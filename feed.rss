<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>WeekRef.NET</title>
		<link>/</link>
		<description>.NET 関連の情報をほぼ週刊配信</description>
		<copyright>Copyright © Mayuki Sawatari &lt;mayuki@misuzilla.org&gt;</copyright>
		<managingEditor>Mayuki Sawatari</managingEditor>
		<pubDate>Mon, 22 Nov 2021 08:44:54 GMT</pubDate>
		<lastBuildDate>Mon, 22 Nov 2021 08:44:54 GMT</lastBuildDate>
		<item>
			<title>2021-11-19: Windows App SDK 1.0, Azure Active Directory's gateway is on .NET 6.0</title>
			<link>/2021/11/19/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/11/19/updates</guid>
			<pubDate>Fri, 19 Nov 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://github.com/microsoft/WindowsAppSDK/releases/tag/v1.0"&gt;Windows App SDK 1.0 がリリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;WinUI 3 も含まれており、モダンな Windows アプリケーションを作るための新しい SDK の大きなマイルストーンの一つに到達したという感じでしょうか。&lt;/p&gt;
&lt;p&gt;次期バージョンではマルチウィンドウや通知、Self-contained XCopy 配置などが計画されているとのことです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://portal.productboard.com/winappsdk/1-windows-app-sdk/tabs/2-planned"&gt;Planned - Windows App SDK | Product Roadmap&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/azure-active-directorys-gateway-is-on-net-6-0/"&gt;Azure Active Directory のゲートウェイを .NET 6 に移行した話&lt;/a&gt;が公開されています。&lt;/p&gt;
&lt;p&gt;9月頃から .NET 5 から .NET 6 に移行して、CPU 使用率を 30% 削減できたそうです。.NET 6 になったことでサーバーも IIS でのホストから HTTP.sys を利用する形に移行し、アプリケーションのパフォーマンスの向上のために Dynamic PGO を有効にして高い効果を得られたそうです。&lt;/p&gt;
&lt;p&gt;Dynamic PGO はワークロードや計測結果次第ではありますが、アプリケーションのパフォーマンス向上に高い効果がある可能性があるので、起動直後の速度がある程度許容できるサーバーアプリケーションなどでは積極的に試してみる価値はあるかもしれません。&lt;/p&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="release-1.0.0-microsoftwindowsappsdk-github"&gt;Release 1.0.0 · microsoft/WindowsAppSDK · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/microsoft/WindowsAppSDK/releases/tag/v1.0"&gt;https://github.com/microsoft/WindowsAppSDK/releases/tag/v1.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows App SDK 1.0 がリリースされた。このリリースには WinUI 3 も含まれている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;WinUI 3
&lt;ul&gt;
&lt;li&gt;新コントロールの追加とビジュアルの更新&lt;/li&gt;
&lt;li&gt;パッケージ化テンプレート&lt;/li&gt;
&lt;li&gt;Windows 10 Version 1809 以降での非パッケージデスクトップアプリ (msix を使用しないデプロイ) のサポート&lt;/li&gt;
&lt;li&gt;Windows 10 Version 1809 のサポート&lt;/li&gt;
&lt;li&gt;Visual Studio 2022 でのホットリロードとライブビジュアルツリーのサポート&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ウィンドウ
&lt;ul&gt;
&lt;li&gt;Win32, WPF, Windows Forms で利用可能なウィンドウを扱う高レベル API &lt;code&gt;AppWindow&lt;/code&gt; の追加&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;入力
&lt;ul&gt;
&lt;li&gt;Pointer API: XAML の入力 API でポインターイベント情報を取得をサポートする API&lt;/li&gt;
&lt;li&gt;InputPointerSource API: XAML の SwapChainPanel でポインターと入力イベントのハンドリングを提供する API&lt;/li&gt;
&lt;li&gt;Cursor API: カーソルのビットマップの変更を可能にする API&lt;/li&gt;
&lt;li&gt;GestureRecognizer API: ドラッグやホールド、クリックといったジェスチャーを取り扱う API&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;アプリのライフサイクル&lt;/li&gt;
&lt;li&gt;DWriteCore&lt;/li&gt;
&lt;li&gt;MRT Core&lt;/li&gt;
&lt;li&gt;デプロイ
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;WindowsPackageType&lt;/code&gt; プロパティを指定することで Windows App SDK の初期化を行う仕組み&lt;/li&gt;
&lt;li&gt;非パッケージアプリ向けの Windows App SDK インストーラーの MSI や既存セットアップへの統合&lt;/li&gt;
&lt;li&gt;.NET の非パッケージアプリ向けのブートストラップ API のラッパー&lt;/li&gt;
&lt;li&gt;パッケージアプリ向けのインストールの検証を行うデプロイメント API&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/kevintgallo/status/1460670079364788227?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;📢 Windows App SDK 1.0 Stable release is live! The WinAppSDK is focused on empowering developers to build the most productive apps on Windows and we&amp;#39;re looking forward to your feedback! Tag your tweets with &lt;a href="https://twitter.com/hashtag/WinAppSDK?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#WinAppSDK&lt;/a&gt; to get the team&amp;#39;s attention! &lt;a href="https://t.co/q9CvT6eHEy"&gt;https://t.co/q9CvT6eHEy&lt;/a&gt;&lt;/p&gt;&amp;mdash; Kevin Gallo (&amp;#64;kevintgallo) &lt;a href="https://twitter.com/kevintgallo/status/1460670079364788227?ref_src=twsrc%5Etfw"&gt;November 16, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/microsoft-ui-xaml/issues/6325"&gt;Announcing: WinUI 3 in Windows App SDK 1.0! 🎆🎉🎇 · Issue #6325 · microsoft/microsoft-ui-xaml&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/apps/windows-app-sdk/stable-channel#version-10"&gt;Stable channel release notes for the Windows App SDK - Windows apps | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="azure-active-directorys-gateway-is-on.net-6.0"&gt;Azure Active Directory's gateway is on .NET 6.0!&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/azure-active-directorys-gateway-is-on-net-6-0/"&gt;https://devblogs.microsoft.com/dotnet/azure-active-directorys-gateway-is-on-net-6-0/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Azure Active Directory のゲートウェイサービスを .NET 5 から .NET 6 へと移行した話。&lt;/p&gt;
&lt;p&gt;Azure AD ゲートウェイは Azure Active Directory の表に立つリバースプロキシーサービスで、TLS終端やフェイルオーバー、ルーティングなどを行い、一日約1,850億リクエストを処理している。記事では2021年の9月にサービスのランタイムを .NET 5 から .NET 6 へと移行した結果の効果とその際どのようなことを行ったのか、学びのあったポイントなどに触れている。&lt;/p&gt;
&lt;p&gt;.NET 6 へと移行した効果としては CPU の使用率が33%低下し、アプリケーションの効率(&lt;code&gt;Request-per-second / CPU 使用率&lt;/code&gt;で求めた値)は50%向上した。&lt;/p&gt;
&lt;p&gt;.NET 6 へアップグレードする上で行ったことは大きく次の2点。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;IIS から HTTP.sys への移行 (.NET 6 になったことで対応できた)&lt;/li&gt;
&lt;li&gt;Dynamic PGO の有効化 (.NET 6 からの新機能)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;IIS から HTTP.sys への移行は、以前 .NET Framework から .NET Core 3.1 へ移行した際に IIS を選択していたが .NET 6 への移行で HTTP.sys の利用を選択した。Kestrel は必要な TLS の機能が不足していたため選択しなかったとのこと。&lt;/p&gt;
&lt;p&gt;HTTP.sys への移行により受けた恩恵は下記の通り。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;27% のアプリケーションの効率の向上&lt;/li&gt;
&lt;li&gt;決定論的キューイングモデル
&lt;ul&gt;
&lt;li&gt;HTTP.sys と IIS でそれぞれリクエストキューを持っていてパフォーマンスの問題が発生することがあったが、IIS がなくなったことで HTTP.sys のキューだけとなった&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;デプロイとスケーリングの体験の向上
&lt;ul&gt;
&lt;li&gt;サイトを展開する前の IIS と ANCM (ASP.NET Core Module) のインストールと構成が不要となり、TLS の設定も HTTP.sys のものだけとなり簡潔になった&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その他移行時の変更点として、TLS の再ネゴシエーション (クライアント証明書)や IIS での TLS 設定の HTTP.sys へのマッピング、non-ASCII なヘッダーを受け入れる設定、モニタリングなどにふれている。&lt;/p&gt;
&lt;p&gt;Dynamic PGO (profile-guided optimization) の有効については次のような設定を行ったとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;set DOTNET_TieredPGO=1&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;Tier0 コンパイル結果の動作で収集された情報を元に Tier1 コンパイルを行う設定。アプリケーションの効率はプレーンな .NET 6 と比較して 8.18% 向上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set DOTNET_TC_QuickJitForLoops=1&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;ループを含むメソッドでの階層化コンパイルを有効にする設定。アプリケーションの効率はプレーンな .NET 6 と比較して 10.2% 向上&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;set DOTNET_ReadyToRun=0&lt;/code&gt;
&lt;ul&gt;
&lt;li&gt;ReadyToRun (AOT) を無効にする設定。上記二つと合わせてアプリケーションの効率はプレーンな .NET 6 と比較して 13.23% 向上&lt;/li&gt;
&lt;li&gt;.NET のコアライブラリーはデフォルトで ReadyToRun が有効な形で出荷されている(AOT 済みで起動パフォーマンスが良い形となっている)。これを無効化することで Dynamic PGO が必要とする Tier0 プロファイリングを可能とする&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その他の学びとして次のようなものを挙げている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SocketsHttpHandler&lt;/code&gt; の .NET 6 での変更に関してのいくつかの問題
&lt;ul&gt;
&lt;li&gt;.NET チームとしてワークアラウンドを見つけたり、改善したりしている&lt;/li&gt;
&lt;li&gt;.NET 6 では新規接続の失敗時に複数のリクエストが影響を受ける。これは ConnectTimeout の値を調整することで対応できる可能性がある&lt;/li&gt;
&lt;li&gt;RST パケットで失敗したリクエストは自動でリトライされなくなり、&amp;quot;An existing connection was forcibly closed by remote host&amp;quot; が発生しやすくなっていた。ワークアラウンドとして HttpClient での再試行や PooledConnectionIdleTimeout を設定することでの RST パケットを減らすといったものがある&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;HTTP.sys サーバーでの挙動の変更や問題の修正など&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="visual-studio-2022-version-17.0.1"&gt;Visual Studio 2022 version 17.0.1&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes#17.0.1.0"&gt;https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes#17.0.1.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 17.0.1 がリリースされた。&lt;/p&gt;
&lt;p&gt;バッチビルドや Xamarin.Forms プロジェクトでの XAML ホットリロードでのクラッシュの修正、プロファイラーの不具合の修正など。&lt;/p&gt;
&lt;h3 id="whats-new-in-windows-forms-in.net-6.0"&gt;What's new in Windows Forms in .NET 6.0&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/whats-new-in-windows-forms-in-net-6-0/"&gt;https://devblogs.microsoft.com/dotnet/whats-new-in-windows-forms-in-net-6-0/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 における Windows Forms の改善点などをまとめた記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;アクセシビリティ
&lt;ul&gt;
&lt;li&gt;UIA のサポートするコントロールの追加や読み上げの改善、いくつかのコントロールのコントラスト改善など&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;アプリケーションブートストラップ
&lt;ul&gt;
&lt;li&gt;アプリケーションワイドなデフォルトフォント設定を行う &lt;code&gt;Application.SetDefaultFont&lt;/code&gt; API の追加&lt;/li&gt;
&lt;li&gt;アプリケーションの初期設定を行う &lt;code&gt;ApplicationConfiguration.Initialize&lt;/code&gt; をコード生成するように。MSBuild のプロパティーを介して設定可能&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;テンプレートの更新
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;global using&lt;/code&gt; などが使用されるようになり、より簡素なエントリーポイントに&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ランタイムのデザイナーの強化&lt;/li&gt;
&lt;li&gt;高 DPI とスケーリングの修正
&lt;ul&gt;
&lt;li&gt;PerMonitorV2 モードのサポートの改善&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;その他
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Control.Invoke&lt;/code&gt; に &lt;code&gt;Func&amp;lt;T&amp;gt;&lt;/code&gt; を受けるオーバーロードの追加など&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;コミュニティーからのコントリビュート
&lt;ul&gt;
&lt;li&gt;FolderBrowserDialog のプロパティの追加や MessageBox の Try Again/Continue ボタン対応など&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="announcing-windows-11-insider-preview-build-22504"&gt;Announcing Windows 11 Insider Preview Build 22504&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blogs.windows.com/windows-insider/2021/11/17/announcing-windows-11-insider-preview-build-22504/"&gt;https://blogs.windows.com/windows-insider/2021/11/17/announcing-windows-11-insider-preview-build-22504/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows 11 Insider Preview Build 22504 が Dev Channel にリリース。&lt;/p&gt;
&lt;p&gt;このリリースから .NET Conf でアナウンスされていた .NET Framework 4.8.1 が含まれており、.NET Framework が ARM64 をネイティブにサポートするようになった。&lt;/p&gt;
&lt;p&gt;現状 ARM64 サポートは x86, x64 と共に &lt;code&gt;%SystemRoot%\Microsoft.NET\FrameworkArm64&lt;/code&gt; にインストールされ、実行ファイルのプラットフォームが ARM64 としてビルドされている場合にのみ ARM64 向け .NET Framework が使用される。AnyCPU を含め、それ以外は今まで通り x86/x64 が使用されエミュレーションで動作する。&lt;/p&gt;
&lt;!-- https://twitter.com/dotnetlibhunt/status/1459795124393701384?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Scott Hunter announcing .NET Framework 4.8.1 with Arm64 support &lt;a href="https://t.co/vpzVBcPsiC"&gt;https://t.co/vpzVBcPsiC&lt;/a&gt;&lt;/p&gt;&amp;mdash; .Net LibHunt (&amp;#64;dotNetLibHunt) &lt;a href="https://twitter.com/dotNetLibHunt/status/1459795124393701384?ref_src=twsrc%5Etfw"&gt;November 14, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="infer-v1.2-interprocedural-memory-safety-analysis-for-c"&gt;Infer# v1.2: Interprocedural Memory Safety Analysis For C#&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/infer-v1-2-interprocedural-memory-safety-analysis-for-c/"&gt;https://devblogs.microsoft.com/dotnet/infer-v1-2-interprocedural-memory-safety-analysis-for-c/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Infer# v1.2 がリリースされた。Infer# は静的コード解析ツールの &lt;a href="https://fbinfer.com/"&gt;Infer&lt;/a&gt; で C# のコードを解析するためのフロントエンド。今年の3月に 1.0 として GA していた。&lt;/p&gt;
&lt;p&gt;今回のリリースではレースコンディションの検知やパフォーマンス向上、カバレッジの拡大などが含まれる。&lt;/p&gt;
&lt;h3 id="release-3.11.6-unoplatformuno"&gt;Release 3.11.6 · unoplatform/uno&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/unoplatform/uno/releases/tag/3.11.6"&gt;https://github.com/unoplatform/uno/releases/tag/3.11.6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Uno Platform 3.11.6 がリリースされた。&lt;/p&gt;
&lt;p&gt;.NET 6 と Visual Studio 2022 の対応が含まれるほか、様々な改善とバグ修正が行われた。&lt;/p&gt;
&lt;p&gt;MAUI のリリースが延期された影響で Uno Platform のプロジェクトテンプレートは Xamain を使用した従来のものが含まれ、.NET 6 でのプロジェクトはプレビューサポートとなるとのこと。&lt;/p&gt;
&lt;h3 id="release-v1.42.0-grpcgrpc"&gt;Release v1.42.0 · grpc/grpc&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/grpc/grpc/releases/tag/v1.42.0"&gt;https://github.com/grpc/grpc/releases/tag/v1.42.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gRPC v1.42.0 がリリースされた。NuGet パッケージとしては 2.42.0 となる。&lt;/p&gt;
&lt;p&gt;.NET のライブラリ部分に関しては Xamarin のビルド関する不具合の修正や特定のケースでメタデータが破損する問題の修正など。&lt;/p&gt;
&lt;h3 id="calendar-for.net-6-ga.net-6-tips-pr-advent-calendar-2021-qiita"&gt;Calendar for 祝 .NET 6 GA！.NET 6 での開発 Tips や試してみたことなど、あなたの「いち推し」ポイントを教えてください【PR】日本マイクロソフト | Advent Calendar 2021 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/advent-calendar/2021/microsoft"&gt;https://qiita.com/advent-calendar/2021/microsoft&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;日本マイクロソフトがサポートしている .NET 6 をメインにした Advent Calendar。&lt;/p&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="new-dependency-injection-features-in.net-6-exploring.net-core-6-part-10"&gt;New dependency injection features in .NET 6: Exploring .NET Core 6 - Part 10&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-10-new-dependency-injection-features-in-dotnet-6/"&gt;https://andrewlock.net/exploring-dotnet-6-part-10-new-dependency-injection-features-in-dotnet-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Microsoft.Extensions.DependencyInjection の .NET 6 での変更点についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IAsyncDisposable&lt;/code&gt; をサポートするスコープの &lt;code&gt;AsyncServiceScope&lt;/code&gt;、Minimal API との組み合わせ、サービスが登録されているかどうかを取得できる &lt;code&gt;IServiceProviderIsService&lt;/code&gt;、診断の強化と TryAdd* のパフォーマンス向上などに触れている。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IServiceProviderIsService&lt;/code&gt; については Minimal API ではラムダのパラメーターが暗黙的に DI コンテナーからの解決となる(Controller のメソッドの場合は &lt;code&gt;[FromService]&lt;/code&gt; が必要)が、その場合パラメータとして渡されるものが DI 由来なのか、値がバインドされたものなのかの区別がつかなくなってしまうため DI コンテナーに登録されているかどうかを取得するためのメカニズムとして用意されているという話。&lt;/p&gt;
&lt;h3 id="rider-2021.3-brand-new-main-toolbar-the.net-tools-blog"&gt;Rider 2021.3 Brand New Main Toolbar | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/11/16/rider-2021-3-brand-new-main-toolbar/"&gt;https://blog.jetbrains.com/dotnet/2021/11/16/rider-2021-3-brand-new-main-toolbar/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rider 2021.3 で導入される新しいデザインのメインツールバーについての記事。&lt;/p&gt;
&lt;h3 id="powerupc-notnullvariable"&gt;PowerUpを使ってC#のアセンブラを見る – NotNullVariable&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://notnullvariable.com/2021/how-to-use-power-up/"&gt;https://notnullvariable.com/2021/how-to-use-power-up/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# のコードが JIT された結果を逆アセンブル確認する PowerUp の使い方についての記事。&lt;/p&gt;
&lt;h3 id="c-c10"&gt;(C#) C#10 で構造体の既定のコンストラクタを禁止する - ネコのために鐘は鳴る&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ikorin2.hatenablog.jp/entry/2021/11/16/064305"&gt;https://ikorin2.hatenablog.jp/entry/2021/11/16/064305&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;構造体のパラメーターなしコンストラクターを C# 10 で記述できるようになったことで使用させないようにできるという記事。&lt;/p&gt;
&lt;h3 id="capture-logs-in-unit-tests"&gt;Capture Logs in Unit Tests&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://kaylumah.nl/2021/11/14/capture-logs-in-unit-tests.html"&gt;https://kaylumah.nl/2021/11/14/capture-logs-in-unit-tests.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ユニットテストで &lt;code&gt;ILogger&lt;/code&gt; をキャプチャーするにはどのような方法があるかという記事。記事では &lt;code&gt;NullLogger&lt;/code&gt;, Moq を使う方法, xUnit の &lt;code&gt;ITestOutputHelper&lt;/code&gt; に流す方法が書かれている。&lt;/p&gt;
&lt;h3 id="overriding-sealed-methods-in-c"&gt;Overriding Sealed Methods in C#&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.infoq.com/articles/overriding-sealed-methods-c-sharp/"&gt;https://www.infoq.com/articles/overriding-sealed-methods-c-sharp/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;sealed&lt;/code&gt; なメソッドをオーバーライドする方法についての記事。&lt;/p&gt;
&lt;p&gt;記事では実行時に動的にメタデータを書き換えることでメソッドを乗っ取るといういわゆる黒魔術的な手法が解説されている。&lt;/p&gt;
&lt;h3 id="where-are-my-favorite-extensions-in-visual-studio-2022"&gt;Where Are My Favorite Extensions in Visual Studio 2022?&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/where-are-my-favorite-extensions-in-visual-studio-2022/"&gt;https://devblogs.microsoft.com/visualstudio/where-are-my-favorite-extensions-in-visual-studio-2022/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;人気のある拡張が Visual Studio 2022 の Marketplace に見つからないといったケースがあるので、それらが何処かに移行したのか、統合されたのかといったことについて紹介している記事。&lt;/p&gt;
&lt;h3 id="dotnet-6.05.0-qiita"&gt;dotnet-6.0におけるシングルファイルアプリの変更点(5.0からの差分) - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/skitoy4321/items/1cb78a42154622daa455"&gt;https://qiita.com/skitoy4321/items/1cb78a42154622daa455&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 でのシングルファイルアプリケーション発行の変更点についてのまとめた記事。&lt;/p&gt;
&lt;p&gt;ネイティブライブラリーの統合、ファイルの圧縮、TrimMode のデフォルト値の変更などについて触れている。&lt;/p&gt;
&lt;h3 id="unity2021.2c9-synamons-engineer-blog"&gt;Unity2021.2で使えるC#9の機能 - Synamon’s Engineer blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://synamon.hatenablog.com/entry/csharp-9-features-on-unity-2021-2"&gt;https://synamon.hatenablog.com/entry/csharp-9-features-on-unity-2021-2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 9.0 に対応した Unity 2021.2 で実際に利用可能な機能についてのまとめた記事。未サポートの機能についても触れている。&lt;/p&gt;
&lt;h3 id="monitoring-a.net-application-using-opentelemetry-gerald-barre"&gt;Monitoring a .NET application using OpenTelemetry - Gérald Barré&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.meziantou.net/monitoring-a-dotnet-application-using-opentelemetry.htm"&gt;https://www.meziantou.net/monitoring-a-dotnet-application-using-opentelemetry.htm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET アプリケーションを OpenTelemetry を通してモニタリングする方法についての記事。&lt;/p&gt;
&lt;p&gt;記事では .NET アプリケーションから OpenTelemetry を通して Zipkin, Prometheus にデータを収集する形を紹介している。&lt;/p&gt;
&lt;h3 id="anomaly-detection-using-ml.net"&gt;Anomaly Detection Using ML.NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://anileladag.medium.com/anomaly-detection-using-ml-net-c01e43774e44"&gt;https://anileladag.medium.com/anomaly-detection-using-ml-net-c01e43774e44&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ML.NET を使用して Anomaly Detection を実装する方法についての記事。&lt;/p&gt;
&lt;h3 id="dapr-a-code-based-approach-with-dotnet"&gt;DAPR: a code-based approach with DOTNET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://satyampushkar.medium.com/dapr-a-code-based-approach-with-dotnet-6570058da51a"&gt;https://satyampushkar.medium.com/dapr-a-code-based-approach-with-dotnet-6570058da51a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dapr を使用して分散した .NET アプリケーションを構成する方法についての記事。&lt;/p&gt;
&lt;h3 id="global-usings-a-look-at-new-language-features-in-c-10-the.net-tools-blog"&gt;Global Usings – A Look at New Language Features in C# 10 | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/11/18/global-usings-in-csharp-10/"&gt;https://blog.jetbrains.com/dotnet/2021/11/18/global-usings-in-csharp-10/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 10 の &lt;code&gt;global using&lt;/code&gt; についての解説と、ReSharper と Rider でのサポートについての記事。&lt;/p&gt;
&lt;h3 id="net-6-vs.net-5-up-to-40-speedup"&gt;.NET 6 vs .NET 5: up to 40% speedup!&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://alexyakunin.medium.com/net-6-vs-net-5-up-to-40-speedup-ceca9112d298"&gt;https://alexyakunin.medium.com/net-6-vs-net-5-up-to-40-speedup-ceca9112d298&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core + Entity Framework Core のサンプルプロジェクトを .NET 5 から .NET 6 に移行して PGO を有効にした結果、40% 程度パフォーマンスが向上したという記事。&lt;/p&gt;
&lt;p&gt;PGO でループやキャッシュフレンドリーなロジックのようなものは 30% から 40%、IO に依存しないコードでは平均 15% 程度、Web サービスのような IO に依存する部分では 5% 程度のパフォーマンス向上がみられたとのこと。&lt;/p&gt;
&lt;h3 id="in-the-jungle-of.net-decompilers-ndepend"&gt;In the Jungle of .NET Decompilers - NDepend&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.ndepend.com/in-the-jungle-of-net-decompilers"&gt;https://blog.ndepend.com/in-the-jungle-of-net-decompilers&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET の逆コンパイラーについて紹介している記事。&lt;/p&gt;
&lt;p&gt;ILSpy, dotPeek, dnSpy, JustDecompile, Ildasm, .NET Reflector など、現在使用されているものから過去のものまで。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="theolivenbaumh5-the-next-generation-c-to-javascript-compiler"&gt;theolivenbaum/h5: 🚀 The next generation C# to JavaScript compiler&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/theolivenbaum/h5"&gt;https://github.com/theolivenbaum/h5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# で書いたコードを JavaScript に Source Generator などで変換する SDK。Bridge の fork。&lt;/p&gt;
&lt;h3 id="damianedwardsminimalapis.extensions-a-set-of-extensions-and-helpers-for-working-with-asp.net-core-minimal-apis"&gt;DamianEdwards/MinimalApis.Extensions: A set of extensions and helpers for working with ASP.NET Core Minimal APIs.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/DamianEdwards/MinimalApis.Extensions"&gt;https://github.com/DamianEdwards/MinimalApis.Extensions&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core の Minimal API の拡張とヘルパーメソッド集。&lt;/p&gt;
&lt;p&gt;ASP.NET Core の Minimal API ではカスタムの戻り値を提供するために &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.iresultextensions?view=aspnetcore-6.0"&gt;IResultExtensions&lt;/a&gt; というものがあり、拡張メソッドを用意することで &lt;code&gt;Results.Extensions.独自のリザルト()&lt;/code&gt; といった形でカスタム戻り値を返せるようになっている。&lt;/p&gt;
&lt;!-- https://twitter.com/damianedwards/status/1459415233559023622?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Trying out &lt;a href="https://twitter.com/hashtag/aspnetcore?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#aspnetcore&lt;/a&gt; Minimal APIs &amp;amp; like the idea of being able to unit-test your APIs &amp;amp; have them self-describe to Swagger (no attributes or metadata needed)? You might like my MinimalApis.Extension library: &lt;a href="https://t.co/3EliX3mCtQ"&gt;https://t.co/3EliX3mCtQ&lt;/a&gt;&lt;br&gt;In preview, pls log issues!&lt;br&gt;fyi &lt;a href="https://twitter.com/nickchapsas?ref_src=twsrc%5Etfw"&gt;&amp;#64;nickchapsas&lt;/a&gt;&lt;/p&gt;&amp;mdash; Damian Edwards #GetVaccinated (&amp;#64;DamianEdwards) &lt;a href="https://twitter.com/DamianEdwards/status/1459415233559023622?ref_src=twsrc%5Etfw"&gt;November 13, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="extensibility-essentials-2022-visual-studio-marketplace"&gt;Extensibility Essentials 2022 - Visual Studio Marketplace&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=MadsKristensen.ExtensibilityEssentials2022"&gt;https://marketplace.visualstudio.com/items?itemName=MadsKristensen.ExtensibilityEssentials2022&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 の拡張を実装する上で便利なツールを提供する Visual Studio の拡張。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/writing-extensions-just-got-easier/"&gt;Writing extensions just got easier - Visual Studio Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="dynamic-pgo-in.net-6.0.md"&gt;Dynamic PGO in .NET 6.0.md&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/EgorBo/dc181796683da3d905a5295bfd3dd95b"&gt;https://gist.github.com/EgorBo/dc181796683da3d905a5295bfd3dd95b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Dynamic PGO の動作内容と簡単なベンチマーク、アプリケーションで Dynamic PGO を有効にする設定方法、コミュニティーフィードバックを載せているドキュメント。&lt;/p&gt;
&lt;!-- https://twitter.com/egorbo/status/1459134952251871247?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Dynamic PGO in .NET 6.0 is 🚀, Please, help us to recognize the efforts Andy, David and the team made to implement this feature by sharing your numbers, read more here: &lt;a href="https://t.co/mskM4S3exi"&gt;https://t.co/mskM4S3exi&lt;/a&gt;&lt;/p&gt;&amp;mdash; Egor Bogatov (&amp;#64;EgorBo) &lt;a href="https://twitter.com/EgorBo/status/1459134952251871247?ref_src=twsrc%5Etfw"&gt;November 12, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="visual-studio"&gt;Visual Studioチャネルとリリースリズム&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/visualstudio/productinfo/release-rhythm"&gt;https://docs.microsoft.com/ja-jp/visualstudio/productinfo/release-rhythm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio のリリースチャネルとそのリリースのリズムについてのドキュメント。&lt;/p&gt;
&lt;p&gt;リリース直後、プロダクト名に Current と表記されていたのは特定バージョンのサービスリリースを行う Long-Term Servicing Channel (LTSC) あることで、最新機能を提供するリリースとの区別のためだったとのこと。Current の表記は version 17.0.1 で削除された。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developercommunity.visualstudio.com/t/why-is-the-visual-studio-2022-having-a-suffix-curr/1575387"&gt;Why is the Visual Studio 2022 having a suffix Current - Visual Studio Feedback&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="csharplanglanguage-version-history.md-at-main-dotnetcsharplang-github"&gt;csharplang/Language-Version-History.md at main · dotnet/csharplang · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md"&gt;https://github.com/dotnet/csharplang/blob/main/Language-Version-History.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# のバージョンごとに追加された言語機能などについての歴史がまとまっているドキュメント。&lt;/p&gt;
&lt;h3 id="migrate-from-asp.net-core-3.1-to-6.0-microsoft-docs"&gt;Migrate from ASP.NET Core 3.1 to 6.0 | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/aspnet/core/migration/31-to-60?view=aspnetcore-6.0&amp;amp;tabs=visual-studio"&gt;https://docs.microsoft.com/ja-jp/aspnet/core/migration/31-to-60?view=aspnetcore-6.0&amp;amp;tabs=visual-studio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core 3.1 から 6.0 に移行するために何をすれば良いのかがまとまっているドキュメント。&lt;/p&gt;
&lt;h3 id="visual-studio-ide-visualstudio-tiktok-watch-visual-studio-ides-newest-tiktok-videos"&gt;Visual Studio IDE (&amp;#64;visualstudio) TikTok | Watch Visual Studio IDE's Newest TikTok Videos&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.tiktok.com/&amp;#64;visualstudio"&gt;https://www.tiktok.com/&amp;#64;visualstudio&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio の TikTok アカウント。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/evocationist/status/1459185145794203684?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Solid .NET6 perf stats from tests I ran earlier today...&lt;br&gt;&lt;br&gt;We have a key throughput benchmark writing+reading UDP on loopback, that averages about a 200MB/sec throughput increase just by changing to .NET6! 🚀&lt;br&gt;&lt;br&gt;That&amp;#39;s amazing gain; nice one, runtime folks.&lt;a href="https://twitter.com/davidfowl?ref_src=twsrc%5Etfw"&gt;&amp;#64;davidfowl&lt;/a&gt; &lt;a href="https://twitter.com/terrajobst?ref_src=twsrc%5Etfw"&gt;&amp;#64;terrajobst&lt;/a&gt; &lt;a href="https://t.co/07KUjjA9ft"&gt;pic.twitter.com/07KUjjA9ft&lt;/a&gt;&lt;/p&gt;&amp;mdash; Alistair Evans (&amp;#64;evocationist) &lt;a href="https://twitter.com/evocationist/status/1459185145794203684?ref_src=twsrc%5Etfw"&gt;November 12, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 5 から .NET 6 に移行しただけでローカルループバックでの UDP の送受信のパフォーマンスが向上したという話。&lt;/p&gt;
&lt;!-- https://twitter.com/marcel_wiessler/status/1459215837802467330?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Did you know that editing &lt;a href="https://twitter.com/unity?ref_src=twsrc%5Etfw"&gt;&amp;#64;unity&lt;/a&gt; asmdef files in &lt;a href="https://twitter.com/JetBrainsRider?ref_src=twsrc%5Etfw"&gt;&amp;#64;JetBrainsRider&lt;/a&gt; got a lot more powerful recently - no it is not automatically adding references yet 😅 - BUT &lt;br&gt;&lt;br&gt;adding references is fast and chill now and I love it 🥰&lt;br&gt;&lt;br&gt;thanks &lt;a href="https://twitter.com/citizenmatt?ref_src=twsrc%5Etfw"&gt;&amp;#64;citizenmatt&lt;/a&gt; &lt;a href="https://t.co/XVgAdvHJ1L"&gt;pic.twitter.com/XVgAdvHJ1L&lt;/a&gt;&lt;/p&gt;&amp;mdash; Marcel Wiessler (&amp;#64;marcel_wiessler) &lt;a href="https://twitter.com/marcel_wiessler/status/1459215837802467330?ref_src=twsrc%5Etfw"&gt;November 12, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Rider で Unity の asmdef を編集すると、参照プロジェクトの補完や GUID への変更、Inlay-hints が表示されるといった手厚いサポートがあるという話。&lt;/p&gt;
&lt;!-- https://twitter.com/marcgravell/status/1459577561084801027?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Got reminded of something on Friday (that I&amp;#39;ve fixed in at least 4 other code-bases in the past): many people now know that accessing the outcome of ValueTask[&amp;lt;T&amp;gt;] more than once us undefined behaviour (thanks to IVTS), but so is *not accessing it at all*; I&amp;#39;ve seen this in (1)&lt;/p&gt;&amp;mdash; Marc Gravell (&amp;#64;marcgravell) &lt;a href="https://twitter.com/marcgravell/status/1459577561084801027?ref_src=twsrc%5Etfw"&gt;November 13, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;次のような &lt;code&gt;ValueTask&lt;/code&gt; を &lt;code&gt;async&lt;/code&gt; で &lt;code&gt;await&lt;/code&gt; しない、ショートカットするようなコードを書いた時の罠の話(スレッド)。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ValueTask FooAsync()
{
    if (pending.IsCompleteSuccessfully)
    {
        return default;
    }
    return Awaited(pending);
}

async ValueTask Awaited(ValueTask pending)
    =&amp;gt; await pending;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;この場合 &lt;code&gt;pending&lt;/code&gt; を &lt;code&gt;await&lt;/code&gt; せずに終わるコードパスに流れた場合、内部の &lt;code&gt;IValueTaskSource&lt;/code&gt; の &lt;code&gt;GetResult&lt;/code&gt; が呼び出されないと &lt;code&gt;IValueTaskSource&lt;/code&gt; がプーリングを実装している場合には無駄なことになってしまうのではないのか、という話。これ自体の修正方法は &lt;code&gt;_ = pending.Result;&lt;/code&gt; のようにする。&lt;/p&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1459624577441705984?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;When you use inheritance in models, you can be not satisfied with the default EF Core columns order in the created tables.&lt;br&gt;&lt;br&gt;In EF Core 6.0, you can specify columns order with ColumnAttribute.&lt;a href="https://twitter.com/hashtag/dotnet6?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet6&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/efcore6?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#efcore6&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt; &lt;a href="https://t.co/1VIhNwzOa4"&gt;pic.twitter.com/1VIhNwzOa4&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1459624577441705984?ref_src=twsrc%5Etfw"&gt;November 13, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Entity Framework Core 6.0 では &lt;code&gt;Column&lt;/code&gt; 属性に &lt;code&gt;Order&lt;/code&gt; を指定できるようになって、データベースのテーブルのカラムの並びを指定できるという話。&lt;/p&gt;
&lt;!-- https://twitter.com/magicknet/status/1459527515618357253?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Also found this &lt;a href="https://t.co/J5olfE9vIQ"&gt;https://t.co/J5olfE9vIQ&lt;/a&gt;. But it is kinda expensive&lt;a href="https://twitter.com/sinclairinat0r?ref_src=twsrc%5Etfw"&gt;&amp;#64;sinclairinat0r&lt;/a&gt; It looks like it is now available in the US?&lt;/p&gt;&amp;mdash; 🧙‍♂️Dirk Lemstra (&amp;#64;MagickNET) &lt;a href="https://twitter.com/MagickNET/status/1459527515618357253?ref_src=twsrc%5Etfw"&gt;November 13, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;US の Microsoft Store で Windows on ARM の Development Kit 的なマシンがひっそりと発売されていたという話。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1459790266877964289?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;This is what a modern basic scalable socket server looks like in .NET &lt;a href="https://t.co/jFhHqp9Rxn"&gt;https://t.co/jFhHqp9Rxn&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧🇺🇸💉💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1459790266877964289?ref_src=twsrc%5Etfw"&gt;November 14, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;モダンでスケーラブルなソケットサーバーの基本的な記述パターンについて。&lt;/p&gt;
&lt;!-- https://twitter.com/olegtk/status/1461153650588454918?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Interestingly there was an attempt to deprecate it in VS 2022, but it got rejected :)&lt;/p&gt;&amp;mdash; Oleg Tkachenko (&amp;#64;olegtk) &lt;a href="https://twitter.com/olegtk/status/1461153650588454918?ref_src=twsrc%5Etfw"&gt;November 18, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;過去、Visual Studio のメニューが大文字 (capitalize) だった時期があり、現在でもそのオプションは残っていて Visual Studio 2022 で非推奨にしようとしたけど却下となったという小ネタ。&lt;/p&gt;
&lt;!-- https://twitter.com/davkean/status/1461166900658925570?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;And finally git operations were added to context menu to make it easy to quickly diff a file against its base, or revert without needing to find it in Solution Explorer. &lt;br&gt;&lt;br&gt;I find this particularly helpful for designers which don&amp;#39;t expose this on their right-click context menu. &lt;a href="https://t.co/mCi8HjAUlm"&gt;pic.twitter.com/mCi8HjAUlm&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Kean (&amp;#64;davkean) &lt;a href="https://twitter.com/davkean/status/1461166900658925570?ref_src=twsrc%5Etfw"&gt;November 18, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Visual Studio のエディターのタブのコンテキストメニューに Git の項目が増えたという話。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="proposal-self-constraint-issue-5413-dotnetcsharplang"&gt;[Proposal]: Self Constraint · Issue #5413 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/5413"&gt;https://github.com/dotnet/csharplang/issues/5413&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Self constraint の提案の Issue。Spec の Proposal 自体はすでに書かれている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/self-constraint.md"&gt;csharplang/self-constraint.md at main · dotnet/csharplang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="remove-r-parameter-for-dotnet-test-and-change-a-parameter-to-be-shorthand-for-arch-instead-of-test-adapter-path-by-marcorossignoli-pull-request-22497-dotnetsdk"&gt;Remove -r parameter for dotnet test, and change -a parameter to be shorthand for --arch, instead of --test-adapter-path by MarcoRossignoli · Pull Request #22497 · dotnet/sdk&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/sdk/pull/22497"&gt;https://github.com/dotnet/sdk/pull/22497&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet test&lt;/code&gt; での &lt;code&gt;-r&lt;/code&gt; は &lt;code&gt;--results-dir&lt;/code&gt;、&lt;code&gt;-a&lt;/code&gt; は &lt;code&gt;--test-adapter-path&lt;/code&gt; の短縮系だったが、他のコマンドと合わせて &lt;code&gt;--runtime&lt;/code&gt; や &lt;code&gt;--arch&lt;/code&gt; となるようにするという破壊的変更の PR。&lt;/p&gt;
&lt;h3 id="api-proposal-convert.toint32-overload-that-takes-a-roschar-instead-of-a-string-issue-61397-dotnetruntime"&gt;[API Proposal]: &lt;code&gt;Convert.ToInt32&lt;/code&gt; overload that takes a &lt;code&gt;ROSchar&lt;/code&gt; instead of a &lt;code&gt;string&lt;/code&gt; · Issue #61397 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/61397"&gt;https://github.com/dotnet/runtime/issues/61397&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Convert.ToInt32&lt;/code&gt; に &lt;code&gt;ReadOnlySpan&amp;lt;char&amp;gt;&lt;/code&gt; を受けるオーバーロードがほしいという提案。&lt;code&gt;Utf8Parser.TryParse&lt;/code&gt; でいいのではないか、提案者は octal を読みたいといっている、実際に欲しいのは &lt;code&gt;ReadOnlySpan&amp;lt;byte&amp;gt;&lt;/code&gt; では、その場合 &lt;code&gt;Encoding&lt;/code&gt; はどうするのか、ニッチなのでコアライブラリーには不要ではとか。&lt;/p&gt;
&lt;h3 id="minor-file.readallbytes-improvements-by-adamsitnik-pull-request-61519-dotnetruntime"&gt;Minor File.ReadAllBytes* improvements by adamsitnik · Pull Request #61519 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/61519"&gt;https://github.com/dotnet/runtime/pull/61519&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File.ReadAllBytes*&lt;/code&gt; を &lt;code&gt;Stream&lt;/code&gt; から &lt;code&gt;RandomAccess&lt;/code&gt; にすることでパフォーマンスを向上するという PR。&lt;/p&gt;
&lt;h3 id="expose-general-purpose-crc32-apis-by-deeprobin-pull-request-61558-dotnetruntime"&gt;Expose general purpose Crc32 APIs by deeprobin · Pull Request #61558 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/61558"&gt;https://github.com/dotnet/runtime/pull/61558&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CRC32 を計算するための API を &lt;code&gt;BitOperation&lt;/code&gt; クラスで公開するという PR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/2036"&gt;Expose general purpose Crc32 APIs · Issue #2036 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="merge-system.security.cryptography.algorithms-to-system.security.cryptography-by-bartonjs-pull-request-61543-dotnetruntime"&gt;Merge System.Security.Cryptography.Algorithms to System.Security.Cryptography by bartonjs · Pull Request #61543 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/61543"&gt;https://github.com/dotnet/runtime/pull/61543&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.Security.Cryptography.Algorithms&lt;/code&gt; にあった各種アルゴリズムの実装を &lt;code&gt;System.Security.Cryptography&lt;/code&gt; に引っ越す PR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-11-12: .NET 6 &amp; Visual Studio 2022 GA, YARP 1.0, LINQPad 7</title>
			<link>/2021/11/12/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/11/12/updates</guid>
			<pubDate>Fri, 12 Nov 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;Visual Studio Launch Event と .NET Conf 2021 が開かれ、.NET 6 と Visual Studio 2022 が11月8日(日本時間の9日)にリリースされました。&lt;/p&gt;
&lt;p&gt;.NET 6 ではランタイムやコアライブラリーの多くの改善だけでなく C# 10 と ASP.NET Core 6 が含まれています。公式のリリース記事はとても長いのですが、C# 10 や global using のようなものからコンテナー下での動作についてや PGO のような細かいものまで載っているのでトピックを眺めて気になる点をつまんでいくのがよさそうです。&lt;/p&gt;
&lt;p&gt;また .NET 6 は LTS リリースであり、現在運用中のアプリケーションが .NET 5 である場合は EOL が半年後ということあるので早めの移行が推奨されています。&lt;/p&gt;
&lt;p&gt;現時点で Visual Studio 2022 または Visual Studio Code の C# 拡張が .NET 6 対応となっていますが、Visual Studio 2022 for Mac のリリースは来年となることがアナウンスされている点は注意が必要です。JetBrains の Rider は現在 EAP での対応で近く対応版がリリースされるのではないかと予想しています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6/"&gt;Announcing .NET 6 - The Fastest .NET Yet - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-now-available/"&gt;Visual Studio 2022 now available - Visual Studio Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.azure.moe/2021/11/09/visual-studio-2022-%E3%83%AD%E3%83%BC%E3%83%B3%E3%83%81-net-6-ga/"&gt;Visual Studio 2022 ローンチ &amp;amp; .NET 6 GA | ブチザッキ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.azure.moe/2021/11/10/net-conf-2021-day-1-keynote/"&gt;.NET Conf 2021 Day 1 Keynote | ブチザッキ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;YARP (Yet Another Reverse Proxy) の 1.0 がリリースされました。&lt;/p&gt;
&lt;p&gt;簡単に言ってしまうと ASP.NET Core でハイパフォーマンスなリバースプロキシーを構築できるライブラリーです。ライブラリーとして提供されているため、利用者のニーズに合わせたカスタマイズがしやすい形になっているというのがウリです。Microsoft の社内でも既に利用されているとのことです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-yarp-1-0-release/"&gt;Announcing YARP 1.0 Release - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://www.linqpad.net/LINQPad7.aspx"&gt;LINQPad 7 がリリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;.NET 6 への対応や ARM64 版の提供などが行われています。メジャーバージョンアップとなるため、無償アップグレード期間外に購入したライセンスの場合は有償アップグレードが必要となります。&lt;/p&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="announcing.net-6-the-fastest.net-yet.net-blog"&gt;Announcing .NET 6 - The Fastest .NET Yet - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6/"&gt;https://devblogs.microsoft.com/dotnet/announcing-net-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 がリリースされた。&lt;/p&gt;
&lt;p&gt;記事では .NET 6 での C# と F# といった言語も含めての多くの改善点がまとめられている。&lt;/p&gt;
&lt;p&gt;サポートについても触れており、.NET 6 は LTS となることで3年間のアップデートがあることで特に .NET 5 からの移行は EOL の都合推奨されている。また Red Hat とのコラボレーションで RHEL 8 以降の AMD/Intel (x86_64), ARM64 (aarch64), IBM Z/LinuxONE (s390x) で利用できるようになるとのこと。&lt;/p&gt;
&lt;p&gt;IDE サポートは Visual Studio 2022 と Visual Studio 2022 for Mac (未リリース) となり、Visual Studio 2019 や MSBuild 16、Visual Studio for Mac 8.0 はサポートされない。Visual Studio Code の C# 拡張は .NET 6 をサポートする。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/uikou/items/a9efa1dda2c3fe5a7b0b"&gt;[GA] Visual Studio 2022 &amp;amp; .NET 6 がリリースされました - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-now-available/"&gt;Visual Studio 2022 now available - Visual Studio Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="welcome-to-c-10"&gt;Welcome to C# 10&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/welcome-to-csharp-10/"&gt;https://devblogs.microsoft.com/dotnet/welcome-to-csharp-10/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 10 での新しく変わった部分についてまとめた記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;グローバルと暗黙的な using&lt;/li&gt;
&lt;li&gt;File-scoped namespaces&lt;/li&gt;
&lt;li&gt;ラムダ式とメソッドグループの改善
&lt;ul&gt;
&lt;li&gt;戻り値型の推論やラムダ式への属性など&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct&lt;/code&gt; の改善
&lt;ul&gt;
&lt;li&gt;パラメータなしコンストラクターとフィールド初期化, &lt;code&gt;record struct&lt;/code&gt;, &lt;code&gt;with&lt;/code&gt; 等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;文字列補完 (Interpolated string) の改善
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;InterpolatedStringHandler&lt;/code&gt; と定数としての文字列補完式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;その他改善
&lt;ul&gt;
&lt;li&gt;deconstruct 時の代入の改善、限定代入の機能強化、拡張プロパティパターンや &lt;code&gt;CallerArgumentExpressionAttribute&lt;/code&gt; など&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プレビュー機能
&lt;ul&gt;
&lt;li&gt;インターフェースの &lt;code&gt;static abstract&lt;/code&gt; メンバー&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;C# ガイドのドキュメントでも詳しく説明されている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/whats-new/csharp-10"&gt;C# 10 の新機能 - C# ガイド | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="whats-new-in-xamarin-and-visual-studio-2022"&gt;What's New in Xamarin and Visual Studio 2022&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/xamarin/whats-new-in-xamarin-and-visual-studio-2022/"&gt;https://devblogs.microsoft.com/xamarin/whats-new-in-xamarin-and-visual-studio-2022/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 と Xamarin のリリースについての記事。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 でサポートされた機能と、Xamarin がサポートするモバイルプラットフォームのバージョンについて、.NET 6 への移行についてなど。&lt;/p&gt;
&lt;p&gt;記事ではMAUI のスケジュールが変更となった影響で Xamarin のサポート期間にも触れ、Xamarin は Microsoft Modern Lifecycle に従い最後にリリースされてから2年間（2023年11月まで) のサポートとなるとのこと。&lt;/p&gt;
&lt;h3 id="announcing.net-maui-preview-10"&gt;Announcing .NET MAUI Preview 10&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-10/"&gt;https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-10/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MAUI Preview 10 がリリースされた。&lt;/p&gt;
&lt;p&gt;このリリースには Visual Studio 2022 の Preview Channel が必要となる。変更点としては &lt;code&gt;CollectionView&lt;/code&gt; と &lt;code&gt;IndicatorView&lt;/code&gt; のハンドラー実装が追加、その他修正や改善など。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/maui/releases/tag/6.0.101-preview.10"&gt;Release 6.0.101-preview.10 · dotnet/maui&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="announcing-asp.net-core-in.net-6"&gt;Announcing ASP.NET Core in .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-asp-net-core-in-net-6/"&gt;https://devblogs.microsoft.com/dotnet/announcing-asp-net-core-in-net-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 と共にリリースされた ASP.NET Core についてまとめた記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ホットリロード&lt;/li&gt;
&lt;li&gt;Minimal API&lt;/li&gt;
&lt;li&gt;非同期ストリーミング&lt;/li&gt;
&lt;li&gt;&lt;code&gt;IAsyncDisposable&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Bootstrap 5.1&lt;/li&gt;
&lt;li&gt;Nullable reference type の対応&lt;/li&gt;
&lt;li&gt;ページとビューでの CSS アイソレーション&lt;/li&gt;
&lt;li&gt;ページとビューでの JavaScript モジュール&lt;/li&gt;
&lt;li&gt;Blazor の改善
&lt;ul&gt;
&lt;li&gt;JavaScript からのコンポーネントのレンダリング&lt;/li&gt;
&lt;li&gt;プリレンダリングのステートの保持&lt;/li&gt;
&lt;li&gt;エラーバウンダリ&lt;/li&gt;
&lt;li&gt;カスタムイベント引数&lt;/li&gt;
&lt;li&gt;ジェネリック型パラメータの推論&lt;/li&gt;
&lt;li&gt;コンポーネントの必須パラメーター&lt;/li&gt;
&lt;li&gt;クエリーストリングのハンドリング&lt;/li&gt;
&lt;li&gt;HTML の &lt;code&gt;head&lt;/code&gt; のコントロール&lt;/li&gt;
&lt;li&gt;JavaScript 初期化&lt;/li&gt;
&lt;li&gt;動的なコンポーネントのレンダリング&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;.NET WebAssembly ビルドツール&lt;/li&gt;
&lt;li&gt;シングルページアプリケーションテンプレート (React, Angular)&lt;/li&gt;
&lt;li&gt;Socket コントロール&lt;/li&gt;
&lt;li&gt;型のついたヘッダー&lt;/li&gt;
&lt;li&gt;HTTP と W3C ロギングフォーマット&lt;/li&gt;
&lt;li&gt;HTTP/3 (プレビュー)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;詳しくは記事からリンクされているドキュメントや個別の記事で紹介されている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/aspnet/core/migration/50-to-60?view=aspnetcore-6.0&amp;amp;tabs=visual-studio"&gt;ASP.NET Core 5.0 から 6.0 への移行 | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="f-6-is-officially-here"&gt;F# 6 is officially here!&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/fsharp-6-is-officially-here/"&gt;https://devblogs.microsoft.com/dotnet/fsharp-6-is-officially-here/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;F# 6 がリリースされた。&lt;/p&gt;
&lt;p&gt;記事ではドキュメントの更新やコミュニティーによるツールのアップデートについて触れている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/whats-new-in-fsharp-6/"&gt;What’s new in F# 6 - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/fsharp/whats-new/fsharp-6"&gt;F# 6 の新機能 - F# ガイド | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-6-on-microsoft-azure"&gt;.NET 6 on Microsoft Azure&lt;/h3&gt;
&lt;p&gt;Azure のサービスでの .NET 6 サポートが開始された。今回は App Service に加え Azure Functions と Azure Static Web Apps も Day 0 でのサポートとなっている。&lt;/p&gt;
&lt;p&gt;App Service は Windows と Linux の両 App Service プランで .NET 6 への対応が行われた。&lt;/p&gt;
&lt;p&gt;Azure Functions も 4.0 がリリースされ、.NET 6 への対応が行われている。
Azure Static Web Apps も同様に .NET 6 への対応が行われ、Azure Functions と合わせてアプリケーションを構築できる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://techcommunity.microsoft.com/t5/apps-on-azure/azure-functions-4-0-and-net-6-support-are-now-generally/ba-p/2933245"&gt;Azure Functions 4.0 and .NET 6 support are now generally available&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://techcommunity.microsoft.com/t5/apps-on-azure/full-stack-net-6-apps-with-blazor-webassembly-and-azure-static/ba-p/2933428"&gt;Full-stack .NET 6 Apps with Blazor WebAssembly and Azure Static Web Apps - Microsoft Tech Community&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://azure.github.io/AppService/2021/11/08/Dot.Net6.on.App.Service.html"&gt;.NET 6 on App Service&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://techcommunity.microsoft.com/t5/apps-on-azure/net-6-now-available-on-app-service/ba-p/2945364"&gt;.NET 6 now available on App Service&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="announcing-yarp-1.0-release.net-blog"&gt;Announcing YARP 1.0 Release - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-yarp-1-0-release/"&gt;https://devblogs.microsoft.com/dotnet/announcing-yarp-1-0-release/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;YARP (Yet Another Reverse Proxy) 1.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;YARP は高速なリバースプロキシーを ASP.NET Core の上に実装するためのオープンソースのライブラリーとなっており、ライブラリー形式であることからユーザーのニーズに合わせた実装を行えるとのこと。&lt;/p&gt;
&lt;p&gt;元々は Microsoft 社内でのリバースプロキシーの構築の相談が度々あったことから、共通のソリューションを用意するといった目的で始まったとのこと。サードパーティーのリバースプロキシーのカスタマイズや独自のリバースプロキシーを持つといったことをしていたが、HTTP/1 の対応はあるが gRPC のような HTTP/2 をサポートする必要があった場合でも実装が難しくなっていた。YARP はその点を ASP.NET Core と .NET および C# を使用してコントロールできるようにする。&lt;/p&gt;
&lt;p&gt;YARP は ASP.NET Core のミドルウェアとしてリクエストを処理することとなるが、大きく二つの利用・カスタマイズ方法が提供される。&lt;/p&gt;
&lt;p&gt;一つは完全なプロキシーとしての機能。これは URL のパターンでルートを定義し、クラスター/宛先を決定するといった機能。宛先のヘルス状態を使用したり、ロードバランシング、セッションアフィニティといったものをサポートする。これらの設定は拡張により外部のサービス、記事では Service Fabric から取得するといったこともできるとしている。&lt;/p&gt;
&lt;p&gt;もう一つの利用方法としては高度な環境向けにルーティングやロードバランシングといったものを使用せず、直接 YARP のリクエストフォワーダーを呼び出す利用方法がある。これは Azure App Service で特定のインスタンスにルーティングするといった目的で使用しているとのこと。&lt;/p&gt;
&lt;p&gt;YARP 1.0 で導入される機能は次のようなものとなる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;構成
&lt;ul&gt;
&lt;li&gt;静的ファイルやプログラマブルな拡張&lt;/li&gt;
&lt;li&gt;アプリケーションコードによるルーティング&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;ルーティングとインバウンド接続
&lt;ul&gt;
&lt;li&gt;SNI/Host によるルート&lt;/li&gt;
&lt;li&gt;URL やヘッダー値によるルーティング&lt;/li&gt;
&lt;li&gt;セッションアフィニティ&lt;/li&gt;
&lt;li&gt;ロードバランシングの複数のアルゴリズム、&lt;/li&gt;
&lt;li&gt;認証/認可と CORS 用ルート&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;プロキシーとアウトバウンド接続
&lt;ul&gt;
&lt;li&gt;URL 書き換え&lt;/li&gt;
&lt;li&gt;リクエストとレスポンスの書き換え&lt;/li&gt;
&lt;li&gt;メソッドの書き換え&lt;/li&gt;
&lt;li&gt;アウトバウンド HTTP 接続の宛先の構成&lt;/li&gt;
&lt;li&gt;プロキシによるリクエスト転送時に標準的なヘッダーの追加&lt;/li&gt;
&lt;li&gt;gRPC と WebSocket のストリーミングを含むトラフィック&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;診断
&lt;ul&gt;
&lt;li&gt;パフォーマンスモニタリングのためのメトリクス&lt;/li&gt;
&lt;li&gt;ロギング&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;全般
&lt;ul&gt;
&lt;li&gt;クラウドスケールパフォーマンス&lt;/li&gt;
&lt;li&gt;ドキュメント&lt;/li&gt;
&lt;li&gt;容易な拡張性&lt;/li&gt;
&lt;li&gt;.NET Core 3.1, .NET 5, .NET 6 のサポート&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;パフォーマンスは参考として10月時点で HTTP/1 での処理で Envoy と比較して高い性能が出ているとしている。&lt;/p&gt;
&lt;p&gt;サポートは ASP.NET Core とコアライブラリーのネットワークチームによって行われ、24時間365日のようなサポートはないが GitHub の Issue は通常24時間以内に応答するとのこと。1.0 のサービスリリースとなり新機能は新バージョンにて提供予定。&lt;/p&gt;
&lt;p&gt;最後に将来的に対応したいものとして HTTP/3 やパフォーマンスの改善、LLHTTP 対応、Service Fabric 対応、Kubernetes 統合といったものが挙げられている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/reverse-proxy"&gt;microsoft/reverse-proxy: A toolkit for developing high-performance HTTP reverse proxy applications.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="visual-studio-2022-preview-release-notes"&gt;Visual Studio 2022 Preview Release Notes&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#1710-pre10--visual-studio-2022-version-171-preview-1-newreleasebutton"&gt;https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#1710-pre10--visual-studio-2022-version-171-preview-1-newreleasebutton&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 version 17.1 Preview 1 がリリースされた。&lt;/p&gt;
&lt;p&gt;Azure App Service のプロセスアタッチサポートの追加や .NET の PDB に埋め込まれたソースコードへの Go To Definition、MAUI Preview 10 のサポート、コード診断結果(Warning など)をインラインで表示する試験的な機能の追加、XAML Hot Reload の改善など。&lt;/p&gt;
&lt;h3 id="communitytoolkitdotnet.net-community-toolkit-is-a-collection-of-helpers-and-apis-that-work-for-all.net-developers-and-are-agnostic-of-any-specific-ui-platform.the-toolkit-is-part-of-the.net-foundation"&gt;CommunityToolkit/dotnet: .NET Community Toolkit is a collection of helpers and APIs that work for all .NET developers and are agnostic of any specific UI platform. The toolkit is part of the .NET Foundation.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/CommunityToolkit/dotnet"&gt;https://github.com/CommunityToolkit/dotnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows Community Toolkit から UI プラットフォームに依存しない .NET 部分が切り離され、.NET Community Toolkit として公開された。&lt;/p&gt;
&lt;p&gt;MVVM ライブラリーや ArrayPoolBufferWriter のようなパフォーマンスのためのヘルパーライブラリーなどが切り出されている。&lt;/p&gt;
&lt;!-- https://twitter.com/sergiopedri/status/1458777113125863430?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;The .NET Community Toolkit is now live! It&amp;#39;s a new home for the MVVM Toolkit, HighPerformance, Diagnostics packages and all .NET APIs from the Windows Community Toolkit. So excited about this, so many new things and improvements planned! 🚀&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt;&lt;a href="https://t.co/9wYk0hbfu3"&gt;https://t.co/9wYk0hbfu3&lt;/a&gt;&lt;/p&gt;&amp;mdash; Sergio Pedri (&amp;#64;SergioPedri) &lt;a href="https://twitter.com/SergioPedri/status/1458777113125863430?ref_src=twsrc%5Etfw"&gt;November 11, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="announcing-dotnet-monitor-in.net-6"&gt;Announcing dotnet monitor in .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-dotnet-monitor-in-net-6/"&gt;https://devblogs.microsoft.com/dotnet/announcing-dotnet-monitor-in-net-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;以前より試験的な位置づけとなっていた &lt;code&gt;dotnet monitor&lt;/code&gt; がサポート対象のリリースとなった。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet monitor&lt;/code&gt; は実行中の .NET アプリケーションから診断情報(ログやトレース、プロセスダンプ)を取得するためのツールでデータを収集するために次の二つの仕組みを持つ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;オンデマンドで収集するための HTTP API の提供&lt;/li&gt;
&lt;li&gt;指定したルールをトリガーを元に収集 (CPUの使用率が高いときに、といったケース)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;dotnet monitor&lt;/code&gt; は .NET CLI Tool とコンテナーイメージでの提供となる。&lt;/p&gt;
&lt;p&gt;記事では HTTP API のユースケースとしてアプリケーションのサイドカーとして &lt;code&gt;dotnet monitor&lt;/code&gt; コンテナーを実行し、&lt;code&gt;curl&lt;/code&gt; などでプロセスのログを取得するといった例を挙げている。どのような HTTP API が提供されているのかについても触れている。&lt;/p&gt;
&lt;p&gt;トリガーに関しても CPU 使用率が 80% 以上が1分以上続いた場合に収集するルールといった例が挙げられている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/dotnet-monitor/tree/main/documentation/api#http-api-documentation"&gt;dotnet-monitor/documentation/api at main · dotnet/dotnet-monitor&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/dotnet-monitor/blob/main/documentation/collectionrules.md#collection-rules"&gt;dotnet-monitor/collectionrules.md at main · dotnet/dotnet-monitor&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-november-2021-updates-5.0.12-and-3.1.21"&gt;.NET November 2021 Updates – 5.0.12 and 3.1.21&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/november-2021-updates/"&gt;https://devblogs.microsoft.com/dotnet/november-2021-updates/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5.0.12 と .NET Core 3.1.21 がリリースされた。&lt;/p&gt;
&lt;p&gt;それぞれセキュリティー関連の更新はなく、ARM64 でのインストーラーの挙動や Entity Framework Core のプーリングなど細かい不具合修正を含むものとなっている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/announcements/issues/204"&gt;November 2021 .NET Updates · Issue #204 · dotnet/announcements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-framework-november-2021-cumulative-update"&gt;.NET Framework November 2021 Cumulative Update&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/net-framework-november-2021-cumulative-update/"&gt;https://devblogs.microsoft.com/dotnet/net-framework-november-2021-cumulative-update/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Framework の2021年11月の累積アップデートがリリースされた。&lt;/p&gt;
&lt;p&gt;セキュリティー関連のアップデートは特になく、品質の向上と一部機能の改善が含まれている。&lt;/p&gt;
&lt;p&gt;機能の改善は主にコンテナー環境のサポートとなっている。コンテナー環境においての CPU とメモリーの上限、少ないヒープの割り当て、プロセス分離モデルのサポート、ProcessorCount の手動設定のサポートなど。設定は環境変数の DOTNET_, COMPLUS_ で行う。&lt;/p&gt;
&lt;h3 id="release-2.0.0-mysql-netmysqlconnector"&gt;Release 2.0.0 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/2.0.0"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/2.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector 2.0.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;このリリースでは DateOnly や TimeOnly 対応や Batch API 対応などを含めた .NET 6 の対応、MySqlBulkCopy API の強化、ConnectionIdlePingTime の廃止、ターゲットフレームワークから netstandard1.3 と netcoreapp2.1 の削除、その他不具合の修正と改善が含まれている。&lt;/p&gt;
&lt;h3 id="announcing-nuget-6.0-source-mapping-package-vulnerabilities-faster-solution-load-oh-my"&gt;Announcing NuGet 6.0 - Source Mapping, Package Vulnerabilities, Faster Solution Load, Oh My!&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/nuget/announcing-nuget-6/"&gt;https://devblogs.microsoft.com/nuget/announcing-nuget-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NuGet 6.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;このリリースでは次のような機能向上があることに触れている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;.NET 6 対応&lt;/li&gt;
&lt;li&gt;ソースマッピング&lt;/li&gt;
&lt;li&gt;Visual Studio 上でのパッケージ脆弱性確認&lt;/li&gt;
&lt;li&gt;リトライとバックオフの設定 (Experimental)&lt;/li&gt;
&lt;li&gt;デフォルト除外拡張子指定&lt;/li&gt;
&lt;li&gt;Visual Studio での廃止情報表示の改善&lt;/li&gt;
&lt;li&gt;Visual Studio でのパッケージ README の追加&lt;/li&gt;
&lt;li&gt;Visual Studio でのソリューション読み込み時間とブランチ切り替え時間の改善&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="integrations-blazor"&gt;Integrations - Blazor&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/fluent-ui/web-components/integrations/blazor"&gt;https://docs.microsoft.com/ja-jp/fluent-ui/web-components/integrations/blazor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Fluent UI Web Components (fast の Fluent UI) の Blazor 統合がリリースされた。&lt;/p&gt;
&lt;p&gt;これにより Fluent UI のビジュアルを持つあらかじめ用意されているコンポーネントを簡単に Blazor に導入できるようになる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/fluent-ui/web-components/components/overview"&gt;Web Components Overview | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/fluentui/status/1458118151531483136?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Today, we&amp;#39;re excited to announce the release of Fluent UI components for Blazor! Learn more at &lt;a href="https://t.co/NsL6nkuzQD"&gt;https://t.co/NsL6nkuzQD&lt;/a&gt;&lt;/p&gt;&amp;mdash; Fluent UI (&amp;#64;fluentui) &lt;a href="https://twitter.com/fluentui/status/1458118151531483136?ref_src=twsrc%5Etfw"&gt;November 9, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="dotnetoss-grants-dotnetos"&gt;DotnetOSS Grants - Dotnetos&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dotnetos.org/initiatives/grants/"&gt;https://dotnetos.org/initiatives/grants/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 系のコンテンツを提供している Dotnetos がオープンソースの支援として傑出した OSS クリエーターを選出して6か月の GitHub Sponsorship を行う DotnetOSS Grants を開始した。&lt;/p&gt;
&lt;p&gt;現時点では Jeremy Skinner 氏、Marc Gravell 氏、Alexandre Mutel 氏に与えられている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dotnetos.org/blog/2021-11-04-dotnetoss-grants/"&gt;Why should we care about the OSS community? | Dotnetos&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="linqpad-7"&gt;LINQPad 7&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.linqpad.net/LINQPad7.aspx"&gt;https://www.linqpad.net/LINQPad7.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LINQPad 7 がリリースされた。&lt;/p&gt;
&lt;p&gt;.NET 6 の対応が行われた。このバージョンから x86 と x64 に加え ARM64 版の提供されるようになり ARM 版 Windows でも利用できるようになった。その他 Entity Framework Core 6.0 への対応、文字列の比較結果を表示する Util.Dif の追加など。&lt;/p&gt;
&lt;p&gt;メジャーバージョンアップとなるため、LINQPad 6 のライセンスからは有償アップグレードする必要がある点に注意(無償アップグレード対象期間外の場合)。&lt;/p&gt;
&lt;h3 id="release-v6.0.0-npgsqlnpgsql"&gt;Release v6.0.0 · npgsql/npgsql&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/npgsql/npgsql/releases/tag/v6.0.0"&gt;https://github.com/npgsql/npgsql/releases/tag/v6.0.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PostgreSQL のドライバー Npgsql 6.0.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;ロードバランシングやフェイルオーバーを含む複数サーバー接続、OpenTelemetry によるトレーシング、timestamp の改善、プレースホルダーの解釈をサーバーで行う Raw SQL モードの追加、.NET 6 で追加されたADO.NET のバッチ API への対応、SSL/TLS の改善、ロジカルレプリケーションサポートの改善、その他 .NET 6 に関連する対応など。timestamp のマッピングなどをはじめとして破壊的変更もいくつか存在する。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://www.npgsql.org/doc/release-notes/6.0.html"&gt;https://www.npgsql.org/doc/release-notes/6.0.html&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="visual-studio-2022-for-mac-preview-3-and-upcoming-native-m1-processor-support"&gt;Visual Studio 2022 for Mac Preview 3, and Upcoming Native M1 Processor Support&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-3-and-upcoming-native-m1-processor-support/"&gt;https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-3-and-upcoming-native-m1-processor-support/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac Preview 3 がリリースされた。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac ではネイティブ macOS 体験にフォーカスしていること。UI を macOS ネイティブのものへと移行し体験とアシスト技術へのサポート向上や IDE の速度向上と安定性の向上を目的としている、など。&lt;/p&gt;
&lt;p&gt;Preview 3 では .NET 6 の GA 版リリースでの開発がサポートされた。&lt;/p&gt;
&lt;p&gt;エディター部分の改善としてサブワードナビゲーションや各種コードフィックス等のリファクタリングの強化が行われている。&lt;/p&gt;
&lt;p&gt;引き続きネイティブ macOS UI への移行が進められ75%が移行されているとする。このリリースでは Git のブランチ管理ダイアログ、NuGet の設定、コードフォーマットとプロジェクトの設定などが移行された。&lt;/p&gt;
&lt;p&gt;近いうちに Apple M1 ネイティブで動作するようになるとのことにも触れている。この対応のために IDE が動作するランタイムを .NET 6 の CLR (現状 Mono) へと変更する予定であり、Intel も含め多くのパフォーマンス改善が得られるようになるとのこと。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac の GA 版リリースは2022年の前半を予定している。&lt;/p&gt;
&lt;h3 id="whats-new-for-visual-basic-in-visual-studio-2022"&gt;What’s New for Visual Basic in Visual Studio 2022&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/whats-new-for-visual-basic-in-visual-studio-2022/"&gt;https://devblogs.microsoft.com/dotnet/whats-new-for-visual-basic-in-visual-studio-2022/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 における Visual Basic 向けの機能強化についての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;フォントの変更&lt;/li&gt;
&lt;li&gt;デバッグ時のブレークポイントの強化&lt;/li&gt;
&lt;li&gt;エディターのサブワードナビゲーション&lt;/li&gt;
&lt;li&gt;継承元へジャンプできる継承マージン&lt;/li&gt;
&lt;li&gt;IntelliSense のシンボル対応、&lt;/li&gt;
&lt;li&gt;インラインパラメータ名ヒント&lt;/li&gt;
&lt;li&gt;リファクタリングの強化&lt;/li&gt;
&lt;li&gt;Windows Forms アプリケーションの起動時の ApplyApplicationDefaults イベントの追加&lt;/li&gt;
&lt;li&gt;ソースジェネレーター対応&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;など、多くの Visual Studio の言語サポートが強化されている。&lt;/p&gt;
&lt;p&gt;記事では既知の問題として、未使用の参照の削除で取りこぼしがあるケース、.editorconfig の設定の多くが C# 固有であること、.vbproj の &lt;code&gt;ApplicationDefaultFont&lt;/code&gt; は現時点では無視されることなどがあるとしている。&lt;/p&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="single-file-apps-in.net-6.net-core-tutorials"&gt;Single File Apps In .NET 6 - .NET Core Tutorials&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dotnetcoretutorials.com/2021/11/10/single-file-apps-in-net-6/"&gt;https://dotnetcoretutorials.com/2021/11/10/single-file-apps-in-net-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 での単一ファイルアプリケーション (Single File App) についての記事。&lt;/p&gt;
&lt;p&gt;記事では 単一ファイルアプリケーションの発行の仕方の基本に加えて .NET 6 で改善されたインメモリー展開や IL Trimming についても触れている。&lt;/p&gt;
&lt;h3 id="unity-2021.2-c-9-qiita"&gt;祝 Unity 2021.2 C# 9 対応！ - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/up-hash/items/b43754c0763866b4fa96"&gt;https://qiita.com/up-hash/items/b43754c0763866b4fa96&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Unity 2021.2 で対応した C# 9 の Unity で利用可能な機能などをまとめた記事。&lt;/p&gt;
&lt;h3 id="source-generator-updates-incremental-generators-exploring.net-core-6-part-9"&gt;Source generator updates: incremental generators: Exploring .NET Core 6 - Part 9&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-9-source-generator-updates-incremental-generators/"&gt;https://andrewlock.net/exploring-dotnet-6-part-9-source-generator-updates-incremental-generators/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 (Roslyn 4.x) で導入された Incremental Source Generator (V2 API) についての解説記事。&lt;/p&gt;
&lt;p&gt;記事では LoggerMessageGenerator のコードを例としてソースジェネレーターの処理のフローとパイプラインの構築方法といったものを解説している。&lt;/p&gt;
&lt;h3 id="net-qiita"&gt;簡易版 .NETのランタイムデバッグをする方法 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/up-hash/items/7b0e9621e9d850e4088a"&gt;https://qiita.com/up-hash/items/7b0e9621e9d850e4088a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET ランタイム (dotnet/runtime) を Visual Studio でビルドしてデバッグ実行するまでの手順についての記事。&lt;/p&gt;
&lt;h3 id="blazor-webassemblyfilesystem"&gt;Blazor WebAssemblyアプリ上に展開されているFileSystemを触る - 窓を作っては壊していた人のブログ&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://teitoku-window.hatenablog.com/entry/2021/10/29/225536"&gt;https://teitoku-window.hatenablog.com/entry/2021/10/29/225536&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Blazor WebAssembly から Emscripten の File System API を介して仮想ファイルシステム(ブラウザー外のファイルシステムにアクセスするものとは別)を操作できるということについての記事。&lt;/p&gt;
&lt;h3 id="blazor-webassemblynativefilereferenceprebuiltwasm"&gt;Blazor WebAssemblyアプリ上で使えるNativeFileReferenceを使ったPreBuiltなwasmを含むパッケージを作ってみる - 窓を作っては壊していた人のブログ&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://teitoku-window.hatenablog.com/entry/2021/11/08/234722"&gt;https://teitoku-window.hatenablog.com/entry/2021/11/08/234722&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly でアクセス可能な仮想ファイルシステムと外部ネイティブライブラリーを組み合わせて利用することについての記事。&lt;/p&gt;
&lt;p&gt;記事では日本語 TTS の Open JTalk を Emscripten でコンパイルして NativeFileReference で参照し、Open JTalk のデータを仮想ファイルシステムに展開するといったことを行っている。&lt;/p&gt;
&lt;h3 id="vlc.dotnet.wpf-qiita"&gt;Vlc.DotNet.Wpfの罠にはまった話 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/admiralhetare/items/576f11302110143bf405"&gt;https://qiita.com/admiralhetare/items/576f11302110143bf405&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vlc.DotNet.Wpf の代わりに LibVLCSharp を使用して WPF アプリケーションでメディアを再生することについての記事。&lt;/p&gt;
&lt;h3 id="visual-studio.net-framework-4.8.net-6-winformswpf-qiita"&gt;Visual Studioで.NET Framework 4.8と.NET 6のソースコードを共存させる (WinForms＆WPF) - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/belre/items/2ea0d3614786786f7cee"&gt;https://qiita.com/belre/items/2ea0d3614786786f7cee&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Framework 4.8 の Windows Forms プロジェクトを.NET 6 でもビルド出来る形に Visual Studio を使用して構成/共存する方法についての記事。&lt;/p&gt;
&lt;h3 id="net-6-new-project-templates-and-minimal-apis.are-you-ready"&gt;.NET 6 New Project Templates and Minimal APIs. Are you ready?&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://platform.uno/blog/net-6-new-project-templates-and-minimal-apis-are-you-ready/"&gt;https://platform.uno/blog/net-6-new-project-templates-and-minimal-apis-are-you-ready/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="msbuild-and-64-bit-visual-studio-2022"&gt;MSBuild and 64-bit Visual Studio 2022&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/msbuild-and-64-bit-visual-studio-2022/"&gt;https://devblogs.microsoft.com/dotnet/msbuild-and-64-bit-visual-studio-2022/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 で MSBuild も 64-bit 化されたことについての記事。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 では MSBuild が 64-bit 化され、Develpper Command Prompt で通る PATH が指すものも 64-bit のものに変更された。この変更は &lt;code&gt;dotnet build&lt;/code&gt; には影響しない。&lt;/p&gt;
&lt;p&gt;これによって既存の 32-bit 環境を想定している MSBuild タスクが動作しなくなることがある。依存する原因としてファイルシステムパスやレジストリーなどを挙げている。他にも 32-bit のライブラリーをラップしている Visual Studio SDK に依存する場合も更新する必要がある。&lt;/p&gt;
&lt;p&gt;記事では 32-bit と 64-bit 両対応方法とテストするパターンなどについて記している。&lt;/p&gt;
&lt;h3 id="bite-size.net-6-unionby-intersectby-exceptby-and-distinctby"&gt;Bite-Size .NET 6 - UnionBy, IntersectBy, ExceptBy, and DistinctBy&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://exceptionnotfound.net/bite-size-dotnet-6-unionby-intersectby-exceptby-and-distinctby/"&gt;https://exceptionnotfound.net/bite-size-dotnet-6-unionby-intersectby-exceptby-and-distinctby/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で LINQ に追加された UnionBy, IntersectBy, ExceptBy, DistinctBy についての記事。&lt;/p&gt;
&lt;p&gt;*By メソッドでは集合の要素を比較する際に要素そのものの代わりに特定のプロパティーなどで比較できる。&lt;/p&gt;
&lt;h3 id="in-memory-automated-ui-testing-asp.net-core"&gt;In Memory Automated UI Testing ASP.NET Core&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/jdinnovensa/in-memory-automated-ui-testing-aspnet-core-106d"&gt;https://dev.to/jdinnovensa/in-memory-automated-ui-testing-aspnet-core-106d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;インメモリーで ASP.NET Core アプリケーションの自動 UI テストを行うことについての記事。&lt;/p&gt;
&lt;p&gt;記事では ASP.NET Core のアプリケーションをテストで実行するのに WebApplicationFactory とブラウザー自動化に .NET 向けの Playwright する形で対応している。
実際に利用した際や CI で実行時に発生する問題についても触れている。&lt;/p&gt;
&lt;h3 id="key-value-store-built-with-cockroachdb.net-5.0-and-entity-framework"&gt;Key-Value store built with CockroachDB, .Net 5.0, and Entity Framework&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/acho_arnold/key-value-store-built-with-cockroachdb-net-50-and-entity-framework-1kl4"&gt;https://dev.to/acho_arnold/key-value-store-built-with-cockroachdb-net-50-and-entity-framework-1kl4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;CockroachDB を使用して .NET 5 と Entity Framework Core で Key-Value ストアを実装する記事。&lt;/p&gt;
&lt;h3 id="net-6-api"&gt;.NET 6 でのAPI変更を眺めてみる&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/udaken/articles/overview-of-dotnet6-api-diff"&gt;https://zenn.dev/udaken/articles/overview-of-dotnet6-api-diff&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 での API の変更点を広く簡単にまとめている記事。&lt;/p&gt;
&lt;h3 id="net-6-preview-system.random"&gt;.NET 6 (Preview) における System.Random の実装変更 - 屋根裏工房改&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andantesoft.hatenablog.com/entry/2021/03/28/231632"&gt;https://andantesoft.hatenablog.com/entry/2021/03/28/231632&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で変更された Random の実装についての解説記事。&lt;/p&gt;
&lt;p&gt;シード未指定時にアルゴリズムとして xoshiro256** が使用されるように変わったこと、出力関数の改善点、パフォーマンスなどについて触れている。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="maoni0realmon-a-monitoring-tool-that-tells-you-when-gcs-happen-in-a-process-and-some-characteristics-about-these-gcs"&gt;Maoni0/realmon: A monitoring tool that tells you when GCs happen in a process and some characteristics about these GCs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/maoni0/realmon"&gt;https://github.com/maoni0/realmon&lt;/a&gt;&lt;/p&gt;
&lt;!-- https://twitter.com/maoni0/status/1457137728743563267?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I&amp;#39;m sharing a very simple utility that lets you see GCs happening in a process in real time. so if you are running something, especially a client app, you could see GCs as they happen. &lt;a href="https://t.co/F3rtU42Rb0"&gt;https://t.co/F3rtU42Rb0&lt;/a&gt;&lt;/p&gt;&amp;mdash; Maoni Stephens (&amp;#64;maoni0) &lt;a href="https://twitter.com/maoni0/status/1457137728743563267?ref_src=twsrc%5Etfw"&gt;November 7, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="artiomchiflexlabs.upsert-flexlabs.upsert-is-a-library-that-brings-upsert-functionality-to-common-database-providers-for-entity-framework-in-their-respective-native-sql-syntax"&gt;artiomchi/FlexLabs.Upsert: FlexLabs.Upsert is a library that brings UPSERT functionality to common database providers for Entity Framework in their respective native SQL syntax&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/artiomchi/FlexLabs.Upsert"&gt;https://github.com/artiomchi/FlexLabs.Upsert&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core で UPDATE OR INSERT いわゆる UPSERT を行うための拡張ライブラリー。SQLServer, PostgreSQL, SQLite, MySQL に対応している。&lt;/p&gt;
&lt;h3 id="github-sharplinersharpliner-use-c-instead-of-yaml-to-define-your-azure-devops-pipelines"&gt;GitHub - sharpliner/sharpliner: Use C# instead of YAML to define your Azure DevOps pipelines&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/sharpliner/sharpliner"&gt;https://github.com/sharpliner/sharpliner&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Azure Pipelines の YAML を C# のソースコードでタイプセーフに記述できるようにするライブラリー。&lt;/p&gt;
&lt;h3 id="microsoftvisualstudioswag-digital-swag-for-microsoft-visual-studio"&gt;microsoft/VisualStudioSwag: Digital swag for Microsoft Visual Studio.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/microsoft/VisualStudioSwag"&gt;https://github.com/microsoft/VisualStudioSwag&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio のデジタル Swag (おみやげ/記念品)。壁紙や 3D データなどが公開されている。&lt;/p&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="section-4"&gt;文字列補間ハンドラーを詳しく学習する&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/whats-new/tutorials/interpolated-string-handler"&gt;https://docs.microsoft.com/ja-jp/dotnet/csharp/whats-new/tutorials/interpolated-string-handler&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で追加された文字列補完式の拡張の文字列補完ハンドラー(InterpolatedStringHandler)の実装方法についてのドキュメント。&lt;/p&gt;
&lt;h3 id="section-5"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/sergiopedri/status/1456203748187979784?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;It took lots of work, but I finally managed to get ComputeSharp running on UWP too, in Release mode with .NET Native! I had to fork/trim TerraFX, then multi-target both and add a whole lot of polyfills and fixups for .NET Standard 2.0, but... It actually works! 🚀&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://t.co/PqUspg9WOm"&gt;pic.twitter.com/PqUspg9WOm&lt;/a&gt;&lt;/p&gt;&amp;mdash; Sergio Pedri (&amp;#64;SergioPedri) &lt;a href="https://twitter.com/SergioPedri/status/1456203748187979784?ref_src=twsrc%5Etfw"&gt;November 4, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;UWP の .NET Native (AOT) でも ComputeSharp を気合で動かせたという話(ComputeSharp は少し前まで .NET 5 向けで現在 .NET 6 向けとなっている)。&lt;/p&gt;
&lt;!-- https://twitter.com/blowdart/status/1457819844858945537?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I know you’re all excited about .NET 6 but I will remind you that the eol for 5 now starts. You have six months to upgrade. &lt;a href="https://t.co/MW4phE47OM"&gt;https://t.co/MW4phE47OM&lt;/a&gt;&lt;/p&gt;&amp;mdash; Barry Dorrans (&amp;#64;blowdart) &lt;a href="https://twitter.com/blowdart/status/1457819844858945537?ref_src=twsrc%5Etfw"&gt;November 8, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 5 の EOL が半年後に来るという話。.NET 5 は LTS ではないためリリースから18か月で EOL を迎えることとなり来年の5月8日がサポート終了日となる。&lt;/p&gt;
&lt;!-- https://twitter.com/kirillosenkov/status/1456678641899737091?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I have just learned that setting the MSBuildDebugEngine=1 environment variable and then starting VS will give you full, proper binlogs from Visual Studio builds (including design-time), read here for details: &lt;a href="https://t.co/0ZG9ffVDK3"&gt;https://t.co/0ZG9ffVDK3&lt;/a&gt;&lt;/p&gt;&amp;mdash; Kirill Osenkov (&amp;#64;KirillOsenkov) &lt;a href="https://twitter.com/KirillOsenkov/status/1456678641899737091?ref_src=twsrc%5Etfw"&gt;November 5, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;環境変数 &lt;code&gt;MSBuildDebugEngine&lt;/code&gt; に &lt;code&gt;1&lt;/code&gt; を設定した状態で Visual Studio を起動することで Visual Studio がビルドした際(デザイン時のものを含む)の binlog を取得できるというテクニック。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="api-proposal-posix-error-codes-issue-61351-dotnetruntime"&gt;[API Proposal]: Posix error codes · Issue #61351 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/61351"&gt;https://github.com/dotnet/runtime/issues/61351&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;POSIX エラーコードを扱う enum などが欲しいという提案。プラットフォームによってエラーコードが違うこと、CLR や Mono は内部でマッピングを持っているが詳細を公開 API にするつもりはないということで閉じられている。&lt;/p&gt;
&lt;h3 id="net-6-uribuilder-breaking-change-not-documented-issue-61363-dotnetruntime"&gt;[.NET 6] UriBuilder breaking change not documented · Issue #61363 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/61363"&gt;https://github.com/dotnet/runtime/issues/61363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;new UriBuilder(&amp;quot;myapp&amp;quot;, &amp;quot;host&amp;quot;, 0, &amp;quot;path&amp;quot;)&lt;/code&gt; のように UriBuilder に独自スキームとポート番号 0 を渡したときに出力する Uri に .NET 5 まではポート番号が含まれていなかったが、.NET 6 で含まれるようになったので破壊的変更ではという Issue。元々 -1 が省略の意味だったので正しく 0 を扱えるようバグ修正した結果とのこと。&lt;/p&gt;
&lt;h3 id="epic-signalr.net7-issue-38196-dotnetaspnetcore"&gt;EPIC: SignalR - .NET7 · Issue #38196 · dotnet/aspnetcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/issues/38196"&gt;https://github.com/dotnet/aspnetcore/issues/38196&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SignalR の .NET 7 でのエピック&lt;/p&gt;
&lt;h3 id="add-enumerable.concat-enumerable.flatten-methods-by-eiriktsarpalis-pull-request-61230-dotnetruntime"&gt;Add Enumerable.Concat &amp;amp; Enumerable.Flatten methods by eiriktsarpalis · Pull Request #61230 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/61230"&gt;https://github.com/dotnet/runtime/pull/61230&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LINQ の &lt;code&gt;Concat&lt;/code&gt; に3つ以上の &lt;code&gt;IEnumerable&amp;lt;TSource&amp;gt;&lt;/code&gt; を受け取るオーバーロードの追加とシーケンスを平坦化する &lt;code&gt;Flatten&lt;/code&gt; メソッドの追加 PR。&lt;/p&gt;
&lt;h3 id="adding-a-proposal-for-the-self-constraint-by-tannergooding-pull-request-5387-dotnetcsharplang"&gt;Adding a proposal for the self-constraint by tannergooding · Pull Request #5387 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/pull/5387"&gt;https://github.com/dotnet/csharplang/pull/5387&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IEquatable&amp;lt;T&amp;gt;&lt;/code&gt; のようなジェネリックパラメーターに実装する型を指定するようなパターン(&lt;code&gt;class Foo : IEquatable&amp;lt;Foo&amp;gt; { ... }&lt;/code&gt;)で型パラメータを自身に制限する制約を追加したいという提案。&lt;/p&gt;
&lt;h3 id="use-file-scoped-namespaces-by-pranavkm-pull-request-38076-dotnetaspnetcore"&gt;Use file scoped namespaces by pranavkm · Pull Request #38076 · dotnet/aspnetcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/pull/38076"&gt;https://github.com/dotnet/aspnetcore/pull/38076&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core のソースコードを file-scoped namespace に変更する PR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-11-05: .NET community support, Advent Calendar, Power Fx</title>
			<link>/2021/11/05/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/11/05/updates</guid>
			<pubDate>Fri, 05 Nov 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;いよいよ来週の11月8日(日本時間11月9日) は &lt;a href="https://visualstudio.microsoft.com/ja/launch/"&gt;Visual Studio 2022 のローンチイベント&lt;/a&gt;、翌日11月9日(日本時間11月10日) は &lt;a href="https://www.dotnetconf.net/"&gt;.NET Conf 2021&lt;/a&gt; で .NET 6 がリリースとなります。&lt;/p&gt;
&lt;p&gt;.NET Conf は各地のローカルコミュニティーイベントもあり、日本では &lt;a href="https://devblog.connpass.com/event/228106/"&gt;11/12(金) 22時からのdevblogラジオ&lt;/a&gt; がそれとなるようです。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/answers/products/dotnet"&gt;Microsoft の .NET コミュニティーサイト&lt;/a&gt;が公開されました。&lt;/p&gt;
&lt;p&gt;Q&amp;amp;A がメインのような感じなので Stack Overflow やフォーラムに近い位置づけになりそうです。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://qiita.com/advent-calendar/2021/csharplang"&gt;Qiita での C# の 2021 年の Advent Calendar&lt;/a&gt; ページが公開されました。&lt;/p&gt;
&lt;p&gt;12月までは時間があり、枠も空いていますので C# 関連で何か書いてみたい方はお早目の登録をおすすめします。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://powerapps.microsoft.com/en-us/blog/power-fx-open-source-now-available/"&gt;ローコードツールの Power Apps の言語 Power Fx がオープンソースでリリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;Power Apps は Excel の式のような文法でコードを記述するのですが、その言語部分である Power Fx がオープンソースでリリースされました。これは C# / .NET で実装されており、Power Apps などとは関係なくアプリケーションに組み込むことが可能なものとなっています。&lt;/p&gt;
&lt;p&gt;プログラマ向けではないが簡易的なロジックを記述できるような仕組みをアプリケーションに組み込みたい場合などには有用かもしれません。&lt;/p&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="net-6-launches-at.net-conf-november-9-11"&gt;.NET 6 Launches at .NET Conf, November 9-11&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/net-6-launches-at-net-conf-november-9-11/"&gt;https://devblogs.microsoft.com/dotnet/net-6-launches-at-net-conf-november-9-11/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オンラインカンファレンスの .NET Conf が11月9日(日本時間では11月10日午前1時)から始まり3日間開催され、その中で .NET 6 のローンチが予定されている。記事では3日間のカンファレンススケジュールの概要と、コミュニティーイベントの紹介、クイズやSwag (おみやげ) について触れている。&lt;/p&gt;
&lt;p&gt;放送は &lt;a href="http://www.dotnetconf.net/"&gt;www.dotnetconf.net&lt;/a&gt;, &lt;a href="https://docs.microsoft.com/learn/tv/"&gt;Microsoft Learn TV&lt;/a&gt;, &lt;a href="https://www.youtube.com/dotnet"&gt;.NET YouTube channel&lt;/a&gt;, &lt;a href="http://www.twitch.tv/visualstudio"&gt;Visual Studio Twitch channel&lt;/a&gt; で行われ、スケジュールは大まかに Day 1 は .NET 6 について/.NET チームからのセッション/キーノート、Day 2 は .NET に関して深掘りするセッションとローカルコミュニティーのスピーカーによる24時間放送、Day 3 は前日からの24時間放送となっている。&lt;/p&gt;
&lt;p&gt;.NET 6 のローンチと .NET Conf に関連して各地でコミュニティーによるローカルイベントも行われる。日本では &lt;a href="https://devblog.connpass.com/event/228106/"&gt;11/12(金) 22時からのdevblogラジオ&lt;/a&gt; でオンラインの配信イベントがある模様。&lt;/p&gt;
&lt;p&gt;最後に20以上のスポンサーが参加する Day 1/2 の Attendee Party で技術的なクイズに答えると賞品が当たるイベントがあること、無料でダウンロード可能な壁紙やテーマなどの Swag があるとのこと。&lt;a href="https://www.dotnetconf.net/swag"&gt;Swag はスポンサー提供のものもあり、抽選でライセンスやバウチャーなどがもらえる。&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.dotnetconf.net/"&gt;.NET Conf 2021&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblog.connpass.com/event/228106/"&gt;devblogラジオ vol.29 ～.NET 6 GA～ #dotnetconf (2021/11/12 22:00〜)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-community-support-microsoft-docs"&gt;.NET community support | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/answers/products/dotnet"&gt;https://docs.microsoft.com/en-us/answers/products/dotnet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET の技術的な Q&amp;amp;A を行える Microsoft のコミュニティーサイトがオープン。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://techcommunity.microsoft.com/t5/net/ct-p/dotnet"&gt;.NET - Microsoft Tech Community&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="entity-framework-biweekly-status-updates-2021-issue-23884-dotnetefcore"&gt;Entity Framework Biweekly Status Updates (2021) · Issue #23884 · dotnet/efcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/issues/23884#issuecomment-961162804"&gt;https://github.com/dotnet/efcore/issues/23884#issuecomment-961162804&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework の隔週ステータスアップデートの11月4日号。&lt;/p&gt;
&lt;p&gt;ほぼ GA 間近ということもあり、大きなトピックはなく、EF Core 7 の計画が進行中なことや品質やドキュメンテーションなどが進んでいるなど。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/ef/core/what-is-new/ef-core-6.0/whatsnew"&gt;EF Core 6.0 の新機能 | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-2.0.0-rc.1-mysql-netmysqlconnector"&gt;Release 2.0.0-rc.1 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/2.0.0-rc.1"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/2.0.0-rc.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector 2.0.0-rc.1 がリリースされた。&lt;/p&gt;
&lt;p&gt;MySqlBulkCopy の強化、&lt;code&gt;netstandard2.0&lt;/code&gt; のサポートの削除、&lt;code&gt;BigInteger&lt;/code&gt; パラメータのサポートなど。&lt;/p&gt;
&lt;h3 id="power-fx-open-source-now-available-microsoft-power-apps"&gt;Power Fx: Open source now available | Microsoft Power Apps&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://powerapps.microsoft.com/en-us/blog/power-fx-open-source-now-available/"&gt;https://powerapps.microsoft.com/en-us/blog/power-fx-open-source-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ローコード開発ツールである Power Apps で使用されている Excel の式のような言語の Power Fx の処理部分がオープンソースでリリースされた。&lt;/p&gt;
&lt;p&gt;Power Fx は C# (.NET) にて実装されており Power Apps とは独立してアプリケーションへの組み込みなどが行えるようになっている。また Language Server なども提供されている。&lt;/p&gt;
&lt;p&gt;ホスティングのサンプルでは .NET コンソールアプリケーションで REPL 形式で実行するものなどが公開されている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/Power-Fx"&gt;microsoft/Power-Fx: Power Fx low-code programming language&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/power-fx-host-samples"&gt;microsoft/power-fx-host-samples: Samples for hosting Power Fx engine.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="c-advent-calendar-2021-qiita"&gt;C#のカレンダー | Advent Calendar 2021 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/advent-calendar/2021/csharplang"&gt;https://qiita.com/advent-calendar/2021/csharplang&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2021年の C# の Advent Calendar の Qiita でのまとめ。現在参加者は募集中の様子。&lt;/p&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="visual-studio-2022-launch-event-agenda"&gt;Visual Studio 2022 Launch Event Agenda&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-launch-event-agenda/"&gt;https://devblogs.microsoft.com/visualstudio/visual-studio-2022-launch-event-agenda/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;11月8日(日本時間11月9日)に開催される Visual Studio 2022 のローンチイベントのアジェンダについての記事。&lt;/p&gt;
&lt;p&gt;イベントでのセッションの一覧とストリーミングが終わった後に公開される Tips &amp;amp; tricks セッションの一覧が公開されている。&lt;/p&gt;
&lt;h3 id="more-flexible-and-inclusive-ways-to-manage-your-documents"&gt;More flexible and inclusive ways to manage your documents&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/personalize-docs/"&gt;https://devblogs.microsoft.com/visualstudio/personalize-docs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 で強化されたドキュメント関連の機能についての記事。&lt;/p&gt;
&lt;p&gt;タブのプロジェクトごとのカラーリングやタブレイアウト位置の変更、タブの設定(選択中の文字のボールド化や最小最大幅)などについて。&lt;/p&gt;
&lt;h3 id="build-client-web-assets-for-your-razor-class-library"&gt;Build client web assets for your Razor Class Library&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/build-client-web-assets-for-your-razor-class-library/"&gt;https://devblogs.microsoft.com/dotnet/build-client-web-assets-for-your-razor-class-library/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Razor Class Library (.razor, .cshtml) にクライアント向けのアセットをビルドして含める方法についての記事。&lt;/p&gt;
&lt;p&gt;npm を使用したビルドから NuGet パッケージにするまでについて解説している。&lt;/p&gt;
&lt;h3 id="bite-size.net-6-maxby-and-minby-in-linq"&gt;Bite-Size .NET 6 - MaxBy() and MinBy() in LINQ&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://exceptionnotfound.net/bite-size-dotnet-6-maxby-and-minby-in-linq/"&gt;https://exceptionnotfound.net/bite-size-dotnet-6-maxby-and-minby-in-linq/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で追加される LINQ の &lt;code&gt;MaxBy&lt;/code&gt; と &lt;code&gt;MinBy&lt;/code&gt; についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MaxBy&lt;/code&gt; と &lt;code&gt;MinBy&lt;/code&gt; に指定した値のセレクターで最大/最小の要素を返すもの。&lt;/p&gt;
&lt;h3 id="c9.0-qiita"&gt;C#9.0 配列入りのレコードってどうだろう 【不変型配列レコード】 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/muniel/items/fd843abc55a5626e5c45"&gt;https://qiita.com/muniel/items/fd843abc55a5626e5c45&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;record&lt;/code&gt; クラスと &lt;code&gt;ImmutableArray&lt;/code&gt; で配列も込みで不変なデータを定義する方法についての記事。&lt;/p&gt;
&lt;h3 id="intrinsicsdouble"&gt;Intrinsicsを使ってdouble配列の合計値を計算を高速化&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/nin_neko/articles/d310270361beba"&gt;https://zenn.dev/nin_neko/articles/d310270361beba&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.Runtime.Intrinsics&lt;/code&gt; の AVX を使用して double の配列を計算する方法とそのパフォーマンスについての記事。&lt;/p&gt;
&lt;h3 id="usage-of-consul-in.net-core-configuration-management"&gt;Usage of Consul in .NET Core - Configuration Management&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/engincanv/usage-of-consul-in-net-core-configuration-management-39h5"&gt;https://dev.to/engincanv/usage-of-consul-in-net-core-configuration-management-39h5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;サービスディスカバリーなどのネットワークサービスを提供する HashiCorp Consul の構成管理部分を .NET から利用する方法についての記事。&lt;/p&gt;
&lt;h3 id="ef-core-6-custom-functions-with-dbfunctionattribute"&gt;EF Core 6: Custom functions with DbFunctionAttribute&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/timur_kh/ef-core-6-custom-functions-with-dbfunctionattribute-1bb3"&gt;https://dev.to/timur_kh/ef-core-6-custom-functions-with-dbfunctionattribute-1bb3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 6 で &lt;code&gt;DbFunction&lt;/code&gt; 属性を持つメソッドを定義することでデータベース関数 (ストアドプロシージャー) を呼び出すことができることについての記事。&lt;/p&gt;
&lt;h3 id="github-copilot-with-c.net.net-core-tutorials"&gt;Github Copilot With C# .NET - .NET Core Tutorials&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dotnetcoretutorials.com/2021/10/30/github-copilot-with-c-net/"&gt;https://dotnetcoretutorials.com/2021/10/30/github-copilot-with-c-net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub Copilot の C# / .NET での対応についてとその使用感についての記事。&lt;/p&gt;
&lt;h3 id="caller-argument-expressions-a-look-at-new-language-features-in-c-10-the.net-tools-blog"&gt;Caller Argument Expressions – A Look at New Language Features in C# 10 | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/11/04/caller-argument-expressions-in-csharp-10/"&gt;https://blog.jetbrains.com/dotnet/2021/11/04/caller-argument-expressions-in-csharp-10/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で導入された &lt;code&gt;CallerArgumentExpressionAttribute&lt;/code&gt; 属性についての解説記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CallerArgumentExpression&lt;/code&gt; を使用すると、指定したパラメーターに対して呼び出し元で指定された式を文字列として取得できるため Assert のようなケースで役立つ。記事では次のような例が紹介されている。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;public static void Main(string[] args)
{
    // What you call
    Assert(args.Length != 1);

    // What gets compiled
    Assert(args.Length != 1, &amp;quot;args.Length != 1&amp;quot;);
}

public static void Assert(
    bool condition,
    [CallerArgumentExpression(&amp;quot;condition&amp;quot;)]
    string conditionExpression = default)
{
    if (!condition)
        throw new Exception($&amp;quot;Condition failed: {conditionExpression}&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;また、ReSharper と Rider ではコード解析により、&lt;code&gt;CallerArgumentExpression&lt;/code&gt; のパラメーターに値を渡すようなコードや存在しないパラメーター名を指定した場合に警告するといった機能があることにも触れている。&lt;/p&gt;
&lt;h3 id="net-system.random"&gt;.NET System.Random の実装と欠陥について ～ 重箱の隅をつつきたおす ～ - 屋根裏工房改&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andantesoft.hatenablog.com/entry/2021/01/09/203050"&gt;https://andantesoft.hatenablog.com/entry/2021/01/09/203050&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;System.Random の実装とその性質や問題点について詳しく解説している記事。&lt;/p&gt;
&lt;h3 id="net-6"&gt;.NET 6: スレッドの改善&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.infoq.com/jp/news/2021/11/net6-Threading/"&gt;https://www.infoq.com/jp/news/2021/11/net6-Threading/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で改善されたスレッド周りの機能についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Parallel.ForEachAsync&lt;/code&gt;、&lt;code&gt;Thread.ManagedThreadId&lt;/code&gt;, &lt;code&gt;Thread.UnsafeStart&lt;/code&gt; やタスクベースのタイマーについてなど。&lt;/p&gt;
&lt;h3 id="net-annotated-monthly-november-2021-the.net-tools-blog"&gt;.NET Annotated Monthly | November 2021 | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/11/02/net-annotated-monthly-november-2021/"&gt;https://blog.jetbrains.com/dotnet/2021/11/02/net-annotated-monthly-november-2021/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JetBrains による .NET 関連の情報まとめ11月号。&lt;/p&gt;
&lt;h3 id="finding.net-memory-leaks-through-soak-testing"&gt;Finding .NET Memory Leaks through Soak Testing&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/k6/finding-net-memory-leaks-through-soak-testing-2ibe"&gt;https://dev.to/k6/finding-net-memory-leaks-through-soak-testing-2ibe&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;メモリーリークを発見するために耐久性テスト(Soak Testing)を行うことについての記事。&lt;/p&gt;
&lt;p&gt;記事では k6 を使用して継続的に負荷をかけることでメモリーリークを発見するといった手法を紹介している。&lt;/p&gt;
&lt;h3 id="hostbuilder-and-host-for-windows-app-sdk"&gt;HostBuilder and Host for Windows App SDK&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/sharpninja/hostbuilder-and-host-for-windows-app-sdk-4lf4"&gt;https://dev.to/sharpninja/hostbuilder-and-host-for-windows-app-sdk-4lf4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows App SDK のアプリケーションにおいて HostBuilder と Host (Generic Host) を使用する方法についての記事。&lt;/p&gt;
&lt;p&gt;いくつかプロジェクトの設定の変更と外部ライブラリー(WindowsAppSdkHost)の使用が必要となるものの HostBuilder スタイルを使用することが可能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/sharpninja/WindowsAppSdkHost"&gt;sharpninja/WindowsAppSdkHost&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="static-analysis-of-the-invisible-c-sources-by-leandro-t.c.melo-nov-2021-shiftleft-blog"&gt;Static Analysis of (the Invisible) C# Sources | by Leandro T. C. Melo | Nov, 2021 | ShiftLeft Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.shiftleft.io/the-invisible-c-code-51f008d8930"&gt;https://blog.shiftleft.io/the-invisible-c-code-51f008d8930&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# コンパイラーが生成するような見えないコードを静的解析するために C# のコードを展開するリライターを開発したという記事。例えば文字列補完式を展開するといったことを行う。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ShiftLeftSecurity/SharpSyntaxRewriter"&gt;ShiftLeftSecurity/SharpSyntaxRewriter&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-code-coverage-on-gitlab"&gt;.NET Code coverage on GitLab&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/tuimm/net-code-coverage-on-gitlab-3e35f08d0f44"&gt;https://medium.com/tuimm/net-code-coverage-on-gitlab-3e35f08d0f44&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitLab 上で .NET のコードのカバレッジを取得し、レポートする方法についての記事。&lt;/p&gt;
&lt;h3 id="anomaly-detection-using-ml.net"&gt;Anomaly Detection Using ML.NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.infoq.com/articles/anomaly-detection-ml-net/"&gt;https://www.infoq.com/articles/anomaly-detection-ml-net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ML.NET を使用して異常検知 (Anomaly Detection) を実装することについての記事。&lt;/p&gt;
&lt;h3 id="improving-logging-performance-with-source-generators-exploring.net-core-6-part-8"&gt;Improving logging performance with source generators: Exploring .NET Core 6 - Part 8&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-8-improving-logging-performance-with-source-generators/"&gt;https://andrewlock.net/exploring-dotnet-6-part-8-improving-logging-performance-with-source-generators/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ILogger&lt;/code&gt; を使用する場合のパフォーマンスの注意点と .NET 6 から導入された Logger の Source Generator を使用する方法についての記事。&lt;/p&gt;
&lt;p&gt;それぞれのケースにおいてのベンチマーク結果なども載せている。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="github-badamczewskipowerup-decompilation-tools-and-high-productivity-utilities"&gt;GitHub - badamczewski/PowerUp: Decompilation Tools and High Productivity Utilities&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/badamczewski/PowerUp"&gt;https://github.com/badamczewski/PowerUp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.cs や .il ファイルを監視してコンパイルした際の JIT コンパイル結果を出力したり、簡易ベンチマークを実行したりできるツール群。&lt;/p&gt;
&lt;!-- https://twitter.com/badamczewski01/status/1455499944987660288?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Made some changes to .NET Decompilation Tools.&lt;br&gt;How each instruction will now show a high-level (C# like) documentation of what it is doing to your code.&lt;br&gt;&lt;br&gt;Link: &lt;a href="https://t.co/uuskcVxsXN"&gt;https://t.co/uuskcVxsXN&lt;/a&gt;&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://t.co/nlmGIib8HJ"&gt;pic.twitter.com/nlmGIib8HJ&lt;/a&gt;&lt;/p&gt;&amp;mdash; Bartosz Adamczewski (&amp;#64;badamczewski01) &lt;a href="https://twitter.com/badamczewski01/status/1455499944987660288?ref_src=twsrc%5Etfw"&gt;November 2, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="asp.net-core-blazor-webassembly"&gt;ASP.NET Core Blazor WebAssembly のセキュリティに関するその他のシナリオ&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/aspnet/core/blazor/security/webassembly/additional-scenarios?view=aspnetcore-5.0"&gt;https://docs.microsoft.com/ja-jp/aspnet/core/blazor/security/webassembly/additional-scenarios?view=aspnetcore-5.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly でアプリケーションを構築する上でセキュリティー関連を中心としたシナリオごとの情報がまとまっているドキュメント。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/andygocke/status/1454583486820405253?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;With .NET 6 around the corner, I wanted to talk about a new feature I’m very excited about: trim warnings! In .NET 3.1 we introduced trimming as a preview feature. Conceptually pretty simple — when publishing self-contained, the trimmer will remove anything unused. 1/&lt;/p&gt;&amp;mdash; Andy Gocke (&amp;#64;andygocke) &lt;a href="https://twitter.com/andygocke/status/1454583486820405253?ref_src=twsrc%5Etfw"&gt;October 30, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;self-contained なアプリケーションの発行時に使用できるトリミングでの警告についての話。(なお .NET 5 まではトリミングはプレビュー機能)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/core/deploying/trimming/fixing-warnings"&gt;トリミングの警告の概要 - .NET | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;メソッドが潜在的にリフレクションや動的コードを使用している(トリム安全ではない)ことを伝える &lt;code&gt;RequiresUnreferencedCode&lt;/code&gt;属性 や動的にアクセスされることがあることをトリマーに伝える &lt;code&gt;DynamicallyAccessedMembers&lt;/code&gt; 属性などでトリミング時に警告できるようになった。&lt;/p&gt;
&lt;!-- https://twitter.com/badamczewski01/status/1453993632365699072?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Similar methods but vastly different results (C# / .NET 5)&lt;br&gt;&lt;br&gt;(The one that doesn&amp;#39;t inline will be slower)&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://t.co/YTL2ULAa5d"&gt;pic.twitter.com/YTL2ULAa5d&lt;/a&gt;&lt;/p&gt;&amp;mdash; Bartosz Adamczewski (&amp;#64;badamczewski01) &lt;a href="https://twitter.com/badamczewski01/status/1453993632365699072?ref_src=twsrc%5Etfw"&gt;October 29, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;一見単純なケースでも文字列補完式はボックス化や String.Format の呼び出しなどがあるからインライン化されないことがあるという話。&lt;/p&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1453828375735373825?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;New math APIs have been added in .NET 6.&lt;br&gt;&lt;br&gt;New methods:&lt;br&gt;• SinCos&lt;br&gt;• ReciprocalEstimate&lt;br&gt;• ReciprocalSqrtEstimate &lt;br&gt;&lt;br&gt;New overloads:&lt;br&gt;• Min, Max, Abs, Sign, Clamp supports nint and nuint&lt;br&gt;• DivRem variants return a tuples&lt;a href="https://twitter.com/hashtag/dotnet6?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet6&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt; &lt;a href="https://t.co/jIxZAQbAfM"&gt;pic.twitter.com/jIxZAQbAfM&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1453828375735373825?ref_src=twsrc%5Etfw"&gt;October 28, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 で &lt;code&gt;Math&lt;/code&gt; クラスに追加されたメソッドとオーバーロードについての話。&lt;/p&gt;
&lt;!-- https://twitter.com/egorbo/status/1455856153557098497?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;A few examples where a more aggressive inliner in .NET 6.0 pays off (slides from my talk): &lt;a href="https://t.co/mWXdW6w9cC"&gt;pic.twitter.com/mWXdW6w9cC&lt;/a&gt;&lt;/p&gt;&amp;mdash; Egor Bogatov (&amp;#64;EgorBo) &lt;a href="https://twitter.com/EgorBo/status/1455856153557098497?ref_src=twsrc%5Etfw"&gt;November 3, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 では.NET 5 の時よりも積極的なインライン化が効果的に働くことがあるという話。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="vectorize-spanhelperst.indexof-by-alexcovington-pull-request-60974-dotnetruntime"&gt;Vectorize SpanHelpers&amp;lt;T&amp;gt;.IndexOf by alexcovington · Pull Request #60974 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60974"&gt;https://github.com/dotnet/runtime/pull/60974&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;各種コレクションなどの内部で使用している &lt;code&gt;SpanHelper&amp;lt;T&amp;gt;.IndexOf&lt;/code&gt; の処理をベクトル化する PR。&lt;/p&gt;
&lt;h3 id="add-instructions-for-using-codespaces-by-eerhardt-pull-request-60996-dotnetruntime"&gt;Add instructions for using Codespaces by eerhardt · Pull Request #60996 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60996"&gt;https://github.com/dotnet/runtime/pull/60996&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub Codespaces を使用して開発する手順書の PR。&lt;/p&gt;
&lt;h3 id="update-the-interpolated-string-handler-spec-by-333fred-pull-request-5365-dotnetcsharplang"&gt;Update the interpolated string handler spec by 333fred · Pull Request #5365 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/pull/5365"&gt;https://github.com/dotnet/csharplang/pull/5365&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Interpolated string handler をメンバー初期化子のインデクサーで使用したときの制限についての記述を追加した PR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/57456"&gt;Forbid interpolated string handler conversions that reference an instance as indexer arguments in nested member initializers by 333fred · Pull Request #57456 · dotnet/roslyn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="proposal-collection-literals-issue-5354-dotnetcsharplang"&gt;[Proposal]: Collection literals · Issue #5354 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/5354"&gt;https://github.com/dotnet/csharplang/issues/5354&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ターゲットの型から類推してコレクションを作成するためのリテラル文法を導入したいという提案。&lt;/p&gt;
&lt;h3 id="remove-libuv-transport-and-dependency-by-tratcher-pull-request-38005-dotnetaspnetcore"&gt;Remove Libuv transport and dependency by Tratcher · Pull Request #38005 · dotnet/aspnetcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/pull/38005"&gt;https://github.com/dotnet/aspnetcore/pull/38005&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5.0 の ASP.NET Core (Kestrel) から obsolete となっていた Libuv トランスポートを削除する PR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/aspnet/Announcements/issues/476"&gt;[Breaking change]: Microsoft.AspNetCore.Server.Kestrel.Transport.Libuv and Libuv.dll removed · Issue #476 · aspnet/Announcements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="add-proposal-for-params-spant-by-cston-pull-request-5382-dotnetcsharplang"&gt;Add proposal for &lt;code&gt;params Span&amp;lt;T&amp;gt;&lt;/code&gt; by cston · Pull Request #5382 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/pull/5382"&gt;https://github.com/dotnet/csharplang/pull/5382&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;params Span&amp;lt;T&amp;gt;&lt;/code&gt; の提案実装の PR。&lt;/p&gt;
&lt;h3 id="nativeaot-in.net-7-issue-61231-dotnetruntime"&gt;NativeAOT in .NET 7 · Issue #61231 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/61231"&gt;https://github.com/dotnet/runtime/issues/61231&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 7 の NativeAOT に向けてのタスクリスト Issue。&lt;/p&gt;
&lt;p&gt;スコープ外とされているものは ASP.NET MVC や WPF のようなリフレクション依存フレームワーク、MSBuild のような動的アセンブリーロードを含むアプリケーション、Mono が現在提供中のモバイルと WASM となっている。&lt;/p&gt;
&lt;h3 id="adding-support-for-x86base.pause-and-armbase.yield-by-tannergooding-pull-request-61065-dotnetruntime"&gt;Adding support for X86Base.Pause() and ArmBase.Yield() by tannergooding · Pull Request #61065 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/61065"&gt;https://github.com/dotnet/runtime/pull/61065&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;x86 の PAUSE インストラクションと ARM の YIELD インストラクションのサポートを追加する PR。&lt;/p&gt;
&lt;p&gt;スピンウェイトの改善のために導入したいという目的のよう。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/53532"&gt;Introduce pause intrinsics in order to support spin wait loop indication · Issue #53532 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="memory-allocation-in.net-fails-at-70-of-the-container-limit-when-running-in-kubernetes-issue-61076-dotnetruntime"&gt;Memory allocation in .NET fails at 70% of the container limit when running in Kubernetes · Issue #61076 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/61076"&gt;https://github.com/dotnet/runtime/issues/61076&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kubernetes というかコンテナー上で .NET アプリケーションを動かすとメモリーのリミットの70%で Out-of-Memory になるという Issue。&lt;/p&gt;
&lt;p&gt;.NET GC のデフォルトは 75% を割り当て上限として扱っていて、残りは .NET のネイティブ部分や外部ライブラリーで使用されることを期待している。このケースでは 75% のうち 5% はランタイムがコードに対して使用しているため 70% で落ちているのではないか、この閾値は GC 設定の &lt;code&gt;System.GC.HeapHardLimitPercent&lt;/code&gt; を設定することで変更できるといった話。&lt;/p&gt;
&lt;h3 id="allow-running-simple.exe-files-without.runtimeconfig.json-issue-22384-dotnetsdk"&gt;Allow running simple .exe files without .runtimeconfig.json · Issue #22384 · dotnet/sdk&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/sdk/issues/22384"&gt;https://github.com/dotnet/sdk/issues/22384&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet myapp.exe&lt;/code&gt; で .runtimeconfig.json がないようなシンプルな実行ファイル、例えば &lt;code&gt;net472&lt;/code&gt; なものを指定したときにも実行できていいのでは?という Issue。&lt;/p&gt;
&lt;p&gt;.NET Core でもないものを動かせる必要があるのかそれならばネイティブバイナリも動かせる必要があるのではないかといったツッコミも入っている。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-10-29: Hot Reload, Visual Studio 2022 RC3 &amp; Preview 7, GitHub Universe 2021</title>
			<link>/2021/10/29/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/10/29/updates</guid>
			<pubDate>Fri, 29 Oct 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/net-hot-reload-support-via-cli/"&gt;&lt;code&gt;dotnet&lt;/code&gt; コマンドから一度削除された Hot Reload が戻ってきました。&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;削除に対するプロセスがあまり健全ではなく、コミュニティーからの大きな反発を受けて revert される形となりました。また Rider もホットリロードのサポートをアナウンスしています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/25/hot-reload-for-net-6-in-rider-2021-3/"&gt;Hot Reload for .NET 6 in Rider 2021.3 | The .NET Tools Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#17.0.0-pre.7.0"&gt;Visual Studio 2022 の RC3 と Preview 7 がリリース&lt;/a&gt;されています。RC2 / Preview 6 同様、更新内容は不具合の修正です。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://www.githubuniverse.com/"&gt;GitHub Universe 2021&lt;/a&gt; が10月27日、28日に開かれました。&lt;/p&gt;
&lt;p&gt;その中で新しい Issue のベータ公開やコマンドパレット機能、 Codespaces に関する CLI ツールの強化といった新機能がいくつか発表されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.blog/2021-10-27-everything-new-from-universe-2021/"&gt;Everything new from Universe 2021 | The GitHub Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://www.raspberrypi.com/news/new-raspberry-pi-zero-2-w-2/"&gt;Raspberry Pi Zero 2 W&lt;/a&gt; が発表されました。&lt;/p&gt;
&lt;p&gt;Raspberry Pi Zero では SoC に BCM2835 (ARM11 コア, ARMv6 アーキテクチャー) が搭載されていましたが、Zero 2 では Raspberry Pi 3 と同じ BCM2710A1 (Cortex-A53 コア, ARMv8 アーキテクチャー) となっています。&lt;/p&gt;
&lt;p&gt;.NET Core や .NET 5 以降では ARM アーキテクチャーをサポートしていますが、サポートするアーキテクチャーの下限は ARMv7 となっており、ARMv6 の Raspberry Pi Zero では動作しませんでした。今回 ARMv8 アーキテクチャーとなることで .NET アプリケーションの動作が可能となることが期待できます。&lt;/p&gt;
&lt;p&gt;スイッチサイエンスによるとまだ工事設計認証が取得できていないので日本での販売は少し先になるようです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/7764"&gt;Arm6 Raspberry PI Zero - PI 1 · Issue #7764 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://prtimes.jp/main/html/rd/p/000000060.000064534.html"&gt;Raspberry Pi財団が2021年10月28日に新製品「Raspberry Pi Zero 2 W」を発表、スイッチサイエンスウェブショップでも近く発売予定&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="net-hot-reload-support-via-cli"&gt;.NET Hot Reload Support via CLI&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/net-hot-reload-support-via-cli/"&gt;https://devblogs.microsoft.com/dotnet/net-hot-reload-support-via-cli/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;削除されたホットリロードを戻す Pull Request を取り込み、GA に含まれるアナウンス。&lt;/p&gt;
&lt;p&gt;記事では Visual Studio を優先したため削除したといった経緯などについても触れている。&lt;/p&gt;
&lt;h3 id="whats-new-in-the-rider-2021.3-eap5"&gt;What’s new in the Rider 2021.3 EAP5&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://twitter.com/jetbrainsrider/status/1451555367117275163"&gt;https://twitter.com/jetbrainsrider/status/1451555367117275163&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rider 2021.3 EAP5 がリリースされた。&lt;/p&gt;
&lt;p&gt;.NET 6 のホットリロードサポートの追加、.NET 5/.NET Core 3.x の XAML プレビュー対応、NuGet のバインディングリダイレクト、Unity サポートの向上などが含まれる。&lt;/p&gt;
&lt;p&gt;.NET のホットリロードサポートは .NET 6 をターゲットとしたときに利用可能となる。ASP.NET Core であれば Razor テンプレート、それ以外のアプリケーション形式(コンソールアプリケーション、Windows Forms、WPF、WinUI 等)であっても機能するが、現状 C# のホットリロードにフォーカスしているため XAML のホットリロードは限定的となっている。&lt;/p&gt;
&lt;p&gt;その他、現状の制限事項として下記のものが挙げられている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ASP.NET Core アプリケーションの自動ページリロード機能がない&lt;/li&gt;
&lt;li&gt;デバッグ実行中のホットリロードは Windows に限定される&lt;/li&gt;
&lt;li&gt;F# と VB ではホットリロードがサポートされない&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;その他、.NET 5 と .NET Core 3.x の XAML プレビューに対応 (.NET 6 の対応は含まれない)、.NET Framework アプリケーションのプロジェクトで NuGet のバインディングリダイレクトを自動生成処理の追加、フォーマットとクリーンアップで複数のファイルやディレクトリを対象にできるようになった、Unity 向けの対応として .asmdef の条件付きシンボルの対応や Apple Silicon の Mac でファイルを Unity から開けない不具合の修正など。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/25/hot-reload-for-net-6-in-rider-2021-3/"&gt;Hot Reload for .NET 6 in Rider 2021.3 | The .NET Tools Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.jetbrains.com/rider/nextversion/"&gt;Early Access Program - Rider: Cross-platform .NET IDE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="resharper-2021.3-eap5-is-here"&gt;ReSharper 2021.3 EAP5 is here!&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://twitter.com/resharper/status/1451551846280138754"&gt;https://twitter.com/resharper/status/1451551846280138754&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReSharper 2021.3 EAP5 がリリースされた。&lt;/p&gt;
&lt;p&gt;メンバー実装のガターマークの最適化が行われデフォルトで有効化、dotPeek においてレコード型とレコード構造体に対応、dotTrace、dotCover、dotMemory のコマンドラインツールが Apple Silicon のネイティブビルドで提供されるようになったなど。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.jetbrains.com/resharper/nextversion/#section=windows"&gt;Early Access Program (EAP) - ReSharper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/resharper/status/1451551846280138754?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;ReSharper 2021.3 EAP5 is here! &lt;br&gt;📈 Optimized gutter marks for member implementation&lt;br&gt;🆙 Support for records and record structs in dotPeek&lt;br&gt;🍏 Command Line Tools for dotTrace, dotCover, and dotMemory support Apple silicon &lt;a href="https://t.co/PeC86UzarO"&gt;https://t.co/PeC86UzarO&lt;/a&gt; &lt;a href="https://t.co/hzXkbbV0xx"&gt;pic.twitter.com/hzXkbbV0xx&lt;/a&gt;&lt;/p&gt;&amp;mdash; JetBrains ReSharper (&amp;#64;resharper) &lt;a href="https://twitter.com/resharper/status/1451551846280138754?ref_src=twsrc%5Etfw"&gt;October 22, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="visual-studio-2022-version-17.0-rc3-and-preview-7"&gt;Visual Studio 2022 version 17.0 RC3 and Preview 7&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#17.0.0-pre.7.0"&gt;https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#17.0.0-pre.7.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 version 17.0 RC3 と Preview 7 がリリースされた。&lt;/p&gt;
&lt;p&gt;Windows Forms のデザイナーの修正や Xamarin.Forms のテンプレートの更新、ホットリロードをはじめとする不具合の修正を含む。&lt;/p&gt;
&lt;h3 id="everything-new-from-universe-2021-the-github-blog"&gt;Everything new from Universe 2021 | The GitHub Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.blog/2021-10-27-everything-new-from-universe-2021/"&gt;https://github.blog/2021-10-27-everything-new-from-universe-2021/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub Universe 2021 が10月27日、28日に開かれ、GitHub に関するアナウンスがあった。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.blog/changelog/2021-10-27-the-new-github-issues-public-beta/"&gt;新しい Issue (Project) が公開ベータへ&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;GitHub Discussion の改善
&lt;ul&gt;
&lt;li&gt;ラベルが追加&lt;/li&gt;
&lt;li&gt;GitHub Actions との連携&lt;/li&gt;
&lt;li&gt;将来的な機能として Poll (投票) と Community insight ダッシュボードの提供を予定&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GitHub Actions の強化
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.blog/changelog/2021-10-27-github-actions-secure-cloud-deployments-with-openid-connect/"&gt;GitHub Actions: Secure cloud deployments with OpenID Connect&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.blog/changelog/2021-10-27-command-palette-beta/"&gt;コマンドパレット&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;Ctrl-K/Cmd-K で呼び出せる Visual Studio Code などにあるものと似たツール&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.blog/changelog/2021-10-27-pull-request-merge-queue-limited-beta/"&gt;Pull request merge queue の Limited Beta&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.blog/changelog/2021-10-27-new-codespaces-features-launching-at-universe-2021/"&gt;GitHub Codespaces の強化&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.github.com/en/codespaces/customizing-your-codespace/configuring-codespaces-for-your-project#adding-additional-features-to-your-devcontainerjson-file"&gt;devcontainer feature&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;定義済みの devcontainer にツールなどを簡単に追加できる仕組み&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;GitHub CLI による Codespaces の作成や SSH での接続、ポートフォワーディングなど&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/github/status/1453389061478043652?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;You can now use the cmd-k / ctrl-k keyboard shortcut to navigate around GitHub without taking your hands off the keyboard. &lt;a href="https://t.co/H31sg6BdRl"&gt;https://t.co/H31sg6BdRl&lt;/a&gt; &lt;a href="https://t.co/TbCjGcZt6T"&gt;pic.twitter.com/TbCjGcZt6T&lt;/a&gt;&lt;/p&gt;&amp;mdash; GitHub (&amp;#64;github) &lt;a href="https://twitter.com/github/status/1453389061478043652?ref_src=twsrc%5Etfw"&gt;October 27, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;!-- https://twitter.com/corywilkerson/status/1453385231264714756?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;🚢&lt;a href="https://twitter.com/github?ref_src=twsrc%5Etfw"&gt;&amp;#64;github&lt;/a&gt; Codespaces + cli. Codespaces from your home in the terminal. ssh and make something great! &lt;a href="https://t.co/Wa2zGC7Cpr"&gt;pic.twitter.com/Wa2zGC7Cpr&lt;/a&gt;&lt;/p&gt;&amp;mdash; Cory Wilkerson (&amp;#64;corywilkerson) &lt;a href="https://twitter.com/corywilkerson/status/1453385231264714756?ref_src=twsrc%5Etfw"&gt;October 27, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;!-- https://twitter.com/github/status/1453386345766957064?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;The new Issues public beta is available to everyone, no sign up required. Learn more at &lt;a href="https://t.co/H31sg6BdRl"&gt;https://t.co/H31sg6BdRl&lt;/a&gt; &lt;a href="https://t.co/swOMyNBuRN"&gt;pic.twitter.com/swOMyNBuRN&lt;/a&gt;&lt;/p&gt;&amp;mdash; GitHub (&amp;#64;github) &lt;a href="https://twitter.com/github/status/1453386345766957064?ref_src=twsrc%5Etfw"&gt;October 27, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="windows-terminal-preview-1.12-release"&gt;Windows Terminal Preview 1.12 Release&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/commandline/windows-terminal-preview-1-12-release/"&gt;https://devblogs.microsoft.com/commandline/windows-terminal-preview-1-12-release/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows Terminal Preview 1.12 がリリースされた。&lt;/p&gt;
&lt;p&gt;様々なアプリケーションから起動されるデフォルトターミナルの設定を Windows Terminal に変更できるようになった。Windows Insider Program Dev Channel または Windows 11 で利用可能。&lt;/p&gt;
&lt;p&gt;対象となる実行ファイルなどによってプロファイルがあった形での起動が可能となった。例えばスタートから起動されるコマンドプロンプトと PowerShell で開かれるプロファイルがそれぞれ異なるといったケースに対応できる。&lt;/p&gt;
&lt;p&gt;前回のウィンドウ状態(ペインとタブ)を復元する機能が追加、ウィンドウのターミナル部分の完全な透過の対応や細かい改善や修正など。&lt;/p&gt;
&lt;h3 id="new-product-raspberry-pi-zero-2-w-on-sale-now-at-15-raspberry-pi"&gt;New product: Raspberry Pi Zero 2 W on sale now at $15 - Raspberry Pi&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.raspberrypi.com/news/new-raspberry-pi-zero-2-w-2/"&gt;https://www.raspberrypi.com/news/new-raspberry-pi-zero-2-w-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Raspberry Pi Zero 2 W が発表された。&lt;/p&gt;
&lt;p&gt;Raspberry Pi Zero と同じフォームファクターで SoC が Raspberry Pi 3 と同じ BCM2710A1 (Cortex-A53 コア, ARMv8 アーキテクチャー) にアップグレード。スイッチサイエンスでの発売は工事設計認証を取得次第とのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://prtimes.jp/main/html/rd/p/000000060.000064534.html"&gt;Raspberry Pi財団が2021年10月28日に新製品「Raspberry Pi Zero 2 W」を発表、スイッチサイエンスウェブショップでも近く発売予定&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.switch-science.com/catalog/7600/"&gt;Raspberry Pi Zero 2 W【発売予定】 - スイッチサイエンス&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.raspi.jp/2021/10/raspberry-pi-zero-2-w-report/"&gt;Raspberry Pi Zero 2 Wを見て触ってレポート&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="webassembrysilverlightopensilver-qiita"&gt;WebAssembry上で動くSilverlight、OpenSilverで何が出来るのか - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/karuakun/items/b1c6a1b08a62b9e8d588"&gt;https://qiita.com/karuakun/items/b1c6a1b08a62b9e8d588&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WebAssembly で動作する Silverlight 互換実装の OpenSilver のインストールや簡単な使用感についての記事。&lt;/p&gt;
&lt;h3 id="proxy-any-class-by-interface-in-c-with-dispatchproxy"&gt;Proxy any class by interface in C# with DispatchProxy&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/nullabletype/proxy-any-class-by-interface-in-c-with-dispatchproxy-2i6a"&gt;https://dev.to/nullabletype/proxy-any-class-by-interface-in-c-with-dispatchproxy-2i6a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.Reflection.DispatchProxy&lt;/code&gt; の簡単な使い方の解説記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DispatchProxy&lt;/code&gt; クラスを継承することでインターフェースのメソッド実行に対するプロキシーを簡単に実装することができる。記事ではその際のパフォーマンスへの影響などについても触れている。&lt;/p&gt;
&lt;h3 id="exploring-c-10-global-using-declarations"&gt;Exploring C# 10: Global Using Declarations&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/daveabrock/exploring-c-10-global-using-declarations-lab"&gt;https://dev.to/daveabrock/exploring-c-10-global-using-declarations-lab&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 10 で導入される Global Usings についての記事。&lt;/p&gt;
&lt;p&gt;通常の C# ソースコードに記述する &lt;code&gt;global using&lt;/code&gt; のほか &lt;code&gt;static&lt;/code&gt; やエイリアスの指定、.csproj の &lt;code&gt;&amp;lt;ItemGroup&amp;gt;&lt;/code&gt; を使用した定義についてなど。&lt;/p&gt;
&lt;h3 id="analyzers-for-asp.net-core-in.net-6-exploring.net-core-6-part-7"&gt;Analyzers for ASP.NET Core in .NET 6: Exploring .NET Core 6 - Part 7&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-7-analyzers-for-minimal-apis/"&gt;https://andrewlock.net/exploring-dotnet-6-part-7-analyzers-for-minimal-apis/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="c-valuetuple"&gt;C#: 匿名型とValueTupleではシリアライズ結果が違う&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/shimat/articles/c5248dda90270e"&gt;https://zenn.dev/shimat/articles/c5248dda90270e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;匿名型と名前付き ValueTuple を各種シリアライザー (MessagePack, JSON.NET, System.Text.Json) に通した際の結果の違いについての記事。&lt;/p&gt;
&lt;p&gt;名前付き ValueTuple の名前は属性で付加されるだけの要素のため、大抵の場合出力にはキーとして含まれない。&lt;/p&gt;
&lt;h3 id="nunit-vs.xunit-vs.mstest-comparing-unit-testing-frameworks-in-c"&gt;NUnit vs. XUnit vs. MSTest: Comparing Unit Testing Frameworks In C#&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.lambdatest.com/blog/nunit-vs-xunit-vs-mstest/"&gt;https://www.lambdatest.com/blog/nunit-vs-xunit-vs-mstest/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NUnit と xUnit と MSTest の違いをまとめた記事。それぞれの属性が何に対応するかといったことなどもまとまっている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/kojimadev/items/c451196fb703cbf99e86"&gt;C#のテストフレームワークを MSTest から xUnit に乗り換えたい時にその理由を同僚に説明できるようにする - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="csimd-qiita"&gt;C#で小さい複素数の積を大量に計算したかったのでSIMD実装とか試してみた - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/amutou/items/9031667f21f77a95df1e"&gt;https://qiita.com/amutou/items/9031667f21f77a95df1e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SDR (ソフトウェア無線) のデータ処理のために SIMD を使用してみたという記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/amutou/items/2cd69df4f4d140fabfc7"&gt;C#のSIMDでカスケード積分コムフィルタ - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiita.com/amutou/items/4f618495bcff5c07cc32"&gt;C#のSIMDでFIRフィルタ - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="file-scoped-namespaces-a-look-at-new-language-features-in-c-10-the.net-tools-blog"&gt;File-Scoped Namespaces – A Look at New Language Features in C# 10 | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/28/file-scoped-namespaces-in-csharp-10/"&gt;https://blog.jetbrains.com/dotnet/2021/10/28/file-scoped-namespaces-in-csharp-10/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 10 で導入されるファイルスコープ名前空間について、ReSharper と Rider の対応も含めて解説している記事。&lt;/p&gt;
&lt;p&gt;ReSharper と Rider では Code Styles として設定しチームで共有可能で、変換も Quick Fix から可能となる。テンプレートに関してもコードスタイルに合わせて自動的に変換するといったことも。&lt;/p&gt;
&lt;h3 id="encryptdecrypt-data-with.net-6-and-azure-key-vault"&gt;Encrypt/decrypt data with .NET 6 and Azure Key Vault&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/425show/encryptdecrypt-data-with-net-6-and-azure-key-vault-oak"&gt;https://dev.to/425show/encryptdecrypt-data-with-net-6-and-azure-key-vault-oak&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Azure Key Vault を使用してデータを暗号化、復号処理を行う方法についての記事。&lt;/p&gt;
&lt;h3 id="improving-your-asp.net-core-sites-file-handling-capabilities-part-1-introduction-imar.spaanjaars.com"&gt;Improving your ASP.NET Core site's file handling capabilities – part 1 – Introduction - imar.spaanjaars.com&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://imar.spaanjaars.com/626/improving-your-aspnet-core-sites-file-handling-capabilities-part-1-introduction"&gt;https://imar.spaanjaars.com/626/improving-your-aspnet-core-sites-file-handling-capabilities-part-1-introduction&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core で Web アプリケーションのファイルデータを扱う手段として &lt;code&gt;File&lt;/code&gt; クラスなどを直接使用するのではなくファイルアクセスを抽象化した &lt;code&gt;IFileProvider&lt;/code&gt; インターフェースを使用する方法についての記事。&lt;/p&gt;
&lt;p&gt;Azure Storage Blob を使用した &lt;code&gt;IFileProvider&lt;/code&gt; の実装についても触れている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/aspnet/core/fundamentals/file-providers?view=aspnetcore-5.0"&gt;ASP.NET Core でのファイル プロバイダー | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="bite-size.net-6-priorityqueuet-n"&gt;Bite-Size .NET 6 - PriorityQueue&amp;lt;T, N&amp;gt;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://exceptionnotfound.net/bite-size-dotnet-6-priorityqueue/"&gt;https://exceptionnotfound.net/bite-size-dotnet-6-priorityqueue/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で導入される &lt;code&gt;PriorityQueue&amp;lt;TElement, TPriority&amp;gt;&lt;/code&gt; クラスについての解説記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.collections.generic.priorityqueue-2?view=net-6.0"&gt;PriorityQueue&amp;lt;TElement,TPriority&amp;gt; クラス (System.Collections.Generic) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="testing-grpc-with-grpcui-docker-and-swagger"&gt;Testing gRPC with gRPCui Docker and Swagger&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;niteshsinghal85/testing-grpc-with-grpcui-docker-and-swagger-9cfc9531512"&gt;https://medium.com/&amp;#64;niteshsinghal85/testing-grpc-with-grpcui-docker-and-swagger-9cfc9531512&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core gRPC アプリケーションのデバッグやテストを行うために gRPC UI を Docker で使用する方法についての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/fullstorydev/grpcui"&gt;fullstorydev/grpcui: An interactive web UI for gRPC, along the lines of postman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/aspnet/core/grpc/httpapi?view=aspnetcore-5.0"&gt;Create JSON Web APIs from gRPC | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="x-lessons-learned-from-migrating-a-large-legacy-to.net-56-ndepend"&gt;5x Lessons Learned from Migrating a Large Legacy to .NET 5/6 - NDepend&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.ndepend.com/5x-lessons-learned-from-migrating-a-large-legacy-to-net-5-6"&gt;https://blog.ndepend.com/5x-lessons-learned-from-migrating-a-large-legacy-to-net-5-6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;大きい .NET Framework プロジェクト (NDepend) を .NET 5/6 に移行する際の5つの学びについての記事。&lt;/p&gt;
&lt;p&gt;NDepend の UI に依存しないコードを .NET Framework から .NET 5 へと移行したことで解析やレポーティング、といったツールが macOS や Linux で動作できるようになった。その中で得られた教訓を紹介している。&lt;/p&gt;
&lt;p&gt;.NET Framework との共存には .NET Standard を選択すること、API の非互換といったペインポイント、ツールを使用して移行の助けをすること、コードの保守性を担保すること、3rd パーティーのライブラリはモジュール化され軽量でオープンソースであるべきといったことをあげている。&lt;/p&gt;
&lt;h3 id="github-actionsxamarin-androidrelease-qiita"&gt;GitHub ActionsでXamarin AndroidをReleaseビルド (ストア提出用) - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/kurema/items/becaf36dda27351e88cc"&gt;https://qiita.com/kurema/items/becaf36dda27351e88cc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GitHub Actions で Xamarin Android のアプリケーションを Release ビルドし、ストア提出可能なパッケージを作る方法についての記事。&lt;/p&gt;
&lt;h3 id="unity-2020-lts-unity-blog"&gt;最適化の最前線から：Unity 2020 LTS でのマネージコードストリッピングの強化 | Unity Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.unity.com/ja/technology/tales-from-the-optimization-trenches-better-managed-code-stripping-with-unity-2020-lts"&gt;https://blog.unity.com/ja/technology/tales-from-the-optimization-trenches-better-managed-code-stripping-with-unity-2020-lts&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Unity でのアプリケーションビルドで使用されるマネージドコードのストリッピングを行う Unity リンカーについての記事。&lt;/p&gt;
&lt;p&gt;Unity リンカーによって何が行われるのか、Unity 2020 LTS 以降で導入されたストリッピングの挙動をカスタマイズする属性などについて説明している。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="aarnottxunit.combinatorial-adds-combinatorial-and-pairwise-testing-capability-to-xunit-tests"&gt;AArnott/Xunit.Combinatorial: Adds combinatorial and pairwise testing capability to Xunit tests&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/AArnott/Xunit.Combinatorial"&gt;https://github.com/AArnott/Xunit.Combinatorial&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;xUnit のテストのパラメータ値に組み合わせを渡せるようにする拡張ライブラリ。&lt;/p&gt;
&lt;p&gt;例えば下記のような &lt;code&gt;bool&lt;/code&gt; を引数にとるテストであれば自動で &lt;code&gt;true&lt;/code&gt; / &lt;code&gt;false&lt;/code&gt; の組み合わせを渡してテストできる。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Theory, CombinatorialData]
public void CheckFileSystem(bool recursive) { /* ... */ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;他にも複数指定した組み合わせをテストできる。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;[Theory, CombinatorialData]
public void CheckValidAge(
    [CombinatorialValues(5, 18, 21, 25)] int age,
    bool friendlyOfficer)
{
    // This will run with all combinations:
    // 5  true
    // 18 true
    // 21 true
    // 25 true
    // 5  false
    // 18 false
    // 21 false
    // 25 false
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="net"&gt;プリミティブ: .NET 用拡張機能ライブラリ&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/core/extensions/primitives"&gt;https://docs.microsoft.com/ja-jp/dotnet/core/extensions/primitives&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Microsoft.Extensions.Primitives&lt;/code&gt; についての説明ドキュメント。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CancellationToken&lt;/code&gt; を使用して変更通知を受け取れる &lt;code&gt;CancellationChangeToken&lt;/code&gt; や &lt;code&gt;StringSegment&lt;/code&gt;, &lt;code&gt;StringTokenizer&lt;/code&gt;, &lt;code&gt;StringValues&lt;/code&gt; といった文字列を扱うクラスなどについて触れている。&lt;/p&gt;
&lt;h3 id="your-code-displays-japanese-wrong"&gt;Your code displays Japanese wrong&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://heistak.github.io/your-code-displays-japanese-wrong/"&gt;https://heistak.github.io/your-code-displays-japanese-wrong/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;アプリケーションで日本語を表示したとき、期待されるグリフとは別なものが表示されるいわゆる中華フォント状態となってしまう場合にどうしてそうなるのか、どうすれば解決するのかを非 CJK の開発者に伝えるためのドキュメント。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/nick_craver/status/1453345409984831492?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;In case anyone else was wondering this: an empty finally clause is not removed when all conditional contents are removed. It has no practical impact either, though. &lt;a href="https://t.co/EgSwGVPNDA"&gt;pic.twitter.com/EgSwGVPNDA&lt;/a&gt;&lt;/p&gt;&amp;mdash; Nick Craver (&amp;#64;Nick_Craver) &lt;a href="https://twitter.com/Nick_Craver/status/1453345409984831492?ref_src=twsrc%5Etfw"&gt;October 27, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;&lt;code&gt;finally&lt;/code&gt; 句の中が &lt;code&gt;Conditional&lt;/code&gt; ですべてなくなったとしてもコンパイル結果には &lt;code&gt;finally&lt;/code&gt; 自体は残っているという話。&lt;/p&gt;
&lt;!-- https://twitter.com/konradkokosa/status/1453719238426824716?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Did you know that .NET 6 contains now ISpanFormattable interface, implemented by many built in types, to TryFormat value into Span? 😍 &lt;a href="https://t.co/hoS7sbsIZ2"&gt;pic.twitter.com/hoS7sbsIZ2&lt;/a&gt;&lt;/p&gt;&amp;mdash; Konrad Kokosa (&amp;#64;konradkokosa) &lt;a href="https://twitter.com/konradkokosa/status/1453719238426824716?ref_src=twsrc%5Etfw"&gt;October 28, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 から &lt;code&gt;ISpanFormattable&lt;/code&gt; が使えるようになったので &lt;code&gt;TryFormat&lt;/code&gt; で &lt;code&gt;Span&amp;lt;Char&amp;gt;&lt;/code&gt; に書き込めるものが増えたという話。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.ispanformattable?view=net-6.0"&gt;ISpanFormattable インターフェイス (System) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/trapezoid/status/1453685023077404673?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="ja" dir="ltr"&gt;いつの間にかBurstが(エントリポイントの引数には使えない制限付きだけど)Span対応していた &lt;a href="https://t.co/PspKs1Xspl"&gt;https://t.co/PspKs1Xspl&lt;/a&gt;&lt;/p&gt;&amp;mdash; Haruto Otake (&amp;#64;Trapezoid) &lt;a href="https://twitter.com/Trapezoid/status/1453685023077404673?ref_src=twsrc%5Etfw"&gt;October 28, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Unity の Burst コンパイラーの 1.6.1 から &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; / &lt;code&gt;ReadOnlySpan&amp;lt;T&amp;gt;&lt;/code&gt; が関数ポインターや Job の中のみという制限があるもののサポートされた話。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.unity3d.com/Packages/com.unity.burst&amp;#64;1.6/manual/docs/CSharpLanguageSupport_Types.html#span-types"&gt;Span types | C#/.NET Language Support | Burst | 1.6.1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.unity3d.com/Packages/com.unity.burst&amp;#64;1.6/changelog/CHANGELOG.html#161---2021-10-12"&gt;Changelog | Burst | 1.6.1&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/ufcpp/status/1452911700219351044?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="ja" dir="ltr"&gt;&lt;a href="https://t.co/gjHpiGEvsr"&gt;https://t.co/gjHpiGEvsr&lt;/a&gt;&lt;br&gt;UnityでのNuGetパッケージでの「dllのバージョン違うから読めない」問題、一応bindingRedirectできるらしいという話をやっと見つけたけどこのページのページランク低すぎて見つけるの苦労した…&lt;/p&gt;&amp;mdash; ++C++; // 管理人: 岩永 (&amp;#64;ufcpp) &lt;a href="https://twitter.com/ufcpp/status/1452911700219351044?ref_src=twsrc%5Etfw"&gt;October 26, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Unity で csc.rsp に &lt;code&gt;-appconfig:app.config&lt;/code&gt; の形で設定を記述することで bindingRedirect できるというテクニック。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://forum.unity.com/threads/dependency-on-newtonsoft-json.814128/"&gt;Dependency On Newtonsoft.Json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="api-implementation-add-indexer-to-vectors-by-deeprobin-pull-request-60517-dotnetruntime"&gt;API Implementation: Add Indexer to Vectors by deeprobin · Pull Request #60517 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60517"&gt;https://github.com/dotnet/runtime/pull/60517&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Vector 系の構造体にインデックスアクセスを可能にする PR。.NET 7 に含まれる予定。&lt;/p&gt;
&lt;h3 id="super-draft-new-api-for-invoking-js-functions-from-c-by-kg-pull-request-60765-dotnetruntime"&gt;[SUPER DRAFT] New API for invoking JS functions from C# by kg · Pull Request #60765 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60765"&gt;https://github.com/dotnet/runtime/pull/60765&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WebAssembly 向けに icall を実装することで C# から JavaScript の関数を呼び出したりするオーバーヘッドを小さくするという PR。&lt;/p&gt;
&lt;h3 id="add-objectdisposedexception.throw-for-object-instance-and-type-by-bibletoon-pull-request-58684-dotnetruntime"&gt;Add ObjectDisposedException.Throw for object instance and type by Bibletoon · Pull Request #58684 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/58684"&gt;https://github.com/dotnet/runtime/pull/58684&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ObjectDisposedException&lt;/code&gt; を簡単にスローするためのヘルパーメソッド &lt;code&gt;ThrowIf&lt;/code&gt; の追加 PR。.NET 7 に含まれる予定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/51700"&gt;Add new ObjectDisposedException constructor overload · Issue #51700 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="resolve-differences-between-string.indexofany-and-memoryextensions.indexofany-issue-60864-dotnetruntime"&gt;Resolve differences between string.IndexOfAny and MemoryExtensions.IndexOfAny · Issue #60864 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60864"&gt;https://github.com/dotnet/runtime/issues/60864&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;string.IndexOfAny&lt;/code&gt; は &lt;code&gt;anyOf&lt;/code&gt; 引数の値が5つ以下の時は &lt;code&gt;MemoryExtensions.IndexOfAny&lt;/code&gt; をそのまま呼び出し、6つ以上の時は Probabilistic Map を使用しているが、挙動をそろえてそのまま &lt;code&gt;MemoryExtensions&lt;/code&gt;に 移譲するのでいいのではないかという Issue。&lt;/p&gt;
&lt;h3 id="improve-vectorization-of-memoryextensions.indexof.span-issue-60866-dotnetruntime"&gt;Improve vectorization of MemoryExtensions.IndexOf(..., span) · Issue #60866 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60866"&gt;https://github.com/dotnet/runtime/issues/60866&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MemoryExtensions.IndexOf&lt;/code&gt; はベクトル化できる余地があるのではないかという Issue。&lt;/p&gt;
&lt;h3 id="utf8-string-literal-proposal-by-jaredpar-pull-request-5349-dotnetcsharplang"&gt;Utf8 string literal proposal by jaredpar · Pull Request #5349 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/pull/5349"&gt;https://github.com/dotnet/csharplang/pull/5349&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;UTF-8 文字列リテラルの初期プロポーザルのPR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/blob/main/proposals/utf8-string-literals.md"&gt;csharplang/utf8-string-literals.md at main · dotnet/csharplang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-10-22: Visual Studio 2022 RC2, LINQPad 7 Beta, Hot Reload, F# 6</title>
			<link>/2021/10/22/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/10/22/updates</guid>
			<pubDate>Fri, 22 Oct 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#1700-pre60--visual-studio-2022-version-170-rc2-and-preview-6-newreleasebutton"&gt;Visual Studio 2022 version 17.0 RC2 and Preview 6&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;.NET 自体の更新はなく Visual Studio のバグ修正が主な更新点です。何か不具合のようなものを踏んでいる方は更新をおすすめします。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://www.linqpad.net/LINQPad7.aspx"&gt;LINQPad 7 Beta&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;.NET 6 および C# 10 に対応し、ARM64 向けのバイナリーも含まれるようになりました。Surface Pro X のような ARM 版 Windows でも C# を書いて ARM ネイティブで動かせるようになりました。現在 6 のライセンスは無償アップグレードとなっていて、既にライセンスを持っている人でも割引で購入できるようになっています。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-net-hot-reload-progress-and-visual-studio-2022-highlights/"&gt;ホットリロードについてのステータスアップデート&lt;/a&gt;がアナウンスされました。&lt;/p&gt;
&lt;p&gt;アナウンスでは Visual Studio とターゲットフレームワークによる対応具合や MAUI/ASP.NET での対応についても書かれていますが、地味に大きな点としては &lt;code&gt;dotnet watch&lt;/code&gt; をリリースしないという決定がなされたという点です。特に Visual Studio を使用していない開発者がホットリロードの恩恵を受けられなくなるということで大きな反響が生まれています。&lt;/p&gt;
&lt;p&gt;元々バギーではあったのですが .NET 6 の目玉機能かつ RC2 をリリースした後、GA までもう少しという直前の段階で削除をしてリリースしないというアナウンスをしたので余計に不満になっていそうです。今後何らかの形で戻されたりする可能性は十分あるのではないかと思います。&lt;/p&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="visual-studio-2022-version-17.0-rc2-and-preview-6"&gt;Visual Studio 2022 version 17.0 RC2 and Preview 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#1700-pre60--visual-studio-2022-version-170-rc2-and-preview-6-newreleasebutton"&gt;https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#1700-pre60--visual-studio-2022-version-170-rc2-and-preview-6-newreleasebutton&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 version 17.0 RC2 と Preview 6 がリリースされた。&lt;/p&gt;
&lt;p&gt;RC と Preview 5 のリリースからの Visual Studio 固有のバグ修正が行われており、.NET 6 SDK などへの変更はない。&lt;/p&gt;
&lt;h3 id="linqpad-7-beta"&gt;LINQPad 7 Beta&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.linqpad.net/LINQPad7.aspx"&gt;https://www.linqpad.net/LINQPad7.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LINQPad 7 Beta がリリースされた。&lt;/p&gt;
&lt;p&gt;LINQPad 7 は .NET 6 および C# 10 に対応したリリースとなり、.NET 6, .NET 5, .NET Core 3.1, .NET Framework をサポートする。
また ARM64 ビルドも提供され Surface Pro X をはじめとする ARM64 環境でのネイティブ動作が可能となった。&lt;/p&gt;
&lt;p&gt;正式なリリースは .NET 6 のリリース後となり、現在 LINQPad 6 のライセンスを購入することでリリース時にアップグレードが可能。&lt;/p&gt;
&lt;!-- https://twitter.com/linqpad/status/1450036548506767363?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;LINQPad 7 Preview has just been released, with full support for C# 10, &lt;a href="https://twitter.com/dotnet?ref_src=twsrc%5Etfw"&gt;&amp;#64;dotnet&lt;/a&gt; 6 and EF Core 6. There&amp;#39;s also now an ARM64 build, so you can run and debug C# and F# code on your Surface Pro X at native speed!&lt;a href="https://t.co/1sC2iOFwoW"&gt;https://t.co/1sC2iOFwoW&lt;/a&gt;&lt;/p&gt;&amp;mdash; LINQPad·Joe Albahari (&amp;#64;linqpad) &lt;a href="https://twitter.com/linqpad/status/1450036548506767363?ref_src=twsrc%5Etfw"&gt;October 18, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="update-on.net-hot-reload-progress-and-visual-studio-2022-highlights"&gt;Update on .NET Hot Reload progress and Visual Studio 2022 Highlights&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-net-hot-reload-progress-and-visual-studio-2022-highlights/"&gt;https://devblogs.microsoft.com/dotnet/update-on-net-hot-reload-progress-and-visual-studio-2022-highlights/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET のホットリロードについてのアップデートの記事。&lt;/p&gt;
&lt;p&gt;記事では次のようなトピックについて書かれている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;サポートされるフレームワークとシナリオ&lt;/li&gt;
&lt;li&gt;Visual Studio 2022 での体験の向上&lt;/li&gt;
&lt;li&gt;MAUI と ASP.NET でのシナリオ&lt;/li&gt;
&lt;li&gt;.NET アプリの編集に関する追加サポート&lt;/li&gt;
&lt;li&gt;.NET 6 ユニットテストのホットリロード (Experimental)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dotnet watch&lt;/code&gt; コマンドラインツールに関する変更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;サポートされるフレームワークとシナリオについては Visual Studio 2022 からデバッガーを使用しているかそうでないか、Visual Studio 2022 と .NET 6 をターゲットとしたアプリかどうかといった場合について書かれている。大まかには従来のフレームワークをターゲットとしている場合にはデバッグ時のみ、.NET 6 をターゲットとしている場合はデバッガーなしも含め殆どのケースでサポートされる。&lt;/p&gt;
&lt;p&gt;ただし Blazor WebAssembly は GA の時点では対応されず、他に対応しないシナリオとして iOS と Android の Xamarin.Forms や F# アプリケーション、.NET Native アプリケーションなどがあるとのこと。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 での体験の向上は、ラベルが Hot Reload となったこと、ファイル保存時にホットリロードする機能が付いたことなどがあげられている。&lt;/p&gt;
&lt;p&gt;MAUI と ASP.NET でのシナリオは MAUI (iOS/Android) でのホットリロードが可能になること、ASP.NET では Razor CSHTML の変更と自動リロード、CSS のホットリロードなどが可能となった。ただし MAUI のホットリロードは Mono ランタイムの制限上メソッドボディーの編集に限られるとのこと。&lt;/p&gt;
&lt;p&gt;その他 XAML のホットリロードとユニットテスト実行時のホットリロードがプレビュー(オプトイン)で提供されていることについて。&lt;/p&gt;
&lt;p&gt;最後に &lt;code&gt;dotnet watch&lt;/code&gt; コマンドラインツールについて、ホットリロードは開発の集中のため Visual Studio 2022 でのみの提供となり、コマンドラインツールはリリースしないと決定したとのこと。Visual Studio 2022 for Mac に関しては将来のリリースで追加する予定。&lt;/p&gt;
&lt;p&gt;これに伴い &lt;code&gt;dotnet watch&lt;/code&gt; が削除されたが、Visual Studio Code や Rider といった Visual Studio 以外のユーザーからは不満の声が上がっているので今後何らか動きがある可能性がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sdk/pull/22217"&gt;Remove Hot Reload support from dotnet watch by pranavkm · Pull Request #22217 · dotnet/sdk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sdk/issues/22247"&gt;Hot Reload removed from dotnet watch - Why? · Issue #22247 · dotnet/sdk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="whats-new-in-f-6"&gt;What’s new in F# 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/whats-new-in-fsharp-6/"&gt;https://devblogs.microsoft.com/dotnet/whats-new-in-fsharp-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 に含まれる F# 6 についての記事。&lt;/p&gt;
&lt;p&gt;F# で速くなった点、均一化された点、シンプルになった点、ツーリングの改善などについて触れている。&lt;/p&gt;
&lt;h3 id="introducing-new-javascript-engine-yantrajs-for-dotnet"&gt;Introducing new JavaScript Engine YantraJS for DotNet&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.webatoms.in/blog/yantra-js/Introducing-new-JavaScript-Engine-YantraJS-for-DotNet-2g"&gt;https://www.webatoms.in/blog/yantra-js/Introducing-new-JavaScript-Engine-YantraJS-for-DotNet-2g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オープンソースの JavaScript エンジンの YantraJS がリリースされた。&lt;/p&gt;
&lt;p&gt;.NET との相互運用や JavaScript を .NET のアセンブリーに変換するコンパイラーなどが提供されることが特徴。
現時点で ECMAScript 6 の適合率は70%程度で今後100%を目指すとのこと。その他 V8 Debugger Protocol のサポートなどが今後のロードマップにあがっている。&lt;/p&gt;
&lt;p&gt;ライセンスは LGPL、YantraJS Standard License (主にサーバーサイド利用目的)、YantraJS Enterprise License となっている。MIT ライセンスに変更できるようスポンサーも求めているとのこと。(ただ LGPL 版を NuGet で参照した場合でもソースコードを公開する必要があると書かれているので LGPL ではない可能性がある)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/yantrajs/yantra/wiki/License"&gt;License · yantrajs/yantra Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="weve-upgraded-the-ui-in-visual-studio-2022"&gt;We've upgraded the UI in Visual Studio 2022&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/weve-upgraded-the-ui-in-visual-studio-2022/"&gt;https://devblogs.microsoft.com/visualstudio/weve-upgraded-the-ui-in-visual-studio-2022/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 における UI の変更についての記事。&lt;/p&gt;
&lt;p&gt;一貫性や視認性、親しみやすさを考慮したアイコンの刷新、ダークモードでのコントラスト調整や新しいアクセントカラー、Cascadia フォントの導入などについて触れている。&lt;/p&gt;
&lt;h3 id="contributing-to.net-maui-community-toolkit"&gt;Contributing to .NET MAUI Community Toolkit&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/contributing-to-net-maui-community-toolkit/"&gt;https://devblogs.microsoft.com/dotnet/contributing-to-net-maui-community-toolkit/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET MAUI Community Toolkit にコントリビュートする方法についての記事。&lt;/p&gt;
&lt;p&gt;.NET MAUI Community Toolkit がコミュニティーのコントリビュートを受け入れるようになり、新機能を提案したい場合のフローについて解説している。
フローは C# チームのものを参考にしたものとなっている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Discussion をオープン&lt;/li&gt;
&lt;li&gt;フィーチャーの Proposal (Issue) をオープン&lt;/li&gt;
&lt;li&gt;チームによって Champion を選出&lt;/li&gt;
&lt;li&gt;.NET MAUI Community Toolkit Monthly Standup (YouTube 配信) で投票の上、承認&lt;/li&gt;
&lt;li&gt;Pull Request 承認&lt;/li&gt;
&lt;li&gt;ドキュメント承認&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;承認された Proposal は &lt;code&gt;help wanted&lt;/code&gt; ラベルがつけられるため、簡単なコントリビュートとしてはこの実装を提供する(Pull Request)という方法も提示されている。&lt;/p&gt;
&lt;h3 id="release-2.0.0-beta.5-mysql-netmysqlconnector"&gt;Release 2.0.0-beta.5 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/2.0.0-beta.5"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/2.0.0-beta.5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector 2.0.0-beta.5 がリリースされた。&lt;/p&gt;
&lt;p&gt;変更点は &lt;code&gt;ActivitySource&lt;/code&gt; によるトレースへの対応。今回のリリースよりバージョニングが 1.4.0 ベータでの変更範囲を鑑みて 2.0 へと変更された。&lt;/p&gt;
&lt;h3 id="release-1.3.14-mysql-netmysqlconnector"&gt;Release 1.3.14 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/1.3.14"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/1.3.14&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector 1.3.14 がリリースされた。&lt;/p&gt;
&lt;p&gt;バグ修正が主な変更となっている。&lt;/p&gt;
&lt;h3 id="release-ef-core-3.1.20-dotnetefcore"&gt;Release EF Core 3.1.20 · dotnet/efcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/releases/tag/v3.1.20"&gt;https://github.com/dotnet/efcore/releases/tag/v3.1.20&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 3.1.20 がリリースされた。&lt;/p&gt;
&lt;p&gt;SQLite の不具合対応に伴い、依存しているバージョンが 2.0.2 から 2.0.4 へアップデートされた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ericsink/SQLitePCL.raw/issues/321"&gt;System.AccessViolationException at System.Text.UTF8Encoding.GetCharCount(Byte*, Int32, System.Text.DecoderNLS) · Issue #321 · ericsink/SQLitePCL.raw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-diagnostics-release-v5.0.251802-dotnetdiagnostics"&gt;Release Diagnostics Release - v5.0.251802 · dotnet/diagnostics&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/diagnostics/releases/tag/v5.0.251802"&gt;https://github.com/dotnet/diagnostics/releases/tag/v5.0.251802&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET の診断ツール 5.0.251802 がリリースされた。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet-dump&lt;/code&gt; と &lt;code&gt;dotnet-sos&lt;/code&gt; は Linux と Windows 上でのシングルファイルアプリケーションのプロセスとファイルの解析がサポートされた。その他バグ修正など。&lt;/p&gt;
&lt;h3 id="developing-for-windows-with-the-windows-app-sdk-discussion-1615-microsoftwindowsappsdk"&gt;Developing for Windows with the Windows App SDK · Discussion #1615 · microsoft/WindowsAppSDK&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/microsoft/WindowsAppSDK/discussions/1615"&gt;https://github.com/microsoft/WindowsAppSDK/discussions/1615&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows App SDK と WinUI 3 の開発についての FAQ。&lt;/p&gt;
&lt;p&gt;今後 UWP はバグや信頼性に関連する修正のみが行われ、Windows App SDK を使用する場合には新しいデスクトッププロジェクトに移行する必要があること、といった点など。&lt;/p&gt;
&lt;h3 id="net-framework-october-2021-security-and-quality-rollup"&gt;.NET Framework October 2021 Security and Quality Rollup&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/net-framework-october-2021-security-and-quality-rollup/"&gt;https://devblogs.microsoft.com/dotnet/net-framework-october-2021-security-and-quality-rollup/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Framework の2021年10月のセキュリティーと累積アップデートについて。&lt;/p&gt;
&lt;p&gt;セキュリティーに関する更新はなく、正しくない GC の設定によるパフォーマンスの低下や GC.AddMemoryPressure での GC トリガーのアルゴリズムの調整などが含まれている。&lt;/p&gt;
&lt;h3 id="bouncycastle-c-1.9.0"&gt;BouncyCastle C# 1.9.0&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.bouncycastle.org/csharp/index.html#DOWNLOAD1900"&gt;https://www.bouncycastle.org/csharp/index.html#DOWNLOAD1900&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;BouncyCastle C# 1.9.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;TLS API の更新や Format Preserving Encryption、ParallelHash と TupleHash、ARIA cipher のサポートが追加された。バグ修正も行われている。&lt;/p&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="net-6-qiita"&gt;.NET 6 で追加されるタスクベースの新しいタイマー - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/karuakun/items/677b2e58260634d86d0d"&gt;https://qiita.com/karuakun/items/677b2e58260634d86d0d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で追加されたタスクベースとなる新しいタイマーの使い方とそれ以前のタイマーについての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.periodictimer?view=net-6.0"&gt;PeriodicTimer Class (System.Threading)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="unity-improving-iteration-time-on-c-script-changes"&gt;Unity - Improving iteration time on C# script changes&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://forum.unity.com/threads/improving-iteration-time-on-c-script-changes.1184446/"&gt;https://forum.unity.com/threads/improving-iteration-time-on-c-script-changes.1184446/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Unity で C# コードを変更したときのドメインリロードの時間が長くなってしまった件についての調査と進捗報告。&lt;/p&gt;
&lt;p&gt;リグレッションは 2020.x から発生し、メトリクスの不足や問題が多岐にわたっていること、幾つかの側面から解決を図っていることなど。&lt;/p&gt;
&lt;p&gt;例えば 2020.1 以降ではドメインリロードの診断メトリクスを保存する機能が追加されたので利用者が調べることができるようになった。コードベース全体を通してリグレッションを探すタスクフォースを立ち上げ細かく最適化を行うことなど。今後も継続して改善を進め、必要なものはバックポートし、その進捗はスレッドに報告するとのこと。&lt;/p&gt;
&lt;h3 id="helpful-nuget-package-for-unit-testing-in.net"&gt;5 helpful Nuget package for Unit Testing in .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;niteshsinghal85/5-helpful-nuget-package-for-unit-testing-in-net-87c2e087c6d"&gt;https://medium.com/&amp;#64;niteshsinghal85/5-helpful-nuget-package-for-unit-testing-in-net-87c2e087c6d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ユニットテストをするときに役に立つ5つの NuGet パッケージの紹介の記事。&lt;/p&gt;
&lt;h3 id="supporting-integration-tests-with-webapplicationfactory-in.net-6-exploring.net-core-6-part-6"&gt;Supporting integration tests with WebApplicationFactory in .NET 6: Exploring .NET Core 6 - Part 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-6-supporting-integration-tests-with-webapplicationfactory-in-dotnet-6/"&gt;https://andrewlock.net/exploring-dotnet-6-part-6-supporting-integration-tests-with-webapplicationfactory-in-dotnet-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core を WebApplicationFactory を使用して統合テストを行うことについての記事。&lt;/p&gt;
&lt;p&gt;WebApplicationFactory が内部で行っている処理についても解説している。&lt;/p&gt;
&lt;h3 id="updated-debugging-experience-uwp-apps-and-debug-windows-docker-containers-in-rider-2021.3-the.net-tools-blog"&gt;Updated Debugging Experience, UWP Apps, and Debug Windows Docker containers in Rider 2021.3 | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/20/debugging-experience-debug-uwp-apps-and-debug-windows-docker-containers-in-rider-2021-3/"&gt;https://blog.jetbrains.com/dotnet/2021/10/20/debugging-experience-debug-uwp-apps-and-debug-windows-docker-containers-in-rider-2021-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rider 2021.3 で改善されたデバッグ周りについての記事。&lt;/p&gt;
&lt;p&gt;デバッガーの UI の改善や UWP アプリと Windows Docker コンテナーの対応についてなど。&lt;/p&gt;
&lt;h3 id="bite-size.net-6-linq-ordefault-overloads"&gt;Bite-Size .NET 6 - LINQ OrDefault() Overloads&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://exceptionnotfound.net/bite-size-dotnet-6-linq-ordefault-overloads/"&gt;https://exceptionnotfound.net/bite-size-dotnet-6-linq-ordefault-overloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の LINQ の &lt;code&gt;FirstOrDefault&lt;/code&gt; のような &lt;code&gt;*OrDefault&lt;/code&gt; メソッドにデフォルト値を受けるオーパーロードが追加されたことについての記事。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var name = names.FirstOrDefault(&amp;quot;Unknown&amp;quot;); // 見つからなかったら Unknown が返る
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="exploring-the-auth0-asp.net-core-authentication-sdk"&gt;Exploring the Auth0 ASP.NET Core Authentication SDK&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://auth0.com/blog/exploring-auth0-aspnet-core-authentication-sdk/"&gt;https://auth0.com/blog/exploring-auth0-aspnet-core-authentication-sdk/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;アプリケーションで Auth0 の ASP.NET Core Authentication SDK を使用することについての記事。&lt;/p&gt;
&lt;h3 id="grpc-api-performance-improvement-through-protobuf-fieldmask-in.net"&gt;gRPC API Performance Improvement Through Protobuf FieldMask In .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;AzilenTech/grpc-api-performance-improvement-through-protobuf-fieldmask-in-net-2dff2af6c959"&gt;https://medium.com/&amp;#64;AzilenTech/grpc-api-performance-improvement-through-protobuf-fieldmask-in-net-2dff2af6c959&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Protobuf の FieldMask を使用することで gRPC の API パフォーマンスを向上させることについての記事。&lt;/p&gt;
&lt;p&gt;必要なフィールドだけを明示して取得することでサーバー側の不要な処理を回避して、メッセージサイズも削減できるというテクニック。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://netflixtechblog.com/practical-api-design-at-netflix-part-1-using-protobuf-fieldmask-35cfdc606518"&gt;Practical API Design at Netflix, Part 1: Using Protobuf FieldMask&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.pyspa.org/post/using_protobuf_fieldmask/"&gt;Netflixにおける実用的なAPI設計: gRPCとFieldMask | pyspa&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="implement-a-secure-api-and-a-blazor-app-in-the-same-asp.net-core-project-with-azure-ad-authentication"&gt;Implement a secure API and a Blazor app in the same ASP.NET Core project with Azure AD authentication&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://damienbod.com/2021/10/04/implement-a-secure-api-and-a-blazor-app-in-the-same-asp-net-core-project-with-azure-ad-authentication/"&gt;https://damienbod.com/2021/10/04/implement-a-secure-api-and-a-blazor-app-in-the-same-asp-net-core-project-with-azure-ad-authentication/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly と ASP.NET Core Web API に Azure AD 認証を実装する方法についての記事。&lt;/p&gt;
&lt;h3 id="asp-net-core-rest-api-authorization-with-jwt-roles-vs-claims-vs-policy-step-by-step"&gt;Asp Net Core - Rest API Authorization with JWT (Roles Vs Claims Vs Policy) - Step by Step&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/moe23/asp-net-core-rest-api-authorization-with-jwt-roles-vs-claims-vs-policy-step-by-step-5bgn"&gt;https://dev.to/moe23/asp-net-core-rest-api-authorization-with-jwt-roles-vs-claims-vs-policy-step-by-step-5bgn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REST API に JWT を使った認可を実装する方法についての記事。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="davidfowliiscrossover-a-prototype-running-asp.net-and-asp.net-core-in-the-same-iis-pipeline"&gt;davidfowl/IISCrossover: A prototype running ASP.NET and ASP.NET Core in the same IIS pipeline&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/davidfowl/IISCrossover"&gt;https://github.com/davidfowl/IISCrossover&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IIS で ASP.NET アプリケーション (.NET Framework) と ASP.NET Core アプリケーションを同居させて同じパイプラインで動かすという仕組みのプロトタイプ。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1449239883529134082?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;If you&amp;#39;re interested in trying it out and looking at the s/hacks/changes, the the repository is here &lt;a href="https://t.co/masxtR85CC"&gt;https://t.co/masxtR85CC&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧🇺🇸💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1449239883529134082?ref_src=twsrc%5Etfw"&gt;October 16, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="devloopedthisassembly-exposes-project-and-assembly-level-information-as-constants-in-the-thisassembly-class-using-source-generators-powered-by-roslyn"&gt;devlooped/ThisAssembly: Exposes project and assembly level information as constants in the ThisAssembly class using source generators powered by Roslyn.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/devlooped/ThisAssembly"&gt;https://github.com/devlooped/ThisAssembly&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自身のプロジェクトやアセンブリの情報を取得できるコードを生成する Source Generator。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(ThisAssembly.Info.Company); // AssemblyCompanyAttribute
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;アセンブリの情報だけでなく、定数の定義やメタデータ、プロジェクトのプロパティーにアクセスできるようなものも提供されている。&lt;/p&gt;
&lt;h3 id="amis92csharp-source-generators-a-list-of-c-source-generators-not-necessarily-awesome-and-associated-resources-articles-talks-demos"&gt;amis92/csharp-source-generators: A list of C# Source Generators (not necessarily awesome) and associated resources: articles, talks, demos.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/amis92/csharp-source-generators"&gt;https://github.com/amis92/csharp-source-generators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# Source Generator のまとめリポジトリ。&lt;/p&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="windows-subsystem-for-androidtm"&gt;Windows Subsystem for Android™️&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/android/wsa/"&gt;https://docs.microsoft.com/en-us/windows/android/wsa/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows Subsystem for Android™️ の開発者ドキュメント。考慮すべき点やアプリケーションのデバッグ方法などについて触れている。&lt;/p&gt;
&lt;h3 id="overall-migration-strategy-windows-apps"&gt;Overall migration strategy - Windows apps&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/apps/windows-app-sdk/migrate-to-windows-app-sdk/overall-migration-strategy"&gt;https://docs.microsoft.com/en-us/windows/apps/windows-app-sdk/migrate-to-windows-app-sdk/overall-migration-strategy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Universal Windows Platform から Windows App SDK へのマイグレーションのガイドドキュメント。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/steplyakov/status/1449056693568958466?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;It is amazing how &lt;a href="https://twitter.com/VisualStudio?ref_src=twsrc%5Etfw"&gt;&amp;#64;VisualStudio&lt;/a&gt; can show a deadlock in the async code in the &amp;#39;Parallel Stacks&amp;#39; view!&lt;br&gt;&lt;br&gt;It&amp;#39;s not possible to figure out an issue like this one simply by looking into the stack traces. You need to look at how the async machinery is linked together to show it. &lt;a href="https://t.co/9WlANzaI5t"&gt;pic.twitter.com/9WlANzaI5t&lt;/a&gt;&lt;/p&gt;&amp;mdash; Sergey Teplyakov (&amp;#64;STeplyakov) &lt;a href="https://twitter.com/STeplyakov/status/1449056693568958466?ref_src=twsrc%5Etfw"&gt;October 15, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;非同期処理のデッドロックの発見に Parallel Stacks ビューが便利という話(これは以前のバージョンの Visual Studio にある)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/visualstudio/debugger/using-the-parallel-stacks-window?view=vs-2019"&gt;[並列スタック] ウィンドウでスレッドを表示する - Visual Studio (Windows)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1449098382111346692?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;In .NET 6, you can easily generate a random sequence of values from a Cryptographically Secure Pseudorandom Number Generator (CSPNG).&lt;br&gt;&lt;br&gt;It&amp;#39;s useful for cryptographic applications for:&lt;br&gt;• key generation&lt;br&gt;• nonces&lt;br&gt;• salts in certain signature schemes&lt;a href="https://twitter.com/hashtag/dotnet6?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet6&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt; &lt;a href="https://t.co/O1AmnBVTVE"&gt;pic.twitter.com/O1AmnBVTVE&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1449098382111346692?ref_src=twsrc%5Etfw"&gt;October 15, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 では暗号論的擬似乱数生成器 (CSPRNG) を使用してランダムなデータを生成するのが &lt;code&gt;RandomNumberGenerator&lt;/code&gt; クラスの静的メソッドで簡単に取得できるようになったという話。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.security.cryptography.randomnumbergenerator.getbytes?view=net-6.0#System_Security_Cryptography_RandomNumberGenerator_GetBytes_System_Span_System_Byte__"&gt;RandomNumberGenerator.GetBytes メソッド (System.Security.Cryptography)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/xoofx/status/1449047838017589252?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Thrilled to announce we have formed a C#/.NET Tech Group within Unity, bringing Scripting (C# compilation, .NET Runtime integration...), Burst &amp;amp; VM/IL2CPP teams all together to further standardize, modernize, and innovate with .NET technologies within the Unity platform! ♥️&lt;/p&gt;&amp;mdash; Alexandre Mutel (&amp;#64;xoofx) &lt;a href="https://twitter.com/xoofx/status/1449047838017589252?ref_src=twsrc%5Etfw"&gt;October 15, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Unity 社で C#/.NET の技術グループが立ち上がってスクリプティング (C# や .NET ランタイムの統合)、Burst と VM/IL2CPP チームがまとまって Unity における .NET 技術の推進をしていくという話。今後 &lt;q&gt;exciting news&lt;/q&gt; があるとのこと。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1451230807197040649?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;One of my slides from the &lt;a href="https://t.co/4PmXMQN7SX"&gt;https://t.co/4PmXMQN7SX&lt;/a&gt; Core performance talk &lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/aspnetcore?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#aspnetcore&lt;/a&gt; &lt;a href="https://t.co/kfkYo2uKM9"&gt;pic.twitter.com/kfkYo2uKM9&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧🇺🇸💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1451230807197040649?ref_src=twsrc%5Etfw"&gt;October 21, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;ASP.NET Core の .NET 6 まででどのぐらいパフォーマンスが改善されたのかという話のスライドからの抜粋。WebSocket のアロケーションやリクエスト/TLS ハンドシェイクでのアロケーション、ヘッダー周りの高速化などについて。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="datetime.now-on-linux-has-wrong-timezone-issue-60469-dotnetruntime"&gt;&lt;code&gt;DateTime.Now&lt;/code&gt; on Linux has wrong timezone · Issue #60469 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60469"&gt;https://github.com/dotnet/runtime/issues/60469&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DateTime.Now&lt;/code&gt; が Linux で正しいタイムゾーンを返さないようだという Issue。クローズされているが self-contained な物で発生しているという報告。&lt;/p&gt;
&lt;h3 id="where-is-the-asp.net-branding-and-logo-issue-37550-dotnetaspnetcore"&gt;Where is the ASP.NET Branding and Logo? · Issue #37550 · dotnet/aspnetcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/issues/37550"&gt;https://github.com/dotnet/aspnetcore/issues/37550&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET のブランディングロゴはどこにあるのかという Issue。&lt;/p&gt;
&lt;p&gt;現時点では個別のロゴは存在しないがあってもいいのではないかとか、ブランディングのガイドラインではアプリモデルの形では例があり、今後更新していくといった話も。&lt;/p&gt;
&lt;h3 id="experiment-with-unsafe.stackalloct-by-stephentoub-pull-request-60428-dotnetruntime"&gt;Experiment with Unsafe.StackAlloc&amp;lt;T&amp;gt; by stephentoub · Pull Request #60428 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60428"&gt;https://github.com/dotnet/runtime/pull/60428&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hackathon で実装されたスタック上に &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; を作れる &lt;code&gt;Unsafe.StackAlloc&amp;lt;T&amp;gt;&lt;/code&gt; のサンプル利用例の PR。&lt;/p&gt;
&lt;p&gt;この PR で見られるように現在の dotnet/runtime では &lt;code&gt;Span&amp;lt;参照型&amp;gt;&lt;/code&gt; をスタック上に作成するために次のようなテクニックを使っている。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ThreeMyClasses tmp = default;
Span&amp;lt;MyClass&amp;gt; threeMyClasses = MemoryMarshal.CreateSpan(ref tmp._value1, 3);

ref struct ThreeMyClasses
{
    internal MyClass _value1;
    private MyClass _value2;
    private MyClass _value3;
}

class MyClass { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これによりスタック上の構造体を &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; に見せかけることで参照型を含む配列的なものをアロケーションなしで作ることができる。ただし、&lt;code&gt;stackalloc&lt;/code&gt; と異なりコンパイラーがコードをチェックできず &lt;code&gt;return&lt;/code&gt; できてしまう危険性がある点に注意。&lt;/p&gt;
&lt;h3 id="proposal-readonlyspan-initialization-from-static-data-issue-5295-dotnetcsharplang"&gt;[Proposal]: ReadOnlySpan initialization from static data · Issue #5295 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/5295"&gt;https://github.com/dotnet/csharplang/issues/5295&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;private static ReadOnlySpan&amp;lt;byte&amp;gt; Bytes =&amp;gt; new byte[] { ... };&lt;/code&gt; のような最適化テクニックがあるが、一部のプリミティブでのみ使用できるものでそれ以外のケースでは罠となってしまうのでそれ用の構文が欲しいという提案。&lt;/p&gt;
&lt;h3 id="update-docs-for-pipereader.tryread-by-waf-pull-request-52237-dotnetruntime"&gt;Update docs for PipeReader.TryRead by waf · Pull Request #52237 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/52237"&gt;https://github.com/dotnet/runtime/pull/52237&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; を元にした &lt;code&gt;PipeReader.TryRead&lt;/code&gt; は &lt;code&gt;Stream&lt;/code&gt; に対して読み込みを実行しないということをドキュメントに明記するという PR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-10-15: .NET 6 RC2, Visual Studio 2022 RC2 &amp; Preview 5, .NET 5.0.11, ReSharper/Rider 2021.3 EAP</title>
			<link>/2021/10/15/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/10/15/updates</guid>
			<pubDate>Fri, 15 Oct 2021 10:55:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/"&gt;.NET 6 Release Candidate 2 (RC2) がリリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;それに合わせて ASP.NET Core, MAUI, EF Core もアップデートされ、Visual Studio 2022 も RC と Preview 5 がリリースされています。RC ということもあり新機能はあまりなく、バグ修正がメインのリリースとなっています。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 は今回から RC (リリース) と Preview でチャンネルが分かれました。RC は General Availability (GA) つまり製品版がリリースされたのち製品版へとアップデートされ、Preview チャンネルはそのまま Visual Studio 2022 の次期 Preview 版 (17.1 Preview) へと更新されるという違いがあります。&lt;/p&gt;
&lt;p&gt;以前より11月9日の &lt;a href="https://www.dotnetconf.net/"&gt;.NET Conf&lt;/a&gt; で .NET 6 がローンチされるということがアナウンスされていましたが、&lt;a href="https://visualstudio.microsoft.com/ja/launch/"&gt;Visual Studio 2022 のオンラインローンチイベントも11月8日(日本時間では11月9日)に行われる&lt;/a&gt;こともアナウンスされました。(Visual Studio 2022 に .NET 6 がついてくることを考えると、.NET 6 の実質的なリリース日はそちらになるのでしょうか…)。&lt;/p&gt;
&lt;p&gt;ASP.NET Core の Blazor WebAssembly にはネイティブ依存関係のサポートが入りました。これは Emscripten でコンパイルされたネイティブコードを C# から呼び出せるようになる仕組みです。WASM でコンパイルできる C/C++ などのライブラリーを C# から呼び出すといったことができるようになるので、できることが増えそうです。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/october-2021-updates/"&gt;.NET 5.0.11 と 3.1.20 がリリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;バグ修正とセキュリティー修正が行われています。セキュリティーに関しては Linux および macOS での &lt;code&gt;System.DirectoryServices.Protocols.LdapConnection&lt;/code&gt; で機密情報がプレーンテキストで送信されてしまうという問題が修正されています。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ReSharper と Rider の 2021.3 EAP4 がリリースされました。&lt;/p&gt;
&lt;p&gt;ReSherper はコードフォーマットの改善と dotTrace のタイムラインを開く操作やフィルター操作が高速化しました。Rider はフォーマッティングの設定や &lt;code&gt;EditorBrowsable&lt;/code&gt; のサポート追加、Unity とXamarin のサポート強化が行われています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.jetbrains.com/resharper/nextversion/"&gt;Early Access Program (EAP) - ReSharper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.jetbrains.com/rider/nextversion/"&gt;Early Access Program (EAP) - Rider: Cross-platform .NET IDE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="announcing.net-6-release-candidate-2"&gt;Announcing .NET 6 Release Candidate 2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/"&gt;https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 Release Candidate 2 (RC2) がリリースされ、合わせて Visual Studio 2022 RC および Preview 5 もリリースされた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/uikou/items/c96bbd477898a466a191"&gt;[お知らせ] Visual Studio 2022 のローンチが決定しました（日本時間 11/9 1:30 にオンラインイベントで発表）※随時アップデート予定 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://visualstudio.microsoft.com/ja/launch/"&gt;Visual Studio 2022 のローンチ イベント - Visual Studio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/join-us-november-8th-for-the-launch-of-visual-studio-2022/"&gt;Join us November 8 for the Launch of Visual Studio 2022&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;11月9日の &lt;a href="https://www.dotnetconf.net/"&gt;.NET Conf&lt;/a&gt; で .NET 6 がローンチされ、前日の11月8日(日本時間では11月9日)に&lt;a href="https://visualstudio.microsoft.com/ja/launch/"&gt;Visual Studio 2022 のオンラインローンチイベントが行われる&lt;/a&gt;こともアナウンスされた。&lt;/p&gt;
&lt;p&gt;.NET 6 は Visual Studio 2022 をサポートし、Visual Studio 2019 をサポートしないことにも触れている。なお Visual Studio は RC (リリース) と Preview でチャンネルが分かれ、RC は General Availability (GA) 時には製品版へとアップデートされ、Preview チャンネルは次期 Preview 版 (17.1 Preview) へと更新される。&lt;/p&gt;
&lt;p&gt;前回 (RC1) の記事では .NET の基礎機能について触れていたが、今回の記事では C# 10 とテンプレートについてと ARM64 対応について触れている。&lt;/p&gt;
&lt;p&gt;C# 10 については &lt;code&gt;record struct&lt;/code&gt;、&lt;code&gt;global using&lt;/code&gt;、ファイルスコープ 名前空間、&lt;code&gt;const&lt;/code&gt; と文字列補完の強化、拡張プロパティーパターンについてなど。&lt;/p&gt;
&lt;p&gt;プロジェクトテンプレートについては新しいコンソール、Web、Windows Forms 向けに生成されるものについて。その他、暗黙の using と Nullable reference types の有効化、コマンドライン引数が &lt;code&gt;args&lt;/code&gt; としてアクセス可能といった点に触れている。&lt;/p&gt;
&lt;p&gt;ARM64 の対応については &lt;a href="/2021/10/08/updates#net-6-rc2-update-for-macos-and-windows-arm64-issue-21686-dotnetsdk"&gt;2021/10/08 のトピックスで触れたものと同様&lt;/a&gt;のアナウンスがされている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x64 版と ARM64 版のインストールの共存可能になる&lt;/li&gt;
&lt;li&gt;.NET 6 RC2 以降では一度すべての .NET をアンインストールする必要がある&lt;/li&gt;
&lt;li&gt;コマンドラインから ARM64 のコマンドを使用して x64 の開発が行える (逆も)&lt;/li&gt;
&lt;li&gt;パフォーマンス上の理由からも ARM64 SDK を使用してほしい&lt;/li&gt;
&lt;li&gt;SDK は .NET 6+ の ARM64 のみをサポートする&lt;/li&gt;
&lt;li&gt;ランタイムはすべてのバージョンの ARM64, x64 共にサポートする&lt;/li&gt;
&lt;li&gt;.NET 6 RC2 で x64 エミュレーションも含む ARM64 の .NET 6 体験を提供&lt;/li&gt;
&lt;li&gt;.NET Core 3.1, .NET 5 のランタイムも .NET 6 に合わせて更新予定 (ただし時期は未定)&lt;/li&gt;
&lt;li&gt;RC2 ナイトリービルドは現在壊れているため数週間後にリリースされる RC2 を待ってほしい&lt;/li&gt;
&lt;li&gt;.NET 5 SDK for Windows ARM64 は .NET 6 RTM 後に早期終了予定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NET 6 がリリース後は .NET 5 SDK のサポートが終了することに注意が必要。&lt;/p&gt;
&lt;h3 id="visual-studio-2022-for-mac-preview-2-is-now-available"&gt;Visual Studio 2022 for Mac Preview 2 is now available&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-2-is-now-available/"&gt;https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-2-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac Preview 2 がリリースされた。&lt;/p&gt;
&lt;p&gt;.NET 6 RC2 への対応と UI の修正やネイティブ化が進んだ。.NET 6 RC2 は手動でインストールが必要。現時点では Intel 環境のみのサポートで M1 (Apple Silicon) 環境での動作はサポートしていないことに注意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/uikou/items/83393ddf65eaae068bc4"&gt;Visual Studio 2022 for Mac の Public Preview 2 がリリースされました - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#1700-pre2--visual-studio-2022-for-mac-version-170-preview-2-newreleasebutton"&gt;Visual Studio 2022 for Mac v17.0 Preview - Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="asp.net-core-updates-in.net-6-release-candidate-2"&gt;ASP.NET Core updates in .NET 6 Release Candidate 2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-6-rc-2/"&gt;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-6-rc-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 RC2 での ASP.NET Core のアップデートについての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/uikou/items/918f49aebb086c6d0b57"&gt;.NET 6 Release Candidate 2 における ASP.NET Core アップデート - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既存のプロジェクトのアップデート方法や、Blazor WebAssembly のネイティブ依存関係のサポートとその呼び出し、Minimal API の強化について触れている。&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly のネイティブ依存関係のサポートは ネイティブコードを .NET WebAssembly ビルドツール (Emscripten) でリンクすることで .NET WebAssembly から P/Invoke で呼び出すことが可能となるもの。記事では C のソースコードを作成し、それをプロジェクトに含めてビルドし、C# から呼び出す例が掲載されている。依存として使用できるものは C/C++ のソースコードと事前に Emscripten によってコンパイルされている &lt;code&gt;.a&lt;/code&gt;, &lt;code&gt;.o&lt;/code&gt;, &lt;code&gt;.bc&lt;/code&gt;, &lt;code&gt;.wasm&lt;/code&gt; といったファイル。&lt;/p&gt;
&lt;p&gt;また、ネイティブ依存関係を NuGet パッケージにパッケージングする方法や SkiaSharp を例に既に WebAssembly がパッケージングされたものを使用する方法についても触れている。&lt;/p&gt;
&lt;p&gt;Minimal API の強化についてはパラメータバインディングと OpenAPI 対応、アナライザーの追加などが行われた。パラメータバインディングは &lt;code&gt;TryParse&lt;/code&gt; と &lt;code&gt;BindAsync&lt;/code&gt; という名前の静的メソッドをバインド対象の型に定義することで呼び出される仕組みとなっている。&lt;/p&gt;
&lt;h3 id="announcing.net-maui-preview-9"&gt;Announcing .NET MAUI Preview 9&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-9/"&gt;https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-9/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET MAUI Preview 9 がリリースされた。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BoxView&lt;/code&gt;, &lt;code&gt;IndicatorView&lt;/code&gt;, &lt;code&gt;ImageButton&lt;/code&gt;, &lt;code&gt;WebView&lt;/code&gt; といったコントロールの実装が更新された。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Border&lt;/code&gt; コントロールが新たに導入され、角丸を含むボーダーを描画できるようになった。またレイアウトや画像などのコントロールに影をつける &lt;code&gt;Shadow&lt;/code&gt; も導入された。&lt;/p&gt;
&lt;p&gt;Android においてスタートアップ部分のトレーシングを行うことで部分的に AOT を行い、スタートアップのパフォーマンスを改善するプロファイルが追加された。通常の AOT ではアプリケーション全体をコンパイルするため、パフォーマンスは改善される反面アプリケーションサイズが肥大化してしまう問題があり、スタートアップトレーシングではそのバランスをとることができる。&lt;/p&gt;
&lt;h3 id="release-ef-core-6.0-rc2-dotnetefcore"&gt;Release EF Core 6.0 RC2 · dotnet/efcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/releases/tag/v6.0.0-rc.2.21480.5"&gt;https://github.com/dotnet/efcore/releases/tag/v6.0.0-rc.2.21480.5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 6.0 RC2 がリリースされた。&lt;/p&gt;
&lt;p&gt;RC1 の時点でほぼ feature complete となっていたため、バグ修正が主な変更内容となっている。一点 RC1 時点で積み残しであったカラムの並びを &lt;code&gt;Column&lt;/code&gt; 属性で指定する機能が含まれている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/efcore/issues/10059"&gt;Allow defining column order via [ColumnAttribute.Order] when creating tables · Issue #10059 · dotnet/efcore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-october-2021-updates-5.0.11-and-3.1.20"&gt;.NET October 2021 Updates – 5.0.11 and 3.1.20&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/october-2021-updates/"&gt;https://devblogs.microsoft.com/dotnet/october-2021-updates/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5.0.11 と 3.1.20 がリリースされた。&lt;/p&gt;
&lt;p&gt;バグ修正とセキュリティー対応が行われ、Linux および macOS での &lt;code&gt;System.DirectoryServices.Protocols.LdapConnection&lt;/code&gt; で機密情報がプレーンテキストで送信されてしまうという問題が修正された。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/announcements/issues/202"&gt;Microsoft Security Advisory CVE-2021-41355 | .NET Core Information Disclosure Vulnerability · Issue #202 · dotnet/announcements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="resharper-2021.3-eap4-rider-2021.3-eap4"&gt;ReSharper 2021.3 EAP4 / Rider 2021.3 EAP4&lt;/h3&gt;
&lt;p&gt;ReSharper と Rider の 2021.3 EAP4 がリリースされた。&lt;/p&gt;
&lt;p&gt;ReSherper はコードフォーマットの改善と dotTrace のタイムラインを開く操作やフィルター操作が高速化。&lt;/p&gt;
&lt;p&gt;Rider はフォーマッティングの設定や &lt;code&gt;EditorBrowsable&lt;/code&gt; のサポート追加、Unity の外部パッケージに含まれるファイルの取り扱いや .asmdef のサポート強化、Xamarin の Android レイアウトエディターの強化や AndroidX ライブラリーのサポート強化など。&lt;/p&gt;
&lt;!-- https://twitter.com/resharper/status/1448589029226713091?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;ReSharper 2021.3 EAP4 brings new formatting settings and better performance in dotTrace Timeline snapshots. Read more here: &lt;a href="https://t.co/SdZYUC5gcf"&gt;https://t.co/SdZYUC5gcf&lt;/a&gt; &lt;a href="https://t.co/7QXNS33sJe"&gt;pic.twitter.com/7QXNS33sJe&lt;/a&gt;&lt;/p&gt;— JetBrains ReSharper (@resharper) &lt;a href="https://twitter.com/resharper/status/1448589029226713091?ref_src=twsrc%5Etfw"&gt;October 14, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;!-- https://twitter.com/jetbrainsrider/status/1448600182367662080?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Rider 2021.3 EAP4 is out with new Code Vision metrics and updates for Unity, Xamarin, the debugger, and environment configuration. Learn more and download it here: &lt;a href="https://t.co/2dPfI9RjQI"&gt;https://t.co/2dPfI9RjQI&lt;/a&gt; &lt;a href="https://t.co/cdgNEShjxQ"&gt;pic.twitter.com/cdgNEShjxQ&lt;/a&gt;&lt;/p&gt;— JetBrains Rider (@JetBrainsRider) &lt;a href="https://twitter.com/JetBrainsRider/status/1448600182367662080?ref_src=twsrc%5Etfw"&gt;October 14, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="resharper-2021.2.2-and-rider-2021.2.2-bug-fixes-have-landed-the.net-tools-blog"&gt;ReSharper 2021.2.2 and Rider 2021.2.2 bug fixes have landed | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/13/resharper-and-rider-2021-2-2/"&gt;https://blog.jetbrains.com/dotnet/2021/10/13/resharper-and-rider-2021-2-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReSharper 2021.2.2 と Rider 2021.2.2 がリリースされた。&lt;/p&gt;
&lt;p&gt;それぞれバグ修正がメインのリリース。ReSharper では C# 10 の const を使用した文字列補完、Rider ではビルトインのコンソールに関する問題が修正された。&lt;/p&gt;
&lt;h3 id="release-0.10.8-avaloniauiavalonia"&gt;Release 0.10.8 · AvaloniaUI/Avalonia&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/AvaloniaUI/Avalonia/releases/tag/0.10.8"&gt;https://github.com/AvaloniaUI/Avalonia/releases/tag/0.10.8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Avalonia 0.10.8 がリリースされた。&lt;/p&gt;
&lt;p&gt;タスクトレイアイコンサポートやマスクされたテキストボックスの追加、様々なバグ修正が行われている。&lt;/p&gt;
&lt;h3 id="cake-cake-v1.3.0-released"&gt;Cake - Cake v1.3.0 released&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://cakebuild.net/blog/2021/10/cake-v1.3.0-released"&gt;https://cakebuild.net/blog/2021/10/cake-v1.3.0-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cake 1.3.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;.NET 6 のサポートや Visual Studio 2022、MSBuild 17 への対応が含まれている。その他終了コードを指定してビルドプロセスを終了させる機能やディレクトリが存在する場合に削除する &lt;code&gt;EnsureDirectoryDoesNotExist&lt;/code&gt; の追加など。&lt;/p&gt;
&lt;h3 id="release-ilspy-7.2-preview-1-icsharpcodeilspy"&gt;Release ILSpy 7.2 Preview 1 · icsharpcode/ILSpy&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/icsharpcode/ILSpy/releases/tag/v7.2-preview1"&gt;https://github.com/icsharpcode/ILSpy/releases/tag/v7.2-preview1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ILSpy 7.2 Preview 1 がリリースされた。&lt;/p&gt;
&lt;p&gt;Roslyn 3.11 に合わせたパターン検出、C# 7.0 のパターンマッチングと C# 9 の共変戻り値のサポート、その他修正や機能強化がふくまれる。&lt;/p&gt;
&lt;h3 id="a-preview-of-wsl-in-the-microsoft-store-is-now-available-windows-command-line"&gt;A preview of WSL in the Microsoft Store is now available! - Windows Command Line&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/commandline/a-preview-of-wsl-in-the-microsoft-store-is-now-available/"&gt;https://devblogs.microsoft.com/commandline/a-preview-of-wsl-in-the-microsoft-store-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WSL のプレビュー版が Microsoft Store からインストール可能となった。&lt;/p&gt;
&lt;p&gt;現在の WSL は Windows の機能としてインストールする形だが、WSL のプレビュー版は Microsoft Store から提供される。これにより Windows のアップデートに依存せず WSL の更新が行えるようになるため、新機能の提供サイクルを早められるとしている。将来的には WSL のインストールは Microsoft Store からにしたいとのこと。&lt;/p&gt;
&lt;p&gt;現在のプレビューでは WSLg や VHD のマウント、カーネルアップデートなどが含まれている。&lt;/p&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="dotnet-centralized-package-versioning"&gt;dotnet centralized package versioning&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/kritner/dotnet-centralized-package-versioning-4i41"&gt;https://dev.to/kritner/dotnet-centralized-package-versioning-4i41&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NuGet パッケージのバージョンを一か所 (&lt;code&gt;Directory.Packages.props&lt;/code&gt;) に定義することで、リポジトリワイドでパッケージのバージョンを統一する &lt;code&gt;&amp;lt;ManagePackageVersionsCentrally&amp;gt;&lt;/code&gt; についての記事。&lt;/p&gt;
&lt;p&gt;プレビューな機能ではあるが &lt;code&gt;Directory.Packages.props&lt;/code&gt; を作成して、プロジェクト側に &lt;code&gt;&amp;lt;ManagePackageVersionsCentrally&amp;gt;true&amp;lt;/ManagePackageVersionsCentrally&amp;gt;&lt;/code&gt; を指定することで使用できる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/NuGet/Home/wiki/Centrally-managing-NuGet-package-versions"&gt;Centrally managing NuGet package versions · NuGet/Home Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spanmemoryintptrarray-qiita"&gt;SpanとかMemoryとかIntPtrとかArrayの変換方法チートシート - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/kenichiuda/items/510a3443181e3602e2eb"&gt;https://qiita.com/kenichiuda/items/510a3443181e3602e2eb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Span や Memory, IntPtr や配列といったものを相互で変換する方法についてのチートシート。&lt;/p&gt;
&lt;h3 id="prime-your-flux-capacitor-sql-server-temporal-tables-in-ef-core-6.0"&gt;Prime your flux capacitor: SQL Server temporal tables in EF Core 6.0&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/prime-your-flux-capacitor-sql-server-temporal-tables-in-ef-core-6-0/"&gt;https://devblogs.microsoft.com/dotnet/prime-your-flux-capacitor-sql-server-temporal-tables-in-ef-core-6-0/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 6.0 でサポートされた、SQL Server のテンポラル テーブル (バージョニング) を扱うことについての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/sql/relational-databases/tables/temporal-tables?view=sql-server-ver15"&gt;テンポラル テーブル - SQL Server | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-6"&gt;.NET 6 で動的にコンポーネントをレンダリングする機能が追加されたので試してみる&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/okazuki/articles/blazor-dynamic-component"&gt;https://zenn.dev/okazuki/articles/blazor-dynamic-component&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Blazor で追加された、型を指定して動的にコンポーネントをレンダリングする &lt;code&gt;DynamicComponent&lt;/code&gt; コンポーネントについての記事。&lt;/p&gt;
&lt;h3 id="javascript-equivalent-of-c-out-keyword"&gt;JavaScript equivalent of C# 'out' keyword&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/sincovschi/javascript-equivalent-of-c-out-keyword-2l2b"&gt;https://dev.to/sincovschi/javascript-equivalent-of-c-out-keyword-2l2b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JavaScript を書く際に C# の &lt;code&gt;out&lt;/code&gt; キーワードと同じことをするにはどうすればいいかという記事。&lt;/p&gt;
&lt;p&gt;例えば &lt;code&gt;TryParse&lt;/code&gt; に相当する関数を書くようなケースの書き方。&lt;code&gt;null&lt;/code&gt; を返す方法、&lt;code&gt;{ isNumber, number }&lt;/code&gt; のようにオブジェクトで返す方法、オブジェクトを渡すことで書き換える方法、他にもトリッキーな方法について触れている。&lt;/p&gt;
&lt;h3 id="dotnet-code-generation-overview-by-example"&gt;Dotnet code generation overview by example&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/maximtkachenko/dotnet-code-generation-overview-by-example-1m16"&gt;https://dev.to/maximtkachenko/dotnet-code-generation-overview-by-example-1m16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;簡単なパーサーを例としたコード生成を行う手法についての比較の記事。&lt;/p&gt;
&lt;p&gt;IL Emit, Expression Tree, Reflection, Sigil, Roslyn, Source Generator, 手書きといったパターンでのコード例とパーサーの生成時間、呼び出しコストなどの比較をしている。&lt;/p&gt;
&lt;h3 id="worlds-smallest-c-program-featuring-n"&gt;World's Smallest C# Program (featuring &lt;code&gt;N&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://nietras.com/2021/10/09/worlds-smallest-csharp-program/"&gt;https://nietras.com/2021/10/09/worlds-smallest-csharp-program/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET で最小のプログラムはどうなるのかという記事。&lt;/p&gt;
&lt;p&gt;結論としては .NET 5 以降と C# 9.0 以降であれば &lt;code&gt;{}&lt;/code&gt; の2文字で何もしないプログラムを記述でき、.NET 6 と C# 10 以降であれば &lt;code&gt;N();&lt;/code&gt; という4文字で何かをするプログラムを記述できる。記事ではそれぞれにたどり着くまでの経過と、.NET 6 で何かする &lt;code&gt;N();&lt;/code&gt; を記述できるようになるまでのパッケージ等について書かれている。&lt;/p&gt;
&lt;h3 id="testing-asp.net-core-web-applications-with-webapplicationfactory-its-all-about-tech"&gt;Testing ASP.NET Core web applications with WebApplicationFactory - It’s all about tech&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://renatogolia.com/2021/10/11/testing-asp-net-core-web-applications-with-webapplicationfactory/"&gt;https://renatogolia.com/2021/10/11/testing-asp-net-core-web-applications-with-webapplicationfactory/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="bring-vs-code-themes-to-visual-studio-2022-visual-studio-blog"&gt;Bring VS Code themes to Visual Studio 2022! - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/vs-code-themes-in-vs/"&gt;https://devblogs.microsoft.com/visualstudio/vs-code-themes-in-vs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio Code のテーマを Visual Studio 2022 にコンバートするという記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/theme-converter-for-vs"&gt;microsoft/theme-converter-for-vs: CLI tool that allows you to convert your VS Code color theme to a VS 2022 color theme.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="copy-code-reference-in-resharper-and-rider-2021.3-eap-the.net-tools-blog"&gt;Copy Code Reference in ReSharper and Rider 2021.3 EAP | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/11/copy-code-reference-in-resharper-and-rider-2021-3-eap/"&gt;https://blog.jetbrains.com/dotnet/2021/10/11/copy-code-reference-in-resharper-and-rider-2021-3-eap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReSharper と Rider 2021.3 EAP に搭載された、コードの参照をコピーする機能についての記事。&lt;/p&gt;
&lt;p&gt;コードの参照は FQN (&lt;code&gt;Namespace.Type.Member&lt;/code&gt; の形式) や XML ドキュメントの ID でのコピーに加え、カスタムのパターンに展開する方法についても触れている。&lt;/p&gt;
&lt;h3 id="supporting-ef-core-migrations-with-webapplicationbuilder-exploring.net-core-6-part-5"&gt;Supporting EF Core migrations with WebApplicationBuilder: Exploring .NET Core 6 - Part 5&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-5-supporting-ef-core-tools-with-webapplicationbuilder/"&gt;https://andrewlock.net/exploring-dotnet-6-part-5-supporting-ef-core-tools-with-webapplicationbuilder/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Entity Framework Core のマイグレーションをはじめとするツールが &lt;code&gt;IServiceProvider&lt;/code&gt; を取得する流れについての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WebApplicationBuilder&lt;/code&gt; のような Minimal API に対応するために、&lt;code&gt;DiagnosticSource&lt;/code&gt; を駆使して &lt;code&gt;IHost&lt;/code&gt; の生成をとらえているといった話。&lt;/p&gt;
&lt;h3 id="reading-asynclocal-values-from-a-memory-dump"&gt;Reading AsyncLocal values from a memory dump&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://kevingosse.medium.com/reading-asynclocal-values-from-a-memory-dump-8be356a46b29"&gt;https://kevingosse.medium.com/reading-asynclocal-values-from-a-memory-dump-8be356a46b29&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsyncLocal&amp;lt;T&amp;gt;&lt;/code&gt; が内部ではどのように格納されているのかについての記事。&lt;/p&gt;
&lt;p&gt;実際にメモリーダンプを取って WinDbg で読み取る方法や ClrMD で読み取ってみるといったことをしている。&lt;/p&gt;
&lt;h3 id="refactor-functional-tests-to-support-minimal-web-apis"&gt;Refactor Functional Tests to support Minimal Web APIs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/this-is-learning/refactor-functional-tests-to-support-minimal-web-apis-4p2e"&gt;https://dev.to/this-is-learning/refactor-functional-tests-to-support-minimal-web-apis-4p2e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Minimal API を使用した ASP.NET Core アプリのファンクショナルテストを行う方法についての記事。&lt;/p&gt;
&lt;h3 id="try-out.net-6-inside-your-own-development-environment-built-with-devcontainers-docker-and-vscode"&gt;Try out .NET 6 inside your own development environment built with devcontainers, docker, and vscode&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/nikiforovall/try-out-net-6-inside-your-own-development-environment-built-with-devcontainers-docker-and-vscode-4fe4"&gt;https://dev.to/nikiforovall/try-out-net-6-inside-your-own-development-environment-built-with-devcontainers-docker-and-vscode-4fe4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio Code の Devcontainer を使って .NET 6 を試すという記事。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="github-jpobstclassic-dotnet-templates.net-6-project-templates-that-do-not-use-top-level-statements"&gt;GitHub - jpobst/classic-dotnet-templates: .NET 6+ project templates that do not use top level statements&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/jpobst/classic-dotnet-templates"&gt;https://github.com/jpobst/classic-dotnet-templates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 向けの Top-level Statements を使用しない、昔ながらのプロジェクトを作成するテンプレート。&lt;/p&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="internalsvisibleto-msbuild-msbuild"&gt;InternalsVisibleTo - MSBuild プロジェクトの共通項目 - MSBuild&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/visualstudio/msbuild/common-msbuild-project-items?view=vs-2019#internalsvisibleto"&gt;https://docs.microsoft.com/ja-jp/visualstudio/msbuild/common-msbuild-project-items?view=vs-2019#internalsvisibleto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core または .NET 5 SDK のプロジェクトでは &lt;code&gt;InternalsVisibleTo&lt;/code&gt; をプロジェクトに定義することでビルド時にアセンブリの属性を出力する。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;InternalsVisibleTo Include="Nantoka.Test" /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="performancemicrobenchmark-design-guidelines.md-at-main-dotnetperformance"&gt;performance/microbenchmark-design-guidelines.md at main · dotnet/performance&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/performance/blob/main/docs/microbenchmark-design-guidelines.md"&gt;https://github.com/dotnet/performance/blob/main/docs/microbenchmark-design-guidelines.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET ランタイムのマイクロベンチマークのガイドライン。&lt;/p&gt;
&lt;h3 id="carbon"&gt;Carbon&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://carbon.now.sh/"&gt;https://carbon.now.sh/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ソースコードを画像にしてシェアできるサービス。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/9012/137476689-d20dd453-0b4f-4388-9592-3489e12d4561.png" alt="carbon"&gt;&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/egorbo/status/1447221009950593032?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;This .NET benchmark is 4x faster on M1 Rosetta (x64 emulation) then on the same M1 but natively (arm64) 🙃 &lt;a href="https://t.co/9gr8kt9Zth"&gt;pic.twitter.com/9gr8kt9Zth&lt;/a&gt;&lt;/p&gt;— Egor Bogatov (@EgorBo) &lt;a href="https://twitter.com/EgorBo/status/1447221009950593032?ref_src=twsrc%5Etfw"&gt;October 10, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;メモリーオーダーリングの違いで M1 の Rosetta (x64 エミュレーション) のほうが M1 (arm64) ネイティブよりも速くなってしまうケースがあるという話。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60232"&gt;[arm64] Volatile.Read/Write is 2x faster than "volatile" loads/stores · Issue #60232 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1446893764694380548?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;.NET 6 introduces a new Reflection API for nullability information.&lt;br&gt;&lt;br&gt;It provides nullability information and context from reflection members:&lt;br&gt;• ParameterInfo&lt;br&gt;• FieldInfo&lt;br&gt;• PropertyInfo&lt;br&gt;• EventInfo&lt;a href="https://twitter.com/hashtag/dotnet6?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet6&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/reflection?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#reflection&lt;/a&gt; &lt;a href="https://t.co/GbW3uIHIBF"&gt;pic.twitter.com/GbW3uIHIBF&lt;/a&gt;&lt;/p&gt;— Oleg Kyrylchuk (@okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1446893764694380548?ref_src=twsrc%5Etfw"&gt;October 9, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 で導入された Nullability を取得する Reflection API について。&lt;/p&gt;
&lt;!-- https://twitter.com/james_m_south/status/1447010033510744066?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Really looking forward to the coming year of working on ImageSharp. Once we ship V2 which will include some awesome features and performance improvements the focus will switch immediately to V3 which will drop all the legacy target frameworks.&lt;/p&gt;— JimBobSquarePants (@James_M_South) &lt;a href="https://twitter.com/James_M_South/status/1447010033510744066?ref_src=twsrc%5Etfw"&gt;October 10, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;ImageSharp は V2 をリリースしたのち V3 にフォーカスし、レガシーフレームワークのサポートを削除する予定 (.NET Core 3.1 が最低ライン) とのこと。&lt;/p&gt;
&lt;!-- https://twitter.com/sergiopedri/status/1448397332572213255?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Our DevDiv friends have been going absolutely crazy this hackaton! This stuff is now checked in (not in main):&lt;br&gt;- stackalloc for all Ts&lt;br&gt;- Constant ReadOnlySpan&amp;lt;T&amp;gt; for all primitives&lt;br&gt;- ref fields (!)&lt;br&gt;- Generic *everything* (!!)&lt;br&gt;- refs to refs&lt;br&gt;Don't wake me up now 🚀&lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt;&lt;/p&gt;— Sergio Pedri (@SergioPedri) &lt;a href="https://twitter.com/SergioPedri/status/1448397332572213255?ref_src=twsrc%5Etfw"&gt;October 13, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;DevDiv でハッカソンをやっているという話。実際幾つかのリポジトリにハッカソンのようなブランチとその PR が上がっているのでそのことのよう。Spec がないようなものもあり、デモ用のブランチにマージされているので PoC を兼ねている模様。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/57104"&gt;Support params SpanT by cston · Pull Request #57104 · dotnet/roslyn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/57123"&gt;RuntimeHelpers.CreateSpan optimization for stackalloc by svick · Pull Request #57123 · dotnet/roslyn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/57135"&gt;Support 'ref' type arguments in delegates by RikkiGibson · Pull Request #57135 · dotnet/roslyn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60303"&gt;Checkin the work for coreclr around stackalloc, ref fields and arbitrary generics to hackathon tree by davidwrighton · Pull Request #60303 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60320"&gt;Constraint generic work by davidwrighton · Pull Request #60320 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="add-simpler-way-to-get-the-old-style-console-templates-issue-3985-dotnettemplating"&gt;Add simpler way to get the "old style" console templates · Issue #3985 · dotnet/templating&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/templating/issues/3985"&gt;https://github.com/dotnet/templating/issues/3985&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 とそれ以前のスタイルのコンソールアプリケーションテンプレートを使いたいという話の Issue。現時点では .NET 6 GA にそのようなものは含めるつもりはないとのこと。&lt;/p&gt;
&lt;h3 id="file.alltext-optimizations-by-adamsitnik-pull-request-58167-dotnetruntime"&gt;File.&lt;em&gt;AllText&lt;/em&gt; optimizations by adamsitnik · Pull Request #58167 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/58167"&gt;https://github.com/dotnet/runtime/pull/58167&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File.*AllText*&lt;/code&gt; メソッドの実装を最適化することでメモリーアロケーションと処理時間を削減するという PR。&lt;code&gt;StreamWriter&lt;/code&gt;/&lt;code&gt;FileStream&lt;/code&gt; を介さないようにすることでメモリーの削減、大き目のバッファの確保とファイルシステムの事前アロケーションによって CPU 負荷を削減。&lt;/p&gt;
&lt;h3 id="add-support-for-non-seekable-files-to-randomaccess-by-adamsitnik-pull-request-58506-dotnetruntime"&gt;Add support for non-seekable files to RandomAccess by adamsitnik · Pull Request #58506 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/58506"&gt;https://github.com/dotnet/runtime/pull/58506&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;シークできないハンドル(ネットワークや名前付きパイプなど)に対して &lt;code&gt;RandomAccess&lt;/code&gt; クラスの &lt;code&gt;Write&lt;/code&gt;/&lt;code&gt;Read&lt;/code&gt; を使用できるようにする PR (なぜかクローズされた)。&lt;/p&gt;
&lt;h3 id="plaintextmvc-benchmark-is-slow-on-arm64-issue-60166-dotnetruntime"&gt;PlaintextMVC benchmark is slow on arm64 · Issue #60166 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60166"&gt;https://github.com/dotnet/runtime/issues/60166&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ARM64 の PlaintextMVC ベンチマーク(とその他ベンチマーク)が x64 に比べて遅いという Issue。プロセッサーのキャッシュサイズによって決まる Gen0 のサイズによって GC が影響を受けているといった話。&lt;/p&gt;
&lt;h3 id="is-new-crashes-csc.exe-issue-57088-dotnetroslyn"&gt;"is new()" crashes csc.exe · Issue #57088 · dotnet/roslyn&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/roslyn/issues/57088"&gt;https://github.com/dotnet/roslyn/issues/57088&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T is new()&lt;/code&gt; で C# コンパイラーがクラッシュするという Issue (Visual Studio もエラーを吐く)。17.1 で修正される可能性がある。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void Foo&amp;lt;T&amp;gt;()
{
    if (T is new ())
    { }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="how-to-properly-benchmark-filestream.write-vs-writefile-issue-60268-dotnetruntime"&gt;How to properly benchmark FileStream.Write vs WriteFile? · Issue #60268 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60268"&gt;https://github.com/dotnet/runtime/issues/60268&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Win32 API の &lt;code&gt;WriteFile&lt;/code&gt; と &lt;code&gt;FileStream.Write&lt;/code&gt; では &lt;code&gt;FileStream.Write&lt;/code&gt; のほうが遅い、という話が元々の Issue。&lt;/p&gt;
&lt;p&gt;コメントで BenchmarkDotNet でこうすると良いし、その結果特に遅くないという結果が出たため件名が変更された。他にも Issue を立てた人のシナリオであれば .NET 6 で Preallocaiton を使用したり、バッファリングをオフにすると良いといった話も。&lt;/p&gt;
&lt;h3 id="make-upgrade-install-new-host-first-then-uninstall-old-by-ericstj-pull-request-60307-dotnetruntime"&gt;Make upgrade install new host first, then uninstall old by ericstj · Pull Request #60307 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60307"&gt;https://github.com/dotnet/runtime/pull/60307&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dotnet コマンドへのパスは PATH の後ろに追加されるため、x86 と x64 の SDK がインストールされたような環境でアップグレードインストールすると x86 のものが残り、x64 環境においても x86 版が使用されてしまう問題。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sdk/issues/22047"&gt;[Known Issue]  Installing VS2022 Preview 5.0 and/or .NET 6.0 RC2 results in x86 dotnet on the PATH · Issue #22047 · dotnet/sdk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60317"&gt;[release/6.0] Make upgrade install new host first, then uninstall old by github-actions[bot] · Pull Request #60317 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lateapexearlyspeed-issue-30778-create-method-tryreadexact.by-lateapexearlyspeed-pull-request-57921-dotnetruntime"&gt;lateapexearlyspeed-issue-30778 Create method: TryReadExact(). by lateapexearlyspeed · Pull Request #57921 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/57921"&gt;https://github.com/dotnet/runtime/pull/57921&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequenceReader&amp;lt;T&amp;gt;&lt;/code&gt; に指定したサイズを読むことを試みる &lt;code&gt;TryReadExact&lt;/code&gt; を追加する PR。.NET 7 に入る予定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/30778"&gt;API Proposal: SequenceReader&lt;t&gt;.TryRead overloads to read a specified number of elements · Issue #30778 · dotnet/runtime&lt;/t&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="implement-iasyncenumerablet.toblockingenumerable-by-eiriktsarpalis-pull-request-60363-dotnetruntime"&gt;Implement IAsyncEnumerable&amp;lt;T&amp;gt;.ToBlockingEnumerable by eiriktsarpalis · Pull Request #60363 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60363"&gt;https://github.com/dotnet/runtime/pull/60363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; をブロッキングな &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; に変換する拡張メソッドの追加 PR と提案 Issue。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60106"&gt;[API Proposal]: Add an IAsyncEnumerable&amp;lt;T&amp;gt;.ToEnumerable extension method. · Issue #60106 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-10-08: .NETのクラスライブラリ設計 改訂新版, Umbraco 9, Visual Studio 2022 for Mac Preview 1</title>
			<link>/2021/10/08/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/10/08/updates</guid>
			<pubDate>Fri, 08 Oct 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://www.nikkeibp.co.jp/atclpubmkt/book/21/S80040/"&gt;.NETのクラスライブラリ設計 改訂新版&lt;/a&gt; (&lt;a href="https://www.amazon.co.jp/gp/product/4296080040"&gt;Amazon&lt;/a&gt;) が10/7に発売されました。&lt;/p&gt;
&lt;p&gt;この本は .NET Framework を開発した中で出てきたクラスライブラリーを作る上でのノウハウをまとめたベストプラクティス集のようなものです。&lt;/p&gt;
&lt;p&gt;クラスライブラリーを設計するうえでどういった部分に気を付ければよいのか、何をすべきで何をすべきではないのかといったものが書かれているのですが、この本の特徴的な部分は .NET 開発チームの声が注釈としてたくさん入っていることです。そこには .NET でなぜその選択をしたのかといった理由をはじめ、時には後悔なども書かれており、それを読むだけでも楽しめます。&lt;/p&gt;
&lt;p&gt;前の翻訳版は .NET 開発者の中では知る人ぞ知るといった本だったのですが既に12年が経過し内容も古くなっていたこともあり、待望の改訂となりました。この改訂では .NET Framework から .NET Core 世代に変化したような時代に合わせた内容となっています。例えば C# 5 以降に関する記述や Task ベースの非同期、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; などを含むバッファパターンについてなど多くの項目が増えています。&lt;/p&gt;
&lt;p&gt;また付録もボリュームがあり、コーディング規約や破壊的変更について、さらには日本語翻訳版独自の翻訳者と監訳者による座談会風の雑感なども収録されて読み応えが増しています。&lt;/p&gt;
&lt;p&gt;今では NuGet や GitHub といったものが一般的になりライブラリーを作る人が増えたためそういった方々にお勧めできるのはもちろん、クラスライブラリーに限らずアプリケーションのコードにおいても一貫性や使いやすさといった面で多くの .NET 開発の上で参考になる一冊だと思います。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://umbraco.com/blog/umbraco-9-release/"&gt;Umbraco 9&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;Umbraco は .NET 界の中では比較的歴史のあるオープンソースの CMS です。その Umbraco が 9 で .NET Framework から .NET 5 への移行を完了しています。これによりパフォーマンスの向上や開発体験の向上、マルチプラットフォームでの動作が可能となるといった恩恵を受けられるようになったそうです。&lt;/p&gt;
&lt;p&gt;Umbraco も実際に .NET Core 世代に移行を検討してから年単位で時間がかかったようなので、先日の Paint.NET のように歴史のあるプロジェクトが .NET 5 以降に移行するものがそろそろ増え始めるのかもしれません。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-1-is-now-available/"&gt;Visual Studio 2022 for Mac Preview 1&lt;/a&gt; がリリースされました。先日まで Private Preview だったのですが Public Preview として一般公開されました。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac は目玉として UI の macOS ネイティブ化が進められています。これにより UI のフィーリング(見た目や挙動)が macOS のものと近くなりパフォーマンスと安定性も向上するとしています。またアクセシビリティ面でも VoiceOver の対応といった利点があります。&lt;/p&gt;
&lt;p&gt;Preview 1 では主に C# 10 と .NET 6 SDK 対応が含まれており、MAUI の対応は後ほどとなるようです。全体的な UI の再構築を行っていることもあり、現時点では設定画面や一部機能がまだ不完全なところが多くある(未実装や項目が減っている)のでその点は注意が必要です。&lt;/p&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="umbraco-9-release-umbraco-powered-by.net-5-asp.net-core"&gt;Umbraco 9 release | Umbraco powered by .NET 5 &amp;amp; ASP.NET Core&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://umbraco.com/blog/umbraco-9-release/"&gt;https://umbraco.com/blog/umbraco-9-release/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オープンソースの CMS の Umbraco 9 がリリースされた。&lt;/p&gt;
&lt;p&gt;2年前からスタートした .NET Framework から .NET 5 および ASP.NET Core へ移行が完了。&lt;/p&gt;
&lt;p&gt;.NET 5 へ移行したことによりパフォーマンス向上や Microsoft.Extensions.DependencyInjection や Configuration を元にしたアーキテクチャへの変更による開発しやすさの向上、Windows 以外のプラットフォームのサポートが可能となった。&lt;/p&gt;
&lt;h3 id="visual-studio-2022-for-mac-preview-1-is-now-available-visual-studio-blog"&gt;Visual Studio 2022 for Mac Preview 1 is now available! - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-1-is-now-available/"&gt;https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-1-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac の Preview 1 がリリースされた。Private Preview から Public Preview となったことで登録不要でインストール可能となった。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac は UI の macOS ネイティブへの刷新がフォーカスされている。これによりパフォーマンスと安定性の向上、操作や表示のフィーリングの改善、アクセシビリティの対応 (VoiceOver) といった恩恵を受けられる。&lt;/p&gt;
&lt;p&gt;その他 .NET 6 と C# 10 への対応や Git ツーリングの改善などが含まれている。&lt;/p&gt;
&lt;p&gt;Preview 1 では多くの機能が不完全であり(例えば設定画面等)、MAUI への対応ものちの Preview にて提供予定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/uikou/items/ae0a54d18b0557f8477e"&gt;Visual Studio 2022 for Mac Preview 1 がリリースされました - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ml.net-updates-announcing-notebooks-in-visual-studio.net-blog"&gt;ML.NET Updates &amp;amp; Announcing Notebooks in Visual Studio - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/ml-net-and-model-builder-october-updates/"&gt;https://devblogs.microsoft.com/dotnet/ml-net-and-model-builder-october-updates/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 に .NET のインタラクティブなノートブックを統合する拡張がリリースされた。&lt;/p&gt;
&lt;p&gt;以前より .NET Interactive Notebooks や Visual Studio Code 拡張といったものが提供されていたがその Visual Studio 向けの拡張。.NET のインタラクティブなノートブックは ML.NET の Model Builder や .ipynb ファイルを直接作成することで使用可能。&lt;/p&gt;
&lt;p&gt;その他 ML.NET のアップデートや、以前フィードバックされていた ML.NET に関する懸念点に関する進捗についてにも触れている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=MLNET.notebook"&gt;Notebook Editor - Visual Studio Marketplace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-1.4.0-beta.4-mysql-netmysqlconnector"&gt;Release 1.4.0-beta.4 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/1.4.0-beta.4"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/1.4.0-beta.4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector の 1.4.0-beta.4 がリリース。&lt;/p&gt;
&lt;p&gt;不具合の修正のほか &lt;code&gt;ConnectionIdlePingTime&lt;/code&gt; オプションの削除など。&lt;/p&gt;
&lt;h3 id="net-6-rc2-update-for-macos-and-windows-arm64-issue-21686-dotnetsdk"&gt;.NET 6 RC2 Update for macOS and Windows Arm64 · Issue #21686 · dotnet/sdk&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/sdk/issues/21686"&gt;https://github.com/dotnet/sdk/issues/21686&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 RC2 で macOS と Windows の ARM64 対応がほぼ完了したとのこと。&lt;/p&gt;
&lt;p&gt;それにより .NET 6 RC2 以降での macOS と Windows の ARM64 対応は次のような状況となる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x64 版と ARM64 版のインストールの共存可能になる&lt;/li&gt;
&lt;li&gt;.NET 6 RC2 以降では一度すべての .NET をアンインストールする必要がある&lt;/li&gt;
&lt;li&gt;コマンドラインから ARM64 のコマンドを使用して x64 の開発が行える (逆も)&lt;/li&gt;
&lt;li&gt;パフォーマンス上の理由からも ARM64 SDK を使用してほしい&lt;/li&gt;
&lt;li&gt;SDK は .NET 6+ の ARM64 のみをサポートする&lt;/li&gt;
&lt;li&gt;ランタイムはすべてのバージョンの ARM64, x64 共にサポートする&lt;/li&gt;
&lt;li&gt;.NET 6 RC2 で x64 エミュレーションも含む ARM64 の .NET 6 体験を提供&lt;/li&gt;
&lt;li&gt;.NET Core 3.1, .NET 5 のランタイムも .NET 6 に合わせて更新予定 (ただし時期は未定)&lt;/li&gt;
&lt;li&gt;RC2 ナイトリービルドは現在壊れているため数週間後にリリースされる RC2 を待ってほしい&lt;/li&gt;
&lt;li&gt;.NET 5 SDK for Windows ARM64 は .NET 6 RTM 後に早期終了予定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他にもインストールした際にネイティブアーキテクチャーの dotnet コマンドにのみ PATH が通ることやアーキテクチャーを指定する &lt;code&gt;-a&lt;/code&gt; 引数が追加されたこと、Windows 11 においては特別な対応がないことなどにも触れている。&lt;/p&gt;
&lt;h3 id="release-release-v2.40.0-grpcgrpc-dotnet"&gt;Release Release v2.40.0 · grpc/grpc-dotnet&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/grpc/grpc-dotnet/releases/tag/v2.40.0"&gt;https://github.com/grpc/grpc-dotnet/releases/tag/v2.40.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Grpc.Net の v2.40.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;幾つかの不具合対応、ターゲットフレームワークとして .NET 6 が追加、ProtoBuf のバージョンアップなど。&lt;/p&gt;
&lt;h3 id="release-diagnostics-release-v5.0.248003-dotnetdiagnostics"&gt;Release Diagnostics Release - v5.0.248003 · dotnet/diagnostics&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/diagnostics/releases/tag/v5.0.248003"&gt;https://github.com/dotnet/diagnostics/releases/tag/v5.0.248003&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Diagnostics ツールの v5.0.248003 がリリースされた。&lt;/p&gt;
&lt;p&gt;各種バグの修正や Microsoft.Diagnostics.NetCore.Client (Diagnostics API) の非同期対応など。&lt;/p&gt;
&lt;p&gt;その他 .NET 6 で PDB を配置していなかった場合にメタデータトークンのオフセットがスタックトレースに出力できるようになったが、それから元のコードの位置を割り出す &lt;code&gt;symbolicate&lt;/code&gt; コマンドが &lt;code&gt;dotnet-stack&lt;/code&gt; に実装された。なおメタデータトークンのオフセットを出力する機能はデフォルトで無効化されているため、&lt;code&gt;Switch.System.Diagnostics.StackTrace.ShowILOffsets&lt;/code&gt; AppContext スイッチを有効にする必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/diagnostics/pull/2436"&gt;Add new 'symbolicate' commands to dotnet-stack by JongHeonChoi · Pull Request #2436 · dotnet/diagnostics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/44013"&gt;Add IL Offset and Method Token to stacktrace by wscho77 · Pull Request #44013 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/56780"&gt;disable token info in traces. by mangod9 · Pull Request #56780 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="net-core-api-in-azure-container-instances-secured-with-https-using-caddy2"&gt;.NET Core API in Azure Container Instances, secured with HTTPS using Caddy2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/kedzior_io/net-core-api-in-azure-container-instances-secured-with-https-using-caddy2-32jm"&gt;https://dev.to/kedzior_io/net-core-api-in-azure-container-instances-secured-with-https-using-caddy2-32jm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core API アプリケーションを Azure Container Instances 上で動かすときに Caddy2 をセットで使用することで簡単に HTTPS 対応をするという記事。&lt;/p&gt;
&lt;h3 id="asp.net-mvc5.net-frameworkmicrosoft.extensions.dependencyinjection-qiita"&gt;ASP.NET MVC5(.NET Framework)にMicrosoft.Extensions.DependencyInjectionを導入する - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/jun1s/items/cedf917a9de98830e97c"&gt;https://qiita.com/jun1s/items/cedf917a9de98830e97c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Framework の ASP.NET MVC 5 に Microsoft.Extensions.DependencyInjection を導入する方法についての記事。&lt;/p&gt;
&lt;p&gt;DependencyResolver に登録するためのアダプターとなるライブラリーを使用することで、ASP.NET MVC のコントローラーでもコンストラクターインジェクションやメソッドパラメーターインジェクションを行えるようにする。&lt;/p&gt;
&lt;h3 id="differences-between-hashtable-vs-dictonary-vs-concurrentdictionary-vs-immutabledictionary"&gt;Differences between Hashtable vs Dictonary vs ConcurrentDictionary vs ImmutableDictionary&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/differences-between-hashtable-vs-dictonary-vs-concurrentdictionary-vs-immutabledictionary"&gt;https://www.hanselman.com/blog/differences-between-hashtable-vs-dictonary-vs-concurrentdictionary-vs-immutabledictionary&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET はマップ/辞書を実現するクラスが &lt;code&gt;Hashtable&lt;/code&gt; と &lt;code&gt;Dictonary&lt;/code&gt; と &lt;code&gt;ConcurrentDictionary&lt;/code&gt; と &lt;code&gt;ImmutableDictionary&lt;/code&gt; 4種類あるがどう違うのかの記事。David Fowler 氏のツイートから。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Hashtable&lt;/code&gt; は .NET 1.x 世代の弱い型付けであり、box 化も発生するため .NET 2.0 以降では &lt;code&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; に変わられた。&lt;/p&gt;
&lt;p&gt;スレッドセーフティーを考慮する必要があるのであれば &lt;code&gt;System.Collections.Concurrent&lt;/code&gt; か&lt;code&gt;System.Collections.Immutable&lt;/code&gt; を使用することになる。それを踏まえてそれぞれ次のような違いがある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentDictionary&lt;/code&gt;: 並列実行時の読み取りは良好、作成は重い、更新速度は遅い&lt;/li&gt;
&lt;li&gt;ロックあり &lt;code&gt;Dictionary&lt;/code&gt;: 読み取りは遅く、作成は軽量、更新速度はまあまあ&lt;/li&gt;
&lt;li&gt;イミュータブルな &lt;code&gt;Dictionary&lt;/code&gt;: 読み取りは最速、作成は軽量、 更新速度はとても遅い
&lt;ul&gt;
&lt;li&gt;イミュータブルな Dictionary とは &lt;code&gt;var newDict = new Dictionary&amp;lt;T,K&amp;gt;(oldDict); newDict.Add(key, value);&lt;/code&gt; のようにコピーする方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;: 読み取りは良好、作成は Dictionary と同様に軽量、更新は重く、ジェネリクスもない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ImmutableDictionary&lt;/code&gt;: 読み取りは遅め、ロックは不要ただし更新時にアロケーションが多い&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/davidfowl/status/1444467842418548737?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;.NET has 4 built-in dictionary/map types:&lt;br&gt;- Hashtable&lt;br&gt;- Dictionary&lt;br&gt;- ConcurrentDictionary&lt;br&gt;- ImmutableDictionary&lt;br&gt;&lt;br&gt;There’s no guidance on when to use what, mostly individual documentation on each implementation.&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧🇺🇸💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1444467842418548737?ref_src=twsrc%5Etfw"&gt;October 3, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2017/march/net-framework-immutable-collections"&gt;.NET Framework - 不変コレクション | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/standard/collections/thread-safe/when-to-use-a-thread-safe-collection"&gt;スレッドセーフなコレクションを使用する状況 | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/premier-developer/read-only-frozen-and-immutable-collections/"&gt;Read only, frozen, and immutable collections - Developer Support&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spaphp-conference-japan-2021"&gt;SPAセキュリティ入門～PHP Conference Japan 2021&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.slideshare.net/ockeghem/phpconf2021spasecurity"&gt;https://www.slideshare.net/ockeghem/phpconf2021spasecurity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Single Page Application におけるフロントエンドを中心としたサーバーとのセキュリティーについてのスライド。&lt;/p&gt;
&lt;p&gt;JWT をセッションに使うことについてや、Cookie/localStorage について、CORS などについて落とし穴と共に解説している。&lt;/p&gt;
&lt;h3 id="net-annotated-monthly-october-2021-the.net-tools-blog"&gt;.NET Annotated Monthly | October 2021 | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/05/net-annotated-monthly-october-2021/"&gt;https://blog.jetbrains.com/dotnet/2021/10/05/net-annotated-monthly-october-2021/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JetBrains による9月から10月にあった .NET 関連の記事やトピックスのまとめの記事。&lt;/p&gt;
&lt;h3 id="c"&gt;(C#) 構造体で列挙型ライクな定義を作る - ネコのために鐘は鳴る&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ikorin2.hatenablog.jp/entry/2021/10/04/043527"&gt;https://ikorin2.hatenablog.jp/entry/2021/10/04/043527&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enum (列挙型) の代わりとなるような値/タイプセーフな定義型を作る方法について。&lt;/p&gt;
&lt;p&gt;struct として定義することのメリットとして定義外の値を防ぐことやメソッドの定義ができること、内部値の変更が可能といった点があり、デメリットとして定数とできない、デフォルト引数値として扱えない、switch での分岐ができない、Enum の機能を使えないといった点をあげている。&lt;/p&gt;
&lt;h3 id="a-look-at-the-upcoming-improvements-to-linq-in.net-6"&gt;A look at the upcoming improvements to LINQ in .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://raygun.com/blog/linq-net-6-improvements/"&gt;https://raygun.com/blog/linq-net-6-improvements/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で強化される LINQ に関する紹介の記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Chunk&lt;/code&gt; の追加, &lt;code&gt;ElementAt&lt;/code&gt; の Index 対応、&lt;code&gt;Take&lt;/code&gt; の Range 対応、&lt;code&gt;Zip&lt;/code&gt; の3パラメータ版 の追加、&lt;code&gt;FirstOrDefault&lt;/code&gt; などでのデフォルト値、&lt;code&gt;TryGetNonEnumeratedCount&lt;/code&gt; ヘルパーメソッド、&lt;code&gt;MaxBy&lt;/code&gt;/&lt;code&gt;MinBy&lt;/code&gt; の追加について。&lt;/p&gt;
&lt;h3 id="hacktoberfest-for.net-developers-c-edition"&gt;Hacktoberfest for .NET Developers (C# Edition)&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/arafattehsin/hacktoberfest-for-net-developers-c-edition-3bha"&gt;https://dev.to/arafattehsin/hacktoberfest-for-net-developers-c-edition-3bha&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hacktoberfest に参加しコントリビュートを受け付けている .NET (C# 向け) のプロジェクトの紹介記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hacktoberfest.digitalocean.com/"&gt;Hacktoberfest 2021&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="odata-with.net-6"&gt;OData with .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/berviantoleo/odata-with-net-6-5e1p"&gt;https://dev.to/berviantoleo/odata-with-net-6-5e1p&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 と PostgreSQL で OData 対応の API アプリケーションを用意するステップバイステップ。&lt;/p&gt;
&lt;h3 id="aws-dotnet-lambda-functions-powered-by-aws-graviton2-processors-c-cdk"&gt;AWS DotNet Lambda Functions powered by AWS Graviton2 Processors (C#, CDK)&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://collin-smith.medium.com/aws-dotnet-lambda-functions-powered-by-aws-graviton2-processors-c-cdk-c7efc160324d"&gt;https://collin-smith.medium.com/aws-dotnet-lambda-functions-powered-by-aws-graviton2-processors-c-cdk-c7efc160324d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET による AWS Lambda Functions を AWS Graviton 2 (ARM) インスタンスの上で動かす記事。&lt;/p&gt;
&lt;p&gt;CDK を使用して Lambda Functions のプロジェクトを作成し、デプロイする方法について触れている。&lt;/p&gt;
&lt;h3 id="building-a-middleware-pipeline-with-webapplication-exploring.net-core-6-part-4"&gt;Building a middleware pipeline with WebApplication: Exploring .NET Core 6 - Part 4&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-4-building-a-middleware-pipeline-with-webapplication/"&gt;https://andrewlock.net/exploring-dotnet-6-part-4-building-a-middleware-pipeline-with-webapplication/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core の WebApplication が開始、終了するまでの流れと HTTP ミドルウェアパイプラインの構築についての解説記事。&lt;/p&gt;
&lt;p&gt;WebApplication を介してミドルウェアを登録した場合にどのようにしてパイプラインを構築されるかに触れている。&lt;/p&gt;
&lt;h3 id="switchbotwindowscble-qiita"&gt;SwitchBot温湿度計の値を、WindowsでC#でBLEで直接受信する - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/ShTair/items/3fef7dad7668bd4e8fa5"&gt;https://qiita.com/ShTair/items/3fef7dad7668bd4e8fa5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SwitchBot の温湿度計を .NET 5 と Windows 10 の Bluetooth LE の API を使用して読み取ることについての記事。&lt;/p&gt;
&lt;h3 id="graphql-mutation-errors-union-erros-with-interface-aka-6a-with-hotchocolate-graphql-server"&gt;GraphQL mutation errors (union erros with interface aka 6a) with Hotchocolate GraphQL Server&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/damikun/graphql-mutation-union-erros-6a-with-hotchocolate-graphql-server-1b70"&gt;https://dev.to/damikun/graphql-mutation-union-erros-6a-with-hotchocolate-graphql-server-1b70&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hotchocolate GraphQL サーバーでミューテーションのエラーを Union と Interface の組み合わせ (Stage 6a) で返す方法についての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://productionreadygraphql.com/2020-08-01-guide-to-graphql-errors"&gt;A Guide to GraphQL Errors | Production Ready GraphQL | Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="blazor-webassembly-svg-drag-and-drop"&gt;Blazor Webassembly SVG Drag And Drop&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/codex/blazor-webassembly-svg-drag-and-drop-e680769ac682"&gt;https://medium.com/codex/blazor-webassembly-svg-drag-and-drop-e680769ac682&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly で SVG の要素をドラッグアンドドロップできるようにする実装についての記事。&lt;/p&gt;
&lt;h3 id="exploring-c-10-save-space-with-file-scoped-namespaces"&gt;Exploring C# 10: Save Space with File-Scoped Namespaces&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/daveabrock/exploring-c-10-save-space-with-file-scoped-namespaces-1jfi"&gt;https://dev.to/daveabrock/exploring-c-10-save-space-with-file-scoped-namespaces-1jfi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 10 で使用できるファイルスコープの &lt;code&gt;namespace&lt;/code&gt; についての記事。&lt;/p&gt;
&lt;p&gt;従来の指定方法と混ぜることができない点や、複数回指定できないなどの注意点にも触れている。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="adamralphminver-minimalistic-versioning-using-git-tags"&gt;adamralph/minver: 🏷 Minimalistic versioning using Git tags.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/adamralph/minver"&gt;https://github.com/adamralph/minver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Git のタグをベースにアプリケーション/ライブラリーのバージョニングを簡単に行うためのライブラリー/コマンドラインツール。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/karuakun/items/26a2496fb5874980637b"&gt;MinVerでお手軽にライブラリのバージョン番号の管理を行う - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="marusykgrok.net.net-implementation-of-the-grok"&gt;Marusyk/grok.net: .net implementation of the grok 📝&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/Marusyk/grok.net"&gt;https://github.com/Marusyk/grok.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ログ解析などで使用される Grok パターンを解析する .NET 向けライブラリー。&lt;/p&gt;
&lt;h3 id="devloopedwebsocketchannel-high-performance-system.threading.channels-api-adapter-for-system.net.websockets"&gt;devlooped/WebSocketChannel: High-performance System.Threading.Channels API adapter for System.Net.WebSockets&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/devlooped/WebSocketChannel"&gt;https://github.com/devlooped/WebSocketChannel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WebSockets をバックにした &lt;code&gt;System.Threading.Channels.Channel&amp;lt;T&amp;gt;&lt;/code&gt; の実装。&lt;/p&gt;
&lt;p&gt;サーバー/クライアントで Channel インターフェースを通して &lt;code&gt;ReadOnlyMemory&amp;lt;byte&amp;gt;&lt;/code&gt; を WebSocket の上で送受信できる。&lt;/p&gt;
&lt;!-- https://twitter.com/kzu/status/1445083345520562181?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Continuing my exploration of &lt;a href="https://twitter.com/Azure?ref_src=twsrc%5Etfw"&gt;&amp;#64;Azure&lt;/a&gt; Web PubSub, I think the &lt;a href="https://twitter.com/dotnet?ref_src=twsrc%5Etfw"&gt;&amp;#64;dotnet&lt;/a&gt; System.Threading.Channels API is actually even nicer than raw WebSockets and pipelines. So I created another small thingy you might find useful too 🤟 &lt;a href="https://t.co/r4xn3cc7Kx"&gt;https://t.co/r4xn3cc7Kx&lt;/a&gt;&lt;/p&gt;&amp;mdash; Daniel Cazzulino (&amp;#64;kzu) &lt;a href="https://twitter.com/kzu/status/1445083345520562181?ref_src=twsrc%5Etfw"&gt;October 4, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="sonarlint-code-quality-and-code-security-starts-in-your-ide"&gt;SonarLint | Code Quality and Code Security starts in your IDE&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.sonarlint.org/"&gt;https://www.sonarlint.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ソースコードに問題がある点などを検出する Visual Studio に対応した IDE 拡張。&lt;/p&gt;
&lt;h3 id="damikuntrouble-training-fullstack-app-workshop-with-distributed-tracing-and-monitoring.this-shows-the-configuration-from-react-frontend-to.netcore-backend"&gt;damikun/trouble-training: FullStack app workshop with distributed tracing and monitoring. This shows the configuration from React frontend to .NetCore backend.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/damikun/trouble-training"&gt;https://github.com/damikun/trouble-training&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET を使用したフルスタックなアプリケーションのワークショップ。&lt;/p&gt;
&lt;p&gt;サーバーアプリケーションのみではなく、フロントエンドやロギング基盤や分散トレーシングなども含む比較的複雑な構成を持つのが特徴。&lt;/p&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="wcf-asp.net-core-grpc-wcf-grpc"&gt;WCF 開発者向け ASP.NET Core gRPC - WCF 開発者向け gRPC&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/architecture/grpc-for-wcf-developers/"&gt;https://docs.microsoft.com/ja-jp/dotnet/architecture/grpc-for-wcf-developers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WCF 開発者に向けた ASP.NET Core の gRPC のガイドとなるのドキュメント。&lt;/p&gt;
&lt;p&gt;WCF 開発者以外でも参考となるような gRPC の特性、ProtoBuf について、gRPC のセキュリティーや運用環境での考慮点についても書かれている。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/tannergooding/status/1443758012980555794?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;&lt;a href="https://t.co/cLdGgzD0bx"&gt;https://t.co/cLdGgzD0bx&lt;/a&gt; gives an example of a Sum method before/after these APIs.&lt;br&gt;&lt;br&gt;There are likely a few APIs we can expose to help simplify/remove the Unsafe logic (while also avoiding pinning) &amp;amp; to handle trailing elements as well, but its something I’m still looking into.&lt;/p&gt;&amp;mdash; Tanner Gooding (&amp;#64;tannergooding) &lt;a href="https://twitter.com/tannergooding/status/1443758012980555794?ref_src=twsrc%5Etfw"&gt;October 1, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;クロスプラットフォームなハードウェア Intrinstic なコードを書けるようにするサポートに取り掛かり始めたという話。&lt;/p&gt;
&lt;!-- https://twitter.com/akarpov89/status/1443957219834400773?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I&amp;#39;ve just found really cool and unexpected application of C# 10 interpolated string handlers: scanf-like parsing!&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://t.co/3VYDEunYuB"&gt;pic.twitter.com/3VYDEunYuB&lt;/a&gt;&lt;/p&gt;&amp;mdash; Andrew Karpov (&amp;#64;akarpov89) &lt;a href="https://twitter.com/akarpov89/status/1443957219834400773?ref_src=twsrc%5Etfw"&gt;October 1, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;C# 10 の String interpolation のハンドラーを使用することで、&lt;code&gt;scanf&lt;/code&gt; のようなフォーマットを元に入力をパースして変数にセットするという黒魔術的なテクニック。(実際のコードも危険な雰囲気が漂っている)&lt;/p&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1445465823938682881?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;A thread about LINQ improvements in .NET 6 🧵&lt;br&gt;&lt;br&gt;As always, retweets are appreciated 😌&lt;a href="https://twitter.com/hashtag/dotnet6?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet6&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/linq?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#linq&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1445465823938682881?ref_src=twsrc%5Etfw"&gt;October 5, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 の LINQ に関する強化点についてのスレッド。新規追加されたメソッドなどを .NET 5 と比較しながら紹介。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="add-pattern-variables.md-by-alrz-pull-request-4592-dotnetcsharplang"&gt;Add pattern-variables.md by alrz · Pull Request #4592 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/pull/4592"&gt;https://github.com/dotnet/csharplang/pull/4592&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if (e is (int i, 0))
  Use(i);
else if (e is (0, int j))
  Use(j);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;の代わりに&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if (e is (int i, 0) or (0, int i))
  Use(i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のような is パターンマッチ中で同じ型であれば共用できるようにするという提案。&lt;/p&gt;
&lt;h3 id="optimize-datetime.equals-by-egorbo-pull-request-59857-dotnetruntime"&gt;Optimize DateTime.Equals by EgorBo · Pull Request #59857 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59857"&gt;https://github.com/dotnet/runtime/pull/59857&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DateTime.Equals&lt;/code&gt; は Ticks を比較していたが、Ticks は内部表現 (ulong) の上位2ビットをマスクしたものを返すプロパティなので、直接内部表現同士で XOR を取って上位2bitを無視するようにすることでより速くなるというPR。&lt;/p&gt;
&lt;h3 id="guarded-devirt-multiple-type-checks-by-egorbo-pull-request-59604-dotnetruntime"&gt;Guarded Devirt: multiple type checks by EgorBo · Pull Request #59604 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59604"&gt;https://github.com/dotnet/runtime/pull/59604&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gurded Devirtualization が「最もよく使われるもの」と「それ以外」だったのを「よく使われるいくつか」と「それ以外」といった形にするというPR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-10-01: NuGet.org, Windows Community Toolkit v7.1, Npgsql 6.0.0 RC1, ReSharper 2021.3 &amp; Rider 2021.3 EAP</title>
			<link>/2021/10/01/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/10/01/updates</guid>
			<pubDate>Fri, 01 Oct 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/nuget/introducing-the-new-nuget-org-package-details-page/"&gt;NuGet.org のパッケージ詳細ページのデザインが新しくなりました&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;いろいろな情報がすべて表示されていましたが、ターゲットフレームワークのバッジなど今後も追加したい要素があるということでタブベースのデザインに変更したそうです。README を表示する機能は少し前から実装されていましたが、より目立つ形になっているのでこれからリリースするパッケージには含めるのがよさそうです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blogs.windows.com/windowsdeveloper/2021/09/23/announcing-windows-community-toolkit-v7-1/"&gt;Windows Community Toolkit v7.1&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;Microsoft ID 認証に関する刷新やドロップシャドウを実現するためのスタイルの追加などが行われています。ドロップシャドウに関しては Microsoft Store アプリで使用されているそうです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/npgsql/npgsql/releases/tag/v6.0.0-rc.1"&gt;Npgsql v6.0.0 RC1&lt;/a&gt;がリリースされました。&lt;/p&gt;
&lt;p&gt;複数ホストへの接続や Raw SQL、バッチ実行といったものがサポートされ、.NET 6 に向けた対応も含まれています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/09/28/resharper-2021-3-eap/"&gt;ReSharper 2021.3 EAP&lt;/a&gt; と &lt;a href="https://blog.jetbrains.com/dotnet/2021/09/28/rider-2021-3-eap/"&gt;Rider 2021.3 EAP&lt;/a&gt; がリリースされました (EAP == プレビュー的なリリース)。&lt;/p&gt;
&lt;p&gt;それぞれ C# 10 への対応や ReSharper は Visual Studio 2022 の対応、Rider は .NET 6 SDK への対応をはじめ、プロジェクトプロパティーや Debug の UI の変更などが含まれています。また Apple Silicon 向けのビルドも別途リリースされています。&lt;/p&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="introducing-the-new-nuget.org-package-details-page-the-nuget-blog"&gt;Introducing the New NuGet.org Package Details Page - The NuGet Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/nuget/introducing-the-new-nuget-org-package-details-page/"&gt;https://devblogs.microsoft.com/nuget/introducing-the-new-nuget-org-package-details-page/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NuGet.org のパッケージ詳細ページが4年ぶりに新デザインに刷新された。&lt;/p&gt;
&lt;p&gt;デザイン変更した理由として、2021年の5月からパッケージに含まれる README を表示する機能が追加され、今後&lt;a href="https://github.com/NuGet/Home/pull/10900"&gt;ターゲットフレームワークに関する情報を表示する予定もある&lt;/a&gt;が、要素を追加するためのスペースが不足してきたためタブデザインで逃がすことにした。&lt;/p&gt;
&lt;p&gt;記事では実際にリリースされるまでのフィードバックについても触れている。&lt;/p&gt;
&lt;h3 id="announcing-windows-community-toolkit-v7.1-windows-developer-blog"&gt;Announcing Windows Community Toolkit v7.1 - Windows Developer Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blogs.windows.com/windowsdeveloper/2021/09/23/announcing-windows-community-toolkit-v7-1/"&gt;https://blogs.windows.com/windowsdeveloper/2021/09/23/announcing-windows-community-toolkit-v7-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows Community Toolkit v7.1 がリリース。&lt;/p&gt;
&lt;p&gt;Microsoft ID 認証のヘルパーとプロバイダーの刷新と Microsoft Graph API と OneDrive をサポートするヘルパー API とコントロールの提供。&lt;/p&gt;
&lt;p&gt;コントロールにドロップシャドウをつけるためのスタイルを追加。既存の DropShadowPanel コントロールに代わるものでコントロールをラップせずスタイルとして適用する。実装には Win2D ベースの　&lt;code&gt;AttachedCardShadow&lt;/code&gt; と UWP の Composition ベースの &lt;code&gt;AttachedDropShadow&lt;/code&gt; がある。&lt;code&gt;AttachedCardShadow&lt;/code&gt; は Win2D への依存があり矩形のみのサポートとなるがパフォーマンスもよい、&lt;code&gt;AttachedDropShadow&lt;/code&gt; は Composition を使用するため UWP アプリでのみ使用できるがマスク画像やテキストなどもサポートするといった違いがある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/communitytoolkit/helpers/attachedshadows"&gt;Attached Shadows - Windows Community Toolkit | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RichSuggestBox コントロールの追加。&lt;code&gt;&amp;#64;&lt;/code&gt; によるユーザー名のサジェストのようなものを提供できる RichEditBox。&lt;/p&gt;
&lt;p&gt;MVVM Source Generator がプレビューで追加され、&lt;code&gt;ObservableProperty&lt;/code&gt;, &lt;code&gt;ICommand&lt;/code&gt;, &lt;code&gt;INotifyPropertyChanged&lt;/code&gt; 属性などでマークすることでボイラープレートコードの生成が行えるようになった。&lt;/p&gt;
&lt;p&gt;そのほか Toolkit Labs という形で実験的なパッケージが提供されるようになった。今後 Lab リポジトリなどが用意される予定。すでに物体認識のような Intelligent APIs や視線入力の Gaze Controls といったものがある。&lt;/p&gt;
&lt;h3 id="release-v6.0.0-rc.1-npgsqlnpgsql"&gt;Release v6.0.0-rc.1 · npgsql/npgsql&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/npgsql/npgsql/releases/tag/v6.0.0-rc.1"&gt;https://github.com/npgsql/npgsql/releases/tag/v6.0.0-rc.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Npgsql v6.0.0 RC1 がリリース。&lt;/p&gt;
&lt;p&gt;6.0 ではロードバランシングなどを含むマルチホスト接続、タイムスタンプの改善、Raw SQL の発行や .NET 6 で導入されたバッチ API を使用したバッチ実行、.NET 6 の DateOnly/TimeOnly のサポートの追加など。&lt;/p&gt;
&lt;p&gt;Raw SQL の発行は Npgsql がクエリーを書き換えずパラメータを送信するようにする仕組みで、以前の名前付きパラメータに代わるもの。名前付きパラメータはクエリーをパースし、書き換えてから PostgreSQL に送信していたが Raw SQL ではクエリーはそのまま PostgreSQL へ送信するため安全性が高まり、クエリーも効果的になるとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.npgsql.org/doc/release-notes/6.0.html"&gt;Npgsql 6.0 Release Notes | Npgsql Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.roji.org/parameters-batching-and-sql-rewriting"&gt;Query parameters, batching and SQL rewriting - Shay Rojansky’s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/28633"&gt;New System.Data.Common batching API · Issue #28633 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-v1.41.0-grpcgrpc"&gt;Release v1.41.0 · grpc/grpc&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/grpc/grpc/releases/tag/v1.41.0"&gt;https://github.com/grpc/grpc/releases/tag/v1.41.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gRPC v1.41.0 がリリース。&lt;/p&gt;
&lt;p&gt;C# (C-core) に関連する変更としては非常に稀なケースでレスポンスのメタデータが破損してしまう問題の修正、non-ASCII な環境でネイティブライブラリーへのパスに non-ASCII な文字が含まれる場合に読み込み失敗してしまうことがある問題の修正など。&lt;/p&gt;
&lt;h3 id="rider-2021.3-early-access-program-has-launched-the.net-tools-blog"&gt;Rider 2021.3 Early Access Program Has Launched! | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/09/28/rider-2021-3-eap/"&gt;https://blog.jetbrains.com/dotnet/2021/09/28/rider-2021-3-eap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rider 2021.3 EAP (早期アクセス) がリリース。&lt;/p&gt;
&lt;p&gt;ソリューションにまつわる問題点を一覧できる Problems View が追加。コードに関連する問題以外も NuGet や .NET SDK といったツールや環境に関する問題を列挙してその場で対応できる。&lt;/p&gt;
&lt;p&gt;.NET 6 SDK に対応、Debug タブの UI 変更、デバッガーの改善により UWP のサポートと Windows 上での Windows Docker コンテナー内でのデバッグが可能となった。&lt;/p&gt;
&lt;p&gt;file-scoped namespace のような C# 10 に関連した言語の対応やコード解析、SQL 言語 Injection のサポート改善、Unity 向けのコードで XML ドキュメントを &lt;code&gt;Tooltip&lt;/code&gt; 属性に変換する機能、Apple Silicon 向けビルドの提供、プロジェクトとソリューションのプロパティーウィンドウの改修など。&lt;/p&gt;
&lt;h3 id="resharper-2021.3-starts-early-access-program-the.net-tools-blog"&gt;ReSharper 2021.3 Starts Early Access Program! | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/09/28/resharper-2021-3-eap/"&gt;https://blog.jetbrains.com/dotnet/2021/09/28/resharper-2021-3-eap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReSharper 2021.3 EAP (早期アクセス) がリリース。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 Preview がサポートされ、file-scoped namespace のような C# 10 に関連した言語の対応やコード解析の改善が行われた。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Namespace.Type.Member&lt;/code&gt; といった FQN 形式でコピーする Copy FQN が Copy Code Reference に変わり、GitHub へのリンクやカスタム URL パターンを定義してコピーできるようになった。&lt;/p&gt;
&lt;p&gt;.NET 5 SDK から対応した AnalyzerConfig ファイルに ReSherper も対応した。パラメータやフィールドを &lt;code&gt;LanguageInjection&lt;/code&gt; 属性でマークすることで Language Injection を有効化できるようになった。&lt;/p&gt;
&lt;p&gt;dotMemory は Windows では ETW イベントを使用してアロケーションをサンプリングできるように。正確さは以前の手法には劣るがパフォーマンスペナルティがない、集めるために有効にする必要がない、すでに動作中のアプリケーションでも集められるといった利点がある。&lt;/p&gt;
&lt;h3 id="avoiding-memory-leaks-in-visual-studio-editor-extensions-visual-studio-blog"&gt;Avoiding Memory Leaks in Visual Studio Editor Extensions - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/avoiding-memory-leaks-in-visual-studio-editor-extensions/"&gt;https://devblogs.microsoft.com/visualstudio/avoiding-memory-leaks-in-visual-studio-editor-extensions/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio のインプロセス拡張でのメモリーリークを防ぐための VS IDE チームが持つベストプラクティスの紹介。&lt;/p&gt;
&lt;p&gt;MEF パーツによるメモリーリークでは &lt;code&gt;ITextView&lt;/code&gt; のような重いオブジェクトの参照を一つ持つだけでも関連するソリューションまで参照が広がり、多くのリークが発生する例が挙げられている。対策として MEF パーツには強参照/ステートを持たない、持つ場合にはスコープのライフタイムに限定できるようにする、どうしても参照を持つ場合には WeakReference を使う。&lt;/p&gt;
&lt;p&gt;C# のイベントリスナーのリークの例も同様に、イベントを購読する際に重いオブジェクトへの参照が間接的に発生してしまう。対策として &lt;code&gt;ITextView.Close&lt;/code&gt; のような不要になるタイミングでの購読解除や IDisposable を IDE が呼び出すものであれば Dispose を実装する。&lt;/p&gt;
&lt;p&gt;他にも静的なステートや WPF のデータバインディングの例が挙げられている。また、それらメモリーリークを解析するためのツールについても触れている。&lt;/p&gt;
&lt;h3 id="announcing-azure-credits-for-open-source-projects-microsoft-open-source-blog"&gt;Announcing: Azure credits for open source projects - Microsoft Open Source Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://cloudblogs.microsoft.com/opensource/2021/09/28/announcing-azure-credits-for-open-source-projects/"&gt;https://cloudblogs.microsoft.com/opensource/2021/09/28/announcing-azure-credits-for-open-source-projects/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Open Source Initiative (OSI) に承認されたライセンスで提供しているオープンソースプロジェクトに対して Azure のクレジットを提供するプログラムを開始。現時点で FreeBSD や Haskell といったプロジェクトが参加している。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://opensource.microsoft.com/azure-credits"&gt;Azure Credits for Open Source Projects | Microsoft Open Source&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vs-code-in-the-browser-for-everyone"&gt;VS Code in the browser for everyone&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.gitpod.io/blog/openvscode-server-launch"&gt;https://www.gitpod.io/blog/openvscode-server-launch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitpod が Gitpod や GitHub Codespaces のように Visual Studio Code をリモートサーバーで稼働させる OpenVSCode Server を公開。&lt;/p&gt;
&lt;p&gt;Visual Studio Code 本体には GitHub Workspaces のような形で実行するためのパーツが欠けているため、フォークして最小の変更で埋めることでサーバーで動作できるようにしている。Docker をはじめ AWS や GCP といったクラウド環境での起動方法も用意されている。&lt;/p&gt;
&lt;p&gt;Gitpod との直接の違いは環境も含めすべてマネージドであって欲しいか、あるいはリモートで Visual Studio Code が動作しそこにアクセスしたいかにあるとしている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/gitpod-io/openvscode-server/"&gt;gitpod-io/openvscode-server: Run upstream VS Code on a remote machine with access through a modern web browser from any device, anywhere.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="how-to-deploy-a-dockerized-web-app-to-heroku-using-the-github-actions"&gt;How to Deploy a Dockerized Web App to Heroku using the GitHub Actions&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://enlear.academy/how-to-deploy-a-dockerized-web-app-to-heroku-using-the-github-actions-f16c00b19621"&gt;https://enlear.academy/how-to-deploy-a-dockerized-web-app-to-heroku-using-the-github-actions-f16c00b19621&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker イメージにした .NET の Web アプリケーションを GitHub Actions から Heroku にデプロイして動かす方法についての記事。&lt;/p&gt;
&lt;h3 id="implicit-usings-in.net-6"&gt;Implicit Usings in .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/implicit-usings-in-net-6"&gt;https://www.hanselman.com/blog/implicit-usings-in-net-6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Implicit using について簡単に紹介する記事。&lt;/p&gt;
&lt;h3 id="c-10.0"&gt;C# 10.0 の補間文字列の改善&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ufcpp.net/study/csharp/start/improvedinterpolatedstring/"&gt;https://ufcpp.net/study/csharp/start/improvedinterpolatedstring/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 10 での補完文字列 (String interpolation) の改善についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InterpolatedStringHandler&lt;/code&gt; 属性を持つハンドラー型を使用した文字列フォーマットの展開例や実装例、オーバーロード解決や .NET 6 で String クラスなどに追加された API についても触れている。&lt;/p&gt;
&lt;h3 id="wpfdicicd1-qiita"&gt;自作のWPFアプリを後から自動テスト・DI・CI/CD対応にしてみる。その1 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/soi/items/273e60b2a48d57ae762f"&gt;https://qiita.com/soi/items/273e60b2a48d57ae762f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WPF アプリケーションの自動テストと DI の導入、CI 対応についての記事。&lt;/p&gt;
&lt;p&gt;テストは xUnit を、DI は Microsoft.Extensions.DependencyInjection を採用。CI は GitHub Actions でカバレッジの取得や Release の作成まで行う。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/soi/items/a19304220c71bdfbc171"&gt;自作のWPFアプリを後から自動テスト・DI・CI/CD対応にしてみる。その2 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiita.com/soi/items/e5f01c66c0a303a74c30"&gt;自作のWPFアプリを後から自動テスト・DI・CI/CD対応にしてみる。その3 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-6-blazor"&gt;.NET 6 の Blazor のコンポーネントでクエリ パラメーターを使うのが簡単になりました&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/okazuki/articles/blazor-wasm-rc1-queryparam"&gt;https://zenn.dev/okazuki/articles/blazor-wasm-rc1-queryparam&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 Preview 7 以降の Blazor に追加されたクエリーストリングをパラメーターとして受け取る &lt;code&gt;SupplyParameterFromQuery&lt;/code&gt; についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NavigationManager&lt;/code&gt; クラスに追加されたアプリケーション側から URL やそのパラメーターを変更するためのメソッドについても触れている。&lt;/p&gt;
&lt;h3 id="c-web-url-blazor-webassembly.net-5-jsakamoto"&gt;C# での Web アプリ開発で、要求 URL 中のクエリ文字列をいい感じに読み取る - 特に Blazor WebAssembly (とりわけ .NET 5 以前) での注意点 : &amp;#64;jsakamoto&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devadjust.exblog.jp/28884450/"&gt;https://devadjust.exblog.jp/28884450/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Web アプリケーションでのクエリーストリングのパースについての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HttpUtility.ParseQueryString&lt;/code&gt; と &lt;code&gt;UriExtensions.ParseQueryString&lt;/code&gt; の違いについてや Blazor (.NET 5) での注意など。&lt;/p&gt;
&lt;h3 id="net-6-blazor-head"&gt;.NET 6 の Blazor で追加された &amp;lt;head&amp;gt; タグの中を変更する機能の紹介&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/okazuki/articles/blazor-dotnet6-headoutlet"&gt;https://zenn.dev/okazuki/articles/blazor-dotnet6-headoutlet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Blazor で導入された &lt;code&gt;head&lt;/code&gt; 要素に関するコンポーネントについての紹介記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt; 要素にページごとに要素を追加できる &lt;code&gt;HeadContent&lt;/code&gt; コンポーネントと、ページのタイトルを設定できる &lt;code&gt;PageTitle&lt;/code&gt; コンポーネントが追加された。&lt;/p&gt;
&lt;h3 id="entity-framework-biweekly-status-updates-2021-issue-23884-dotnetefcore"&gt;Entity Framework Biweekly Status Updates (2021) · Issue #23884 · dotnet/efcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/issues/23884#issuecomment-926052851"&gt;https://github.com/dotnet/efcore/issues/23884#issuecomment-926052851&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2週ごとの Entity Framework のステータス更新レポートの9月23日分。EF Core 6.0 のステータスが Feature complete となったことなど。&lt;/p&gt;
&lt;h3 id="how-to-retry-failing-dotnet-tests-in-github-actions"&gt;How to retry failing dotnet tests in GitHub Actions&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.cazzulino.com/dotnet-test-retry.html"&gt;https://www.cazzulino.com/dotnet-test-retry.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ネットワークが絡むテストなどで失敗しやすい (flaky) テストを GitHub Actions で実行する際にリトライする方法についての記事。&lt;/p&gt;
&lt;p&gt;bash シェルスクリプトで失敗をカウントしつつ、失敗したテスト名を抽出して部分的にリトライする (&lt;code&gt;--filter&lt;/code&gt;) といった手法。&lt;/p&gt;
&lt;h3 id="exploring-the-code-behind-webapplicationbuilder-exploring.net-core-6-part-3"&gt;Exploring the code behind WebApplicationBuilder: Exploring .NET Core 6 - Part 3&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-3-exploring-the-code-behind-webapplicationbuilder/"&gt;https://andrewlock.net/exploring-dotnet-6-part-3-exploring-the-code-behind-webapplicationbuilder/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の WebApplicationBuilder についての詳細に解説している記事。&lt;/p&gt;
&lt;p&gt;WebApplicationBuilder は内部に何を抱えていて、どうアプリケーションが構築されるのかといった点に触れている。&lt;/p&gt;
&lt;h3 id="creating-roslyn-api-based-static-analyzer-for-c"&gt;Creating Roslyn API-based static analyzer for C#&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/pvs-studio/creating-roslyn-api-based-static-analyzer-for-c-c0d7c27489f9"&gt;https://medium.com/pvs-studio/creating-roslyn-api-based-static-analyzer-for-c-c0d7c27489f9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roslyn ベースでの静的コードアナライザーの作成についての記事。&lt;/p&gt;
&lt;p&gt;スタンドアローンで実行可能なコードアナライザーの作成方法から、シンタックスツリーの歩き方についてや Semantic Model とシンボルといったものの扱い方などにも触れている。&lt;/p&gt;
&lt;h3 id="efcore-qiita"&gt;EFCore でレコードに対するトリガーを実行する - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/karuakun/items/2db2e7ff8411e3a455cd"&gt;https://qiita.com/karuakun/items/2db2e7ff8411e3a455cd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework を使用してレコードに対する操作を行う際に C# のコードレベルで追加の処理を行う方法 (更新日のようなカラムを更新するとか) についての記事。&lt;/p&gt;
&lt;p&gt;DataContext の拡張、インターセプターによるフック、EntityFrameworkCore.Triggered を使用した方法が紹介されている。&lt;/p&gt;
&lt;h3 id="azure-active-directorys-gateway-is-on.net-core-3.1.net-blog"&gt;Azure Active Directory's gateway is on .NET Core 3.1! - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/azure-active-directorys-gateway-service-is-on-net-core-3-1/"&gt;https://devblogs.microsoft.com/dotnet/azure-active-directorys-gateway-service-is-on-net-core-3-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Azure Active Directory のゲートウェイサーバーを .NET Framework から .NET Core 3.1 に移行したという2021年1月の記事。&lt;/p&gt;
&lt;p&gt;.NET Core に移行を完遂するにあたって Web サーバーの検討、アプリケーションの移行、段階的なロールアウトを行ったことについて書かれている。
また .NET Framework の ASP.NET との挙動の違いといった移行の中であった学びにも触れている。&lt;/p&gt;
&lt;h3 id="custom-deployment-layout-for-blazor-webassembly-apps-asp.net-blog"&gt;Custom deployment layout for Blazor WebAssembly apps - ASP.NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/aspnet/custom-deployment-layout-for-blazor-webassembly-apps/"&gt;https://devblogs.microsoft.com/aspnet/custom-deployment-layout-for-blazor-webassembly-apps/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Blazor WebAssembly ではカスタムしたアプリケーション配布パッケージを作成する仕組みを NuGet パッケージとして提供できるようになったことについての記事。&lt;/p&gt;
&lt;p&gt;カスタム配置は例として DLL のダウンロードがブロックされている場合にひとまとめにした形でダウンロードするといった利用方法が考えられ、マルチパートなファイルにまとめるというサンプルコード/パッケージが公開されている。&lt;/p&gt;
&lt;p&gt;JavaScript の Blazor の初期化プロセスに介入する部分と MSBuild タスクによってファイルをパブリッシュする部分の拡張ポイントが増えたことで実現可能となったとのこと。&lt;/p&gt;
&lt;h3 id="wpf-window-direct3d12"&gt;WPF の Window 上に Direct3D12 でレンダリングする&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/tan_y/articles/25cc05576ef11a"&gt;https://zenn.dev/tan_y/articles/25cc05576ef11a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 の WPF アプリケーションのウィンドウ上に Direct3D12 でレンダリングした結果を表示する方法についての記事。&lt;/p&gt;
&lt;p&gt;WindowsFormsHost を使用したウィンドウにレンダリングする方法、D3DImage を使用した WPF を介してレンダリングする方法がそれぞれの長所/短所と共に紹介されている。&lt;/p&gt;
&lt;h3 id="the-code-worked-differently-when-the-moon-was-full"&gt;The code worked differently when the moon was full&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/the-code-worked-differently-when-the-moon-was-full"&gt;https://www.hanselman.com/blog/the-code-worked-differently-when-the-moon-was-full&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3-4週間おきにスレッドプールのスレッド数がコア数またはコア数+20を行ったり来たりする謎のバグについての記事。&lt;/p&gt;
&lt;p&gt;これは Windows 95 で有名な 49.7 日問題と似て &lt;code&gt;PortableThreadPool&lt;/code&gt; の &lt;code&gt;ShouldAdjustMaxWorkersActive&lt;/code&gt; メソッドの中で &lt;code&gt;Environment.TickCount&lt;/code&gt; による値を使用していたため。PortableThreadPool ではヒルクライム アルゴリズムを用いてスレッド数を調整する仕組みとなっているがこれが適切に呼び出されない周期が発生していた。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int priorTime = Volatile.Read(ref _separated.priorCompletedWorkRequestsTime);
int requiredInterval = _separated.nextCompletedWorkRequestsTime - priorTime;
// currentTimeMs が Environment.TickCount の値。Environment.TickCount は 24.9 日で負に変わる。
// priorCompletedWorkRequestsTime と nextCompletedWorkRequestsTime は起動時には 0 となっている
// この時 Environment.TickCount が負を返すと elapsedInterval は負になる
int elapsedInterval = currentTimeMs - priorTime;
if (elapsedInterval &amp;gt;= requiredInterval)
{
    // ヒルクライムが実行される == スレッドの数が調整される
    // priorCompletedWorkRequestsTime と nextCompletedWorkRequestsTime も更新する
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/51935"&gt;Hysteresis effect on threadpool hill-climbing · Issue #51935 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="using-the-model-builder-and-automl-for-creating-lead-decision-and-lead-scoring-model-in-microsoft-ml.net"&gt;Using the Model Builder and AutoML for Creating Lead Decision and Lead Scoring Model in Microsoft ML.NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;cekikjmiodrag/utilizing-the-model-builder-and-automl-for-creating-lead-decision-and-lead-scoring-model-in-19888f12d529"&gt;https://medium.com/&amp;#64;cekikjmiodrag/utilizing-the-model-builder-and-automl-for-creating-lead-decision-and-lead-scoring-model-in-19888f12d529&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Model Builder と AutoML を使用してリードスコアリングモデルを ML.NET で使用するステップバイステップの記事。&lt;/p&gt;
&lt;h3 id="a.net-object-from-allocation-to-collection"&gt;A .NET Object from allocation to collection&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/Maoni0/mem-doc/blob/master/presentation/ObjectJourney.pptx"&gt;https://github.com/Maoni0/mem-doc/blob/master/presentation/ObjectJourney.pptx&lt;/a&gt; (&lt;a href="https://view.officeapps.live.com/op/view.aspx?src=https%3A%2F%2Fraw.githubusercontent.com%2FMaoni0%2Fmem-doc%2Fmaster%2Fpresentation%2FObjectJourney.pptx&amp;amp;wdOrigin=BROWSELINK"&gt;PowerPoint Online で開く&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;オブジェクトのインスタンスを生成した際のアロケーションで OS やハードウェア上でのメモリーから始まり GC されるまでを解説したスライド。&lt;/p&gt;
&lt;!-- https://twitter.com/maoni0/status/1443344910476726274?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I&amp;#39;ve been so busy that I barely look at twitter these days. just published the slides from an internal talk I gave yesterday - very different from my normal GC talks as it touches a bit of all layers - the hardware (MMU), the OS (virtual memory) and the GC &lt;a href="https://t.co/fuZBgq6LGQ"&gt;https://t.co/fuZBgq6LGQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; Maoni Stephens (&amp;#64;maoni0) &lt;a href="https://twitter.com/maoni0/status/1443344910476726274?ref_src=twsrc%5Etfw"&gt;September 29, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="chillicreamhotchocolate-welcome-to-the-home-of-the-hot-chocolate-graphql-server-for.net-the-strawberry-shake-graphql-client-for.net-and-banana-cake-pop-the-awesome-monaco-based-graphql-ide"&gt;ChilliCream/hotchocolate: Welcome to the home of the Hot Chocolate GraphQL server for .NET, the Strawberry Shake GraphQL client for .NET and Banana Cake Pop the awesome Monaco based GraphQL IDE.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/ChilliCream/hotchocolate"&gt;https://github.com/ChilliCream/hotchocolate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GraphQL 2021 draft spec に対応した GraphQL サーバーとクライアントのライブラリー。Monaco ベースの GraphQL エディターも提供されている。&lt;/p&gt;
&lt;p&gt;GraphQL for .NET (graphql-dotnet) との違いはパフォーマンス、より良いパーサー、フィルターやミドルウェア、フレキシブルな code-first アプローチなどがあるとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/&amp;#64;teodor.siustis/creating-a-graphql-api-with-net5-and-hotchocolate-6dfe94626d10"&gt;Creating a GraphQL API with .NET5 and HotChocolate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ChilliCream/hotchocolate/issues/392"&gt;Justification for HotChocolate as opposed to GraphQl.Net · Issue #392 · ChilliCream/hotchocolate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="datageneratormxproject.devs.datagenerator-at-main-mxprojectdatagenerator"&gt;DataGenerator/mxProject.Devs.DataGenerator at main · mxProject/DataGenerator&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mxProject/DataGenerator/tree/main/mxProject.Devs.DataGenerator"&gt;https://github.com/mxProject/DataGenerator/tree/main/mxProject.Devs.DataGenerator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ランダムなテストデータを含むレコードを返すライブラリー。&lt;code&gt;IDataReader&lt;/code&gt; を介したデータアクセスが可能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/mxProject/items/194b2ae4c11656ae5a09"&gt;C# データレコード形式のテストデータを生成するライブラリを公開しました。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ltrzesniewskipcre-net-pcre.net-perl-compatible-regular-expressions-for.net"&gt;ltrzesniewski/pcre-net: PCRE.NET - Perl Compatible Regular Expressions for .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/ltrzesniewski/pcre-net"&gt;https://github.com/ltrzesniewski/pcre-net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PCRE (Perl 互換正規表現) ライブラリーの .NET 向けのラッパーとなるライブラリー。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.Text.RegularExpressions.Regex&lt;/code&gt; と似たインターフェースを提供している。&lt;/p&gt;
&lt;h3 id="nsubstitutensubstitute-a-friendly-substitute-for.net-mocking-libraries"&gt;nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/nsubstitute/NSubstitute"&gt;https://github.com/nsubstitute/NSubstitute&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使いやすさを重視したモックインスタンス生成用ライブラリー。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/arahori/items/8bcb0f770a0bfb5f7e54"&gt;NSubstitute を使った処理の置き換え - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="roubachofsharpnado.materialframe-a-modern-xamarin.forms-frame-component-supporting-blur-acrylic-dark-mode.implemented-with-realtimeblurview-on-android-custom-blurview-and-uivisualeffectview-on-ios"&gt;roubachof/Sharpnado.MaterialFrame: A modern Xamarin.Forms Frame component supporting blur, acrylic, dark mode. Implemented with RealtimeBlurView on Android (custom blurview) and UIVisualEffectView on iOS.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/roubachof/Sharpnado.MaterialFrame"&gt;https://github.com/roubachof/Sharpnado.MaterialFrame&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xamarin.Forms 向けのクロスプラットフォームなブラー/アクリルエフェクトを実現するコンポーネントのライブラリー。&lt;/p&gt;
&lt;h3 id="jamesmhcoravel-near-zero-config.net-core-micro-framework-that-makes-advanced-application-features-like-task-scheduling-caching-queuing-event-broadcasting-and-more-a-breeze"&gt;jamesmh/coravel: Near-zero config .NET Core micro-framework that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze!&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/jamesmh/coravel"&gt;https://github.com/jamesmh/coravel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;設定がほとんど不要なタスクスケジューラーサービスを提供するライブラリー。&lt;/p&gt;
&lt;p&gt;キャッシュやキューイング、メール送信といった機能も持っている。ダッシュボードなどを提供する有償版もある。&lt;/p&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="programming-idioms"&gt;Programming Idioms&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.programming-idioms.org/"&gt;https://www.programming-idioms.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;様々なプログラミング言語によるパターン別の実装例を載せているサイト。(例: &lt;a href="https://www.programming-idioms.org/idiom/41/reverse-a-string#impl5098"&gt;C# で文字列を逆順にするコード&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id="apply-rounded-corners-in-desktop-apps-windows-apps-microsoft-docs"&gt;Apply rounded corners in desktop apps - Windows apps | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/apps/desktop/modernize/apply-rounded-corners"&gt;https://docs.microsoft.com/en-us/windows/apps/desktop/modernize/apply-rounded-corners&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows 11 の角丸ウィンドウに対するアプリケーションで行う対応についてのドキュメント。&lt;/p&gt;
&lt;p&gt;デフォルトでは角丸となるが角丸とならないケース、意図的に角丸を抑制したいケースでの C#/WPF と C++ による対応方法についてなど。&lt;/p&gt;
&lt;h3 id="unoconf-2021"&gt;2021 - UnoConf 2021&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://unoconf.com/"&gt;https://unoconf.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Uno Platform のカンファレンスが2021年11月30日の正午 (日本時間 2021年12月1日午前2時) にオンラインで開催。&lt;/p&gt;
&lt;h3 id="aspnetcorediagnosticscenariosasyncguidance.md-at-master-davidfowlaspnetcorediagnosticscenarios-github"&gt;AspNetCoreDiagnosticScenarios/AsyncGuidance.md at master · davidfowl/AspNetCoreDiagnosticScenarios · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md"&gt;https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Devid Fowler 氏による非同期プログラミングのベストプラクティスガイド。&lt;/p&gt;
&lt;h3 id="hello-world-c-microsoft-docs"&gt;Hello World - C# の概要に関する対話型チュートリアル | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/tour-of-csharp/tutorials/hello-world"&gt;https://docs.microsoft.com/ja-jp/dotnet/csharp/tour-of-csharp/tutorials/hello-world&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Web ブラウザー上で Hello World を出力するような C# コードを記述、実行できるインタラクティブなチュートリアル。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1442194858425274369?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;All my tweets about C# 10 features in one thread. 🧵&lt;br&gt;&lt;br&gt;Retweets are appreciated 😊&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1442194858425274369?ref_src=twsrc%5Etfw"&gt;September 26, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;続くスレッドで C# 10 の数々の新機能を1枚画像で簡単に紹介。Constant string interpolation, Extended property patterns, File scoped namespaces, Global using などなど。&lt;/p&gt;
&lt;!-- https://twitter.com/timheuer/status/1440818713582702598?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;File-scoped namespaces by default...via &lt;a href="https://twitter.com/hashtag/editorconfig?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#editorconfig&lt;/a&gt; &lt;br&gt;&lt;br&gt;csharp_style_namespace_declarations = file_scoped&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/VisualStudio?ref_src=twsrc%5Etfw"&gt;&amp;#64;VisualStudio&lt;/a&gt; &lt;a href="https://t.co/GifWb0M9WM"&gt;pic.twitter.com/GifWb0M9WM&lt;/a&gt;&lt;/p&gt;&amp;mdash; Tim Heuer (&amp;#64;timheuer) &lt;a href="https://twitter.com/timheuer/status/1440818713582702598?ref_src=twsrc%5Etfw"&gt;September 22, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;EditorConfig ファイルに &lt;code&gt;csharp_style_namespace_declarations = file_scoped&lt;/code&gt; と設定しておくことで新しいクラスファイルを作成する際などで File-scoped namespace を使用したものを生成できるというテクニック。&lt;/p&gt;
&lt;!-- https://twitter.com/vs_debugger/status/1441092957277351951?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;The project menu in the solution explorer under the Debug now has the “Start Without Debugging” option. This would be helpful when you are working with a multi-project solution.  &lt;a href="https://twitter.com/hashtag/vstip?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#vstip&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/vsdebuggertip?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#vsdebuggertip&lt;/a&gt; &lt;a href="https://t.co/SPUXbQmqgN"&gt;pic.twitter.com/SPUXbQmqgN&lt;/a&gt;&lt;/p&gt;&amp;mdash; Visual Studio Debugger (&amp;#64;VS_Debugger) &lt;a href="https://twitter.com/VS_Debugger/status/1441092957277351951?ref_src=twsrc%5Etfw"&gt;September 23, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;ソリューションエクスプローラーのプロジェクトのコンテキストメニューに &amp;quot;Start Without Debugging&amp;quot; (デバッグなしで実行) が追加された。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1441576163734818817?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;The biggest problem with async await is the “colored functions” problem brilliantly explained by this article &lt;a href="https://t.co/hz5753G8DM"&gt;https://t.co/hz5753G8DM&lt;/a&gt;. It’s a never ending problem because everything can’t be async and          it’s viral. It’s not a new problem though, it’s always been this way.&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧🇺🇸💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1441576163734818817?ref_src=twsrc%5Etfw"&gt;September 25, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt; メソッドは &lt;code&gt;async&lt;/code&gt; メソッドからしか呼べない話。&lt;/p&gt;
&lt;p&gt;Go や Java の Project Loom では viral (感染的) ではないアプローチを取っているが、.NET では難しい理由がある。例えば一つは相互運用のためのパフォーマンスにかかわる問題で .NET には高機能な FFI (P/Invoke) があるがグリーンスレッドからのコンテキストスイッチで問題となる。&lt;/p&gt;
&lt;p&gt;他に .NET にはメモリーをピンするという仕組みがあることもあげている。これはユーザーモードスレッドを実装したとするとスタックを動的に広げる必要がある際にコピーが必要となるが、メモリーのアドレスが変わってしまうためできない。代わりに linked list で持つなどが考えられるがパフォーマンスに問題が出る、また async state machine は .NET におけるある種の linked list としてもみえるといった話など。&lt;/p&gt;
&lt;!-- https://twitter.com/stevensanderson/status/1443288841964638220?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Using the new Native Dependencies feature for Blazor WebAssembly on .NET 6, I just managed to call Rust from C#, both running in the browser! It&amp;#39;s a direct p/invoke call - no JS interop. Now, what can we do with this new power? &lt;a href="https://t.co/VkyBekDWFR"&gt;pic.twitter.com/VkyBekDWFR&lt;/a&gt;&lt;/p&gt;&amp;mdash; Steve Sanderson (&amp;#64;stevensanderson) &lt;a href="https://twitter.com/stevensanderson/status/1443288841964638220?ref_src=twsrc%5Etfw"&gt;September 29, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 の Blazor WebAssemlby では Native Dependencies という機能により、C# から外部の WASM を JavaScript 相互運用なしで P/Invoke できるので Rust などを直接呼び出せるという話。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="obsolete-thumbtacked-assemblyname-properties-by-i3arnon-pull-request-59522-dotnetruntime"&gt;Obsolete thumbtacked AssemblyName properties by i3arnon · Pull Request #59522 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59522"&gt;https://github.com/dotnet/runtime/pull/59522&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AssemblyName&lt;/code&gt; の &lt;code&gt;ProcessorArchitecture&lt;/code&gt;, &lt;code&gt;HashAlgorithm&lt;/code&gt;, &lt;code&gt;VersionCompatibility&lt;/code&gt; は.NET Core では意味をなさないため非推奨としてマークするという PR。&lt;/p&gt;
&lt;h3 id="querystringenumerable-api-by-stevesandersonms-pull-request-33910-dotnetaspnetcore-github"&gt;QueryStringEnumerable API by SteveSandersonMS · Pull Request #33910 · dotnet/aspnetcore · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/pull/33910"&gt;https://github.com/dotnet/aspnetcore/pull/33910&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリーストリングを Span ベースで取り扱って列挙する内部 API の実装 PR。&lt;code&gt;QueryStringEnumerable&lt;/code&gt; 自体は公開されていない。&lt;/p&gt;
&lt;h3 id="port-dllimportgenerator-to-dotnetruntime-by-jkoritzinsky-pull-request-59363-dotnetruntime"&gt;Port DllImportGenerator to dotnet/runtime by jkoritzinsky · Pull Request #59363 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59363"&gt;https://github.com/dotnet/runtime/pull/59363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P/Invoke のコードを Source Generator でコード生成をする DllImportGenerator を別リポジトリから dotnet/runtime に引っ越してきた PR。&lt;/p&gt;
&lt;p&gt;コードを生成することでマーシャリングの調査やカスタマイズが行いやすくなることが目的のよう。&lt;/p&gt;
&lt;h3 id="c-string-formatting-with-negative-numbers-are-not-working-as-expected-in-net5.0-issue-59570-dotnetruntime"&gt;C# string formatting with negative numbers are not working as expected in net5.0 · Issue #59570 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59570"&gt;https://github.com/dotnet/runtime/issues/59570&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;double&lt;/code&gt; の &lt;code&gt;-0.0&lt;/code&gt; を &lt;code&gt;ToString(&amp;quot;f1&amp;quot;)&lt;/code&gt; すると .NET Framework と .NET 5 で結果が違うという Issue。&lt;/p&gt;
&lt;p&gt;これは .NET Core 3.0 で小数点のパースとフォーマットに手が入った影響で正しく符号がつくようになったことによるもの。もし以前と同様の結果を得たい場合は &lt;code&gt;ToString(&amp;quot;0.0;-0.0;0.0&amp;quot;)&lt;/code&gt; という3セクションフォーマットで指定する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/floating-point-parsing-and-formatting-improvements-in-net-core-3-0/"&gt;Floating-Point Parsing and Formatting improvements in .NET Core 3.0 - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="augment-regex-extensibility-point-for-better-perf-and-span-based-matching-issue-59629-dotnetruntime"&gt;Augment Regex extensibility point for better perf and span-based matching · Issue #59629 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59629"&gt;https://github.com/dotnet/runtime/issues/59629&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Regex にパフォーマンスのためと、&lt;code&gt;Span&lt;/code&gt; ベースマッチングのために拡張ポイントを用意したいという話。&lt;/p&gt;
&lt;h3 id="stacktrace-explorer-implementation-by-ryzngard-pull-request-56315-dotnetroslyn"&gt;StackTrace Explorer Implementation by ryzngard · Pull Request #56315 · dotnet/roslyn&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/56315"&gt;https://github.com/dotnet/roslyn/pull/56315&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;テキストとしてクリップボードにコピーしたスタックトレースからジャンプしたりできる Stack Trace Explorer の実装 PR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.jetbrains.com/help/resharper/Reference__Windows__Stack_Trace_Explorer.html"&gt;Stack Trace Explorer window | ReSharper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="api-proposal-bool-hashset.updatet-value-out-t-actual-issue-59468-dotnetruntime"&gt;[API Proposal]: bool HashSet.Update(T value, out T actual) · Issue #59468 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59468#issuecomment-925609693"&gt;https://github.com/dotnet/runtime/issues/59468#issuecomment-925609693&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;元は &lt;code&gt;HashSet&amp;lt;T&amp;gt;&lt;/code&gt; に Update が欲しいという話で、やりたいこと的には &lt;code&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; だが &lt;code&gt;Dictionary&lt;/code&gt; には &lt;code&gt;Update&lt;/code&gt; がないという話になったところ、&lt;code&gt;GetOrSet&lt;/code&gt; に相当するメソッドであれば .NET 6 RC1 で &lt;code&gt;CollectionsMarshal.GetValueRefOrAddDefault&lt;/code&gt; というものが増えたのでそれで実装できるというテクニック。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.collectionsmarshal.getvaluereforadddefault?view=net-6.0"&gt;CollectionsMarshal.GetValueRefOrAddDefault&amp;lt;TKey,TValue&amp;gt;(Dictionary&amp;lt;TKey,TValue&amp;gt;, TKey, Boolean) メソッド (System.Runtime.InteropServices) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="api-proposal-file.writeallbytes-overload-for-span-and-readonlyspan-issue-59770-dotnetruntime"&gt;[API Proposal]: File.WriteAllBytes overload for Span and ReadOnlySpan · Issue #59770 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59770"&gt;https://github.com/dotnet/runtime/issues/59770&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File.WriteAllBytes&lt;/code&gt; に &lt;code&gt;Span&lt;/code&gt;/&lt;code&gt;ReadOnlySpan&lt;/code&gt; を受けるオーバーロードが欲しいという提案。&lt;/p&gt;
&lt;p&gt;既に過去に似た提案があり、&lt;code&gt;File.Write*&lt;/code&gt;/&lt;code&gt;File.Append*&lt;/code&gt; は特に高レベルな API なのに対して &lt;code&gt;Span&lt;/code&gt; のような低レベルな API を組み合わせるのが不自然、これらのメソッドはパフォーマンスよりも利便性に特化していること、初心者向けのコア API を汚染することといった点でデザイン上なしという形で close されている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/35054"&gt;API proposal: Add File class method overloads for ReadOnlyMemory and ReadOnlySpan · Issue #35054 · dotnet/runtime · GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="monowasm-add-beginnings-of-support-for-wasi.by-vargaz-pull-request-59752-dotnetruntime-github"&gt;[mono][wasm] Add beginnings of support for WASI. by vargaz · Pull Request #59752 · dotnet/runtime · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59752"&gt;https://github.com/dotnet/runtime/pull/59752&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mono WASM で WASI (WebAssemlby System Interface) のサポートを始めるという PR。&lt;/p&gt;
&lt;h3 id="add-initial-codespaces-support-for-dotnetruntime-by-eerhardt-pull-request-59723-dotnetruntime"&gt;Add initial codespaces support for dotnet/runtime by eerhardt · Pull Request #59723 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59723"&gt;https://github.com/dotnet/runtime/pull/59723&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dotnet/runtime リポジトリを GitHub Codespaces 上でも編集/ビルドできるようにするための初期サポートの PR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-09-24: paint.net 4.3, Visual Studio 2022 for Mac Preview 1.4, Package Validation, SourceGear Bridge preview</title>
			<link>/2021/09/24/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/09/24/updates</guid>
			<pubDate>Fri, 24 Sep 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://blog.getpaint.net/2021/09/22/paint-net-4-3-is-now-available/"&gt;Paint.NET 4.3&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;.NET 5 への移行が完了し、パフォーマンスの向上や ARM64 対応などが行われました。5か月かかったそうですが比較的歴史のある有名な .NET アプリケーションが .NET Framework から .NET 5 へ移行しきった例という点はとても大きいのではないでしょうか。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#17.0.0-priv-pre.1.4"&gt;Visual Studio 2022 for Mac version 17.0 Private Preview 1.4&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;.NET 6 RC1 に対応し、Roslyn も Visual Studio 2022 (Windows) と同じバージョンに揃うことで C# 10 のコードも問題なく取り扱えるようになっています。また Xamarin プロジェクトの対応など一旦欠けていた機能が徐々に実装されてきているという状況です。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/package-validation/"&gt;Package Validation&lt;/a&gt; についての記事が .NET Blog に出ています。&lt;/p&gt;
&lt;p&gt;これはパッケージビルド時に API の互換性をチェックする仕組みを提供するものです。マルチターゲットなライブラリでのバイナリ互換性やパッケージバージョン間の互換性保てるよう、安全に開発するのに役立つと考えられます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ericsink.com/entries/sourcegear_bridge.html"&gt;SourceGear Bridge preview: Swift with .NET in Xcode&lt;/a&gt; という Swift と .NET を合体して動かして Xcode でコードを書けるようにする野心的なパッケージ/SDKのプレビューが公開されています。&lt;/p&gt;
&lt;p&gt;Eric Sink さんは元々 LLVM-to-CIL で Swift を .NET で動かすといったこともやっているのですが、今回のこれは .NET のアプリケーションが Swift のネイティブライブラリーをホストし、.NET のコードを呼び出せるバインディングを用意することで Swift から .NET のコードを呼び出すという仕組みのようです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ericsink.com/entries/swift_alpaca.html"&gt;Alpaca Preview: Native Swift with ASP.NET Core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ericsink.com/entries/dotnet_swift.html"&gt;Llama Preview: Swift on .NET&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="paint.net-4.3-is-now-available-paint.net-blog"&gt;paint.net 4.3 is now available – paint.net blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.getpaint.net/2021/09/22/paint-net-4-3-is-now-available/"&gt;https://blog.getpaint.net/2021/09/22/paint-net-4-3-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Paint.NET 4.3 がリリース。&lt;/p&gt;
&lt;p&gt;5か月に及ぶ .NET Framework 4.8 から .NET 5 へ移行作業が完了。これによりパフォーマンスの向上、Self-contained 配布による .NET Framework インストールの不要化、ReadyToRun によるインストール時の NGEN ステップの不要化、ARM64 対応などの恩恵を受けられるようになった。&lt;/p&gt;
&lt;p&gt;今後 .NET 6 がリリースされ次第そちらへの移行していくとのこと。&lt;/p&gt;
&lt;h3 id="visual-studio-2022-for-mac-v17.0-preview-release-notes-microsoft-docs"&gt;Visual Studio 2022 for Mac v17.0 Preview - Release Notes | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#17.0.0-priv-pre.1.4"&gt;https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#17.0.0-priv-pre.1.4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac version 17.0 Private Preview 1.4 がリリース。(プライベートプレビュー中のため利用するには登録が必要)&lt;/p&gt;
&lt;p&gt;.NET 6 RC1 の対応、Roslyn 4.0 への更新と C# 10 対応、Xamarin プロジェクトの対応など。その他プロジェクト設定などの IDE の未実装な部分の実装や改善。&lt;/p&gt;
&lt;h3 id="package-validation.net-blog"&gt;Package Validation - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/package-validation/"&gt;https://devblogs.microsoft.com/dotnet/package-validation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の SDK で使用できるようになった Package Validation という MSBuild SDK パッケージについて。&lt;/p&gt;
&lt;p&gt;Package Validation は次のようなパッケージビルド時の API 互換性チェックの仕組みを提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;マルチターゲットでの互換性&lt;/li&gt;
&lt;li&gt;ベースライン間のパッケージの互換性&lt;/li&gt;
&lt;li&gt;ランタイム間の互換性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マルチターゲットでの互換性のチェックは例えば .NET Standard 2.0 と .NET 6 をターゲットにしたライブラリで API のバイナリ互換性が壊れてしまう例がある。記事では次のようなコードが例としてあげられている。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#if NET6_0_OR_GREATER
    public void DoStringManipulation(ReadOnlySpan&amp;lt;char&amp;gt; input)
    {
        // use spans to do string operations.
    }
#else
    public void DoStringManipulation(string input)
    {
        // Do some string operations.
    }
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;元々 .NET Standard 2.0 で参照されていた場合 &lt;code&gt;DoStringManipulation(string input)&lt;/code&gt; を使用できるが、.NET 6 以降の環境に移った場合は &lt;code&gt;DoStringManipulation(ReadOnlySpan&amp;lt;char&amp;gt; input)&lt;/code&gt; のみが使用できる状態となるため &lt;code&gt;DoStringManipulation(string input)&lt;/code&gt; がないというエラーとなる。ソースコードレベルでの互換性はあるので再コンパイルすれば再び正しく動作するが自身のコードでない場合は難しいといったことが発生する。これは &lt;code&gt;DoStringManipulation(string input)&lt;/code&gt; が &lt;code&gt;NET6_0_OR_GREATER&lt;/code&gt; でも残っていれば問題とならない。このようなコードを検出してパッケージのビルドエラーとする。&lt;/p&gt;
&lt;p&gt;ベースライン間のパッケージの互換性チェックは指定した NuGet パッケージバージョンを API のベースラインとしてバイナリ互換性をチェックする仕組み。&lt;/p&gt;
&lt;p&gt;ランタイム間の互換性チェックは Unix や Windows のようなランタイム固有で持つ API が異なる場合、固有のランタイムをターゲットとした場合に互換性のある API があるかどうかチェックする仕組み。記事には次のようなコード例がある。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#if Unix
    public static void Open(string path, bool securityDescriptor)
    {
        // call unix specific stuff
    }
#else
    public static void Open(string path)
    {
        // call windows specific stuff
    }
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコードはランタイムが Unix をターゲットにしている場合には &lt;code&gt;Open(string path, bool securityDescriptor)&lt;/code&gt; を使用できるが、コード使用者はランタイムを限定しない場合 &lt;code&gt;Open(string path)&lt;/code&gt; を呼び出すコードを記述する。そのコードを Unix 環境下で実行した場合メソッドが存在しないエラーとなってしまう。このようなケースでは Unix 環境下において &lt;code&gt;Open(string path)&lt;/code&gt; を呼び出した場合に例外を投げるような形となるほうが望ましく、そういったケースを検出できる。&lt;/p&gt;
&lt;h3 id="sourcegear-bridge-preview-swift-with.net-in-xcode"&gt;SourceGear Bridge preview: Swift with .NET in Xcode&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ericsink.com/entries/sourcegear_bridge.html"&gt;https://ericsink.com/entries/sourcegear_bridge.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 以外の言語と .NET をブリッジして Xcode からコード編集できるようにする SourceGear Bridge がプレビュー。現時点では Swift がターゲット。&lt;/p&gt;
&lt;p&gt;SourceGear Bridge を利用すると ASP.NET Core のコードを Swift で記述するといったことが可能になる。これは .NET から Swift プログラムをバインディングと共にホストする仕組みと Swift のコードから .NET を呼び出せるようにする仕組みによって実現されている。&lt;/p&gt;
&lt;p&gt;async/await のサポートなども含めて、プロダクションレディを目指して開発を進めるとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ericsink.com/entries/swift_alpaca.html"&gt;Alpaca Preview: Native Swift with ASP.NET Core&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="introducing-collection-of-new-visual-studio-themes-visual-studio-blog"&gt;Introducing Collection of New Visual Studio Themes! - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/custom-themes/"&gt;https://devblogs.microsoft.com/visualstudio/custom-themes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 でテーマをインストールして使用できるようになったことの紹介記事。&lt;/p&gt;
&lt;p&gt;コミュニティーによるテーマ (Ayu, Dacula, ...) や Visual Studio チーム提供の Theme Pack (Light+, Monokai, ...) の紹介とテーマの切り替え方法について。また Visual Studio Code のテーマからのコンバーターがあるということにも触れている(テーマの手書きは現実的ではないのでコンバーターの利用が事実上必須と思われる)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/theme-converter-for-vs"&gt;microsoft/theme-converter-for-vs: CLI tool that allows you to convert your VS Code color theme to a VS 2022 color theme.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="http3-support-in.net-6.net-blog"&gt;HTTP/3 support in .NET 6 - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/http-3-support-in-dotnet-6/"&gt;https://devblogs.microsoft.com/dotnet/http-3-support-in-dotnet-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 での HTTP/3 のプレビューサポートについての記事。&lt;/p&gt;
&lt;p&gt;HTTP/3 がなぜ重要か、.NET 6 では QUIC の実装として何を使用しているか、.NET 6 での利用方法について。&lt;/p&gt;
&lt;p&gt;.NET での QUIC 実装は MSQuic を使用しているが、Linux では QUIC での TLS のハンドシェイク実装に必要な API が OpenSSL にないため、Akamai と協力し QuicTLS としてフォークしたものに QUIC に必要な最低限の変更を加えたものを静的リンクするようにした。&lt;/p&gt;
&lt;p&gt;.NET アプリケーションから QUIC を扱うための &lt;code&gt;System.Net.Quic&lt;/code&gt; API は .NET 7 で公開するとしている。&lt;/p&gt;
&lt;p&gt;また macOS では HTTP/3 のサポートが含まれていない。これは .NET の TLS の実装に macOS の SecureTransport を使用していることで QUIC に必要な API が足りないことによるもの。OpenSSL を使用してのサポートでは証明書管理が OS と別になるため、そのような依存は増やすことは避けたとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/msquic"&gt;microsoft/msquic: Cross-platform, C implementation of the IETF QUIC protocol.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/QuicTLS/openssl"&gt;quictls/openssl: TLS/SSL and crypto library with QUIC APIs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="xamarin.forms-5.0.0.2125-5.0.0-service-release-5-release-notes-xamarin-microsoft-docs"&gt;Xamarin.Forms 5.0.0.2125 (5.0.0 Service Release 5) Release Notes - Xamarin | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/xamarin/xamarin-forms/release-notes/5.0/5.0.0-sr5#september-17-2021---xamarinforms-5002125-500-service-release-5"&gt;https://docs.microsoft.com/en-us/xamarin/xamarin-forms/release-notes/5.0/5.0.0-sr5#september-17-2021---xamarinforms-5002125-500-service-release-5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xamarin.Forms 5.0.0 Service Release 5 がリリース。&lt;/p&gt;
&lt;p&gt;主にバグ修正。また依存している AndroidX ライブラリのバージョン引き上げも含まれる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/xamarin/Xamarin.Forms/pull/14506"&gt;Androidx bumps by PureWeen · Pull Request #14506 · xamarin/Xamarin.Forms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="microsoftxamarin-community-toolkit.net-maui-compatibility-package"&gt;MicrosoftがXamarin Community Toolkit用の.NET MAUI Compatibility Packageをリリース&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.infoq.com/jp/news/2021/09/community-toolkit-maui-compat/"&gt;https://www.infoq.com/jp/news/2021/09/community-toolkit-maui-compat/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xamarin Community Toolkit の .NET MAUI Compatibility Package についての記事。&lt;/p&gt;
&lt;h3 id="minimal-apis-in.net-6-but-where-are-the-unit-tests"&gt;Minimal APIs in .NET 6 but where are the Unit Tests?&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/minimal-apis-in-net-6-but-where-are-the-unit-tests"&gt;https://www.hanselman.com/blog/minimal-apis-in-net-6-but-where-are-the-unit-tests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core の Minimal APIs でユニットテストを書くときはどうするのかという記事。これは単純に &lt;code&gt;WebApplicationFactory&amp;lt;T&amp;gt;&lt;/code&gt; を継承したテストアプリケーションクラスを作れば従来通り呼び出しテストを書くことができる。(参考リポジトリのコードを見るとこの記事内のコードは &lt;code&gt;Todo&lt;/code&gt; をセットしていて間違っている気がする…)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/DamianEdwards/MinimalApiPlayground/blob/d9e1bcb46b964bdd8da4074f27e44567f09c60e5/tests/MinimalApiPlayground.Tests/PlaygroundApplication.cs"&gt;MinimalApiPlayground/PlaygroundApplication.cs at d9e1bcb46b964bdd8da4074f27e44567f09c60e5 · DamianEdwards/MinimalApiPlayground&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="websocket-per-message-compression-in-asp.net-core-6"&gt;WebSocket per-message compression in ASP.NET Core 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.tpeczek.com/2021/09/websocket-per-message-compression-in.html"&gt;https://www.tpeczek.com/2021/09/websocket-per-message-compression-in.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core で WebSocket のメッセージ単位の圧縮がサポートされ、それを利用する方法についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DangerousEnableCompression&lt;/code&gt; プロパティという危険そうな名前の理由についても触れている。これはサポートされていないクライアントとのネゴシエーションで失敗するからといった理由ではなく、CRIME/BREACH 攻撃が可能となってしまうセキュリティー上の理由。(実際サポートされていなければ非圧縮にフォールバックする)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.websockets.websocketcreationoptions.dangerousdeflateoptions?view=net-6.0"&gt;WebSocketCreationOptions.DangerousDeflateOptions Property (System.Net.WebSockets) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/aspnetcore/blob/v6.0.0-rc.1.21452.15/src/Http/Http.Features/src/WebSocketAcceptContext.cs#L26-L32"&gt;aspnetcore/WebSocketAcceptContext.cs at v6.0.0-rc.1.21452.15 · dotnet/aspnetcore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ms-graph-blazor-webassembly-and-azure-static-web-apps"&gt;MS Graph, Blazor WebAssembly and Azure Static Web Apps&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/azure/ms-graph-blazor-webassembly-and-azure-static-web-apps-3p1d"&gt;https://dev.to/azure/ms-graph-blazor-webassembly-and-azure-static-web-apps-3p1d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Azure Static Web Apps にホストした Blazor WebAssembly のアプリケーションから Azure Active Directory と Graph API を使用して、ユーザー認証と情報取得を行う方法についての記事。&lt;/p&gt;
&lt;h3 id="pattern-matching-examples-in-c"&gt;Pattern Matching Examples in C#&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/this-is-learning/pattern-matching-examples-in-c-3g74"&gt;https://dev.to/this-is-learning/pattern-matching-examples-in-c-3g74&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;様々なパターンマッチの書き方の紹介の記事。&lt;/p&gt;
&lt;p&gt;C# 10 で導入された Extended property patterns (ネストしたプロパティアクセスを &lt;code&gt;.&lt;/code&gt; で行える) についても。&lt;/p&gt;
&lt;h3 id="raspberrypi-3b.net5l"&gt;RaspberryPi 3B+と.NET5で電子工作したい(準備/Lチカ)&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/tera1707/articles/c458d65fee4cdc"&gt;https://zenn.dev/tera1707/articles/c458d65fee4cdc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Raspberry Pi 3B+ 上で .NET 5 アプリケーションからハードウェアをコントロールする導入記事。&lt;/p&gt;
&lt;p&gt;Raspberry Pi への OS インストールから &lt;code&gt;System.Device.Gpio&lt;/code&gt; を使用してLチカ(LED を光らせる)するプログラムを実行するまでが書かれている。また続く記事で &lt;code&gt;System.Device.Pwm&lt;/code&gt; を使用したハードウェア PWM についても触れている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zenn.dev/tera1707/articles/f33178395a14d8"&gt;RaspberryPi 3B+と.NET5で電子工作(ハードウェアPWM)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="comparing-webapplicationbuilder-to-the-generic-host-exploring.net-core-6-part-2"&gt;Comparing WebApplicationBuilder to the Generic Host: Exploring .NET Core 6 - Part 2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-2-comparing-webapplicationbuilder-to-the-generic-host/"&gt;https://andrewlock.net/exploring-dotnet-6-part-2-comparing-webapplicationbuilder-to-the-generic-host/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core で従来の Generic Host を使用する形から、&lt;code&gt;WebApplicationBuilder&lt;/code&gt; を使用する形へと変わったことについての記事。&lt;/p&gt;
&lt;p&gt;ASP.NET Core 2.x の WebHost と .NET 5 の Generic Host からの流れについても触れている。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WebApplicationBuilder&lt;/code&gt; は &lt;code&gt;Configuration&lt;/code&gt;, &lt;code&gt;Services&lt;/code&gt;, &lt;code&gt;Logging&lt;/code&gt; そして &lt;code&gt;IHostBuilder&lt;/code&gt; と &lt;code&gt;IWebHostBuilder&lt;/code&gt; の設定を提供する、パイプライン以外を構築するためのビルダークラスとなった。またビルダーの &lt;code&gt;Build&lt;/code&gt; で生成されるインスタンスである &lt;code&gt;WebApplication&lt;/code&gt; はミドルウェアパイプラインを構築するためのもので、&lt;code&gt;IHost&lt;/code&gt;, &lt;code&gt;IApplicaitonBuilder&lt;/code&gt;, &lt;code&gt;IEndpointRouteBuilder&lt;/code&gt; を実装しているため、Routing や Endpoint の Use が不要となり簡潔な形となった、といった話。&lt;/p&gt;
&lt;h3 id="unityasmrefasmdefinternalassembly-definition-reference-files-qiita"&gt;【Unity】asmref（asmdefではない）を使うとinternalアクセスできて便利【Assembly Definition Reference Files】 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/su10/items/7773715c8e43058e533c"&gt;https://qiita.com/su10/items/7773715c8e43058e533c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Unity 2019.2.0 で追加された Assembly Definition Reference (.asmref) についての記事。&lt;/p&gt;
&lt;p&gt;Assembly Definition Reference は Assembly Definition のディレクトリにソースコードを差し込めるようにするという仕組み。記事では利用用途として「スクリプトの配置」「既存のアセットやパッケージの拡張」「Unity のパッケージの internal へのアクセス」といった例が挙げられている。&lt;/p&gt;
&lt;h3 id="entity-framework-core-6-compiled-models"&gt;Entity Framework Core 6 の Compiled Models を試した - しばやん雑記&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.shibayan.jp/entry/20210921/1632210374"&gt;https://blog.shibayan.jp/entry/20210921/1632210374&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 6 で実装された Compiled Models についての記事。&lt;/p&gt;
&lt;p&gt;Compiled Models はあらかじめ dotnet-ef ツールで構築済み Model の生成を構築を行ったコードを生成しておくことでスタートアップパフォーマンスを向上する機能。記事ではコード生成と参照方法のほか、Lazy Loading に非対応なこと、GitHub Actions でコード生成を行う例などについて触れている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-6-0-preview-5-compiled-models/"&gt;Announcing Entity Framework Core 6.0 Preview 5: Compiled Models - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ちなみに .NET Blog によると Source Generator として実装されなかったのは Visual Studio 内でコンテキストをビルド/実行することになり、Visual Studio そのものの安定性が損なわれてしまう可能性があったからとのこと。&lt;/p&gt;
&lt;h3 id="net-6-blazor-aka-errorboundary"&gt;.NET 6 の Blazor で改善されたエラー処理を使ってみる aka ErrorBoundary&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/okazuki/articles/blazor-net6-errorboundary"&gt;https://zenn.dev/okazuki/articles/blazor-net6-errorboundary&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Blazor で導入されたエラーハンドリングのためのコンポーネント &lt;code&gt;ErrorBoundary&lt;/code&gt; についての記事。&lt;/p&gt;
&lt;p&gt;今まではコンポーネントが例外をスローした場合、アプリケーションのグローバルでキャッチする形になっていたが &lt;code&gt;ErrorBoundary&lt;/code&gt; コンポーネントを使うことで例外を局所化してメッセージを出すといったことができるようになる。記事ではエラーが発生した後、復旧する方法についても触れられている。&lt;/p&gt;
&lt;h3 id="getting-started-with-roslyn-code-analysis"&gt;Getting started with Roslyn code analysis&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/timur_kh/getting-started-with-roslyn-code-analysis-1aki"&gt;https://dev.to/timur_kh/getting-started-with-roslyn-code-analysis-1aki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roslyn でソリューションを開いてコードを解析するまでの導入についての簡単な記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MSBuildLocator&lt;/code&gt; と &lt;code&gt;MSBuildWorkspace&lt;/code&gt; を使用してソリューションを開き、&lt;code&gt;CSharpSyntaxWalker&lt;/code&gt; でシンタックスツリーをトラバースする方法についてなど。&lt;/p&gt;
&lt;h3 id="async-processing-of-long-running-tasks-in-asp.net-core"&gt;Async processing of long-running tasks in ASP.NET Core&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.elmah.io/async-processing-of-long-running-tasks-in-asp-net-core/"&gt;https://blog.elmah.io/async-processing-of-long-running-tasks-in-asp-net-core/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcurrentQueue&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;IHostedService&lt;/code&gt; を使用して ASP.NET Core アプリケーションに簡単なバックグラウンド処理を実装する記事。&lt;/p&gt;
&lt;p&gt;注意書きではとっかかりとしてはよいがロバストな構成とするため Hangfire や Quartz.NET の利用の検討するように触れられている。&lt;/p&gt;
&lt;h3 id="introduction-to-system.text.json-through-examples-code-maze"&gt;Introduction to System.Text.Json Through Examples - Code Maze&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/introduction-system-text-json-examples/"&gt;https://code-maze.com/introduction-system-text-json-examples/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.Text.Json&lt;/code&gt; の各種クラスなどの利用方法についての記事。&lt;/p&gt;
&lt;p&gt;シリアライズ/デシリアライズの方法や簡単なカスタマイズ方法 JsonDocument について、.NET 5 以降で使用できる HttpClient に対する拡張メソッドの紹介など。&lt;/p&gt;
&lt;h3 id="platform-vs.platformtarget-in-any.net-build"&gt;Platform vs. PlatformTarget In Any .NET Build&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/benvillalobos/platform-vs-platformtarget-in-any-net-build-252b"&gt;https://dev.to/benvillalobos/platform-vs-platformtarget-in-any-net-build-252b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MSBuild の &lt;code&gt;Platform&lt;/code&gt; と &lt;code&gt;PlatformTarget&lt;/code&gt; プロパティについて。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PlatformTarget&lt;/code&gt; はコンパイラーに渡されるもので、.NET Framework (non-SDK スタイル)のプロジェクトでは &lt;code&gt;Platform&lt;/code&gt; から、SDK スタイルのプロジェクトでは &lt;code&gt;Platform&lt;/code&gt; または &lt;code&gt;RuntimeIdentifier&lt;/code&gt; から定義される。その実際に定義されるまでの流れなどが解説されている。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="byme8zeroioc-zeroioc-is-reflectionless-ioc-container-for.net"&gt;byme8/ZeroIoC: ZeroIoC is reflectionless IoC Container for .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/byme8/ZeroIoC"&gt;https://github.com/byme8/ZeroIoC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Source Generator でコード生成することで初回実行も含めて高速な動作を目的とした IoC コンテナー。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dev.to/byme8/zeroioc-ioc-container-powered-via-source-generators-339c"&gt;ZeroIoC - IoC container powered via Source Generators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="net-6-asp.net-core-migration"&gt;.NET 6 ASP.NET Core Migration&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/davidfowl/0e0372c3c1d895c3ce195ba983b1e03d"&gt;https://gist.github.com/davidfowl/0e0372c3c1d895c3ce195ba983b1e03d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;David Fowler 氏による .NET 6 の ASP.NET Core に移行するためのガイド。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/kzu/status/1438634365869768707?s=12 --&gt;
&lt;blockquote class="twitter-tweet" data-conversation="none"&gt;&lt;p lang="en" dir="ltr"&gt;Hmm.... seems like &lt;a href="https://twitter.com/nuget?ref_src=twsrc%5Etfw"&gt;&amp;#64;nuget&lt;/a&gt; install/uninstall icon could use dark theme compatible versions 🤔 &lt;a href="https://t.co/mBYqyIOm1A"&gt;pic.twitter.com/mBYqyIOm1A&lt;/a&gt;&lt;/p&gt;&amp;mdash; Daniel Cazzulino (&amp;#64;kzu) &lt;a href="https://twitter.com/kzu/status/1438634365869768707?ref_src=twsrc%5Etfw"&gt;September 16, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Visual Studio 2022 のダークテーマ対応が進んだ結果、NuGet アイコンが透過で黒いものの場合に視認性が悪くなってしまうという話。&lt;/p&gt;
&lt;!-- https://twitter.com/shanselman/status/1438657727417315328?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Just learned that in the .NET CLR Header MetadataHeader Signature is the bytes 42 53 4A 42, which is HEX ASCII for &amp;#39;BSJB&amp;#39; which is the initials for Brian Harry, Susan Radke-Sproull, Jason Zander &amp;amp; Bill Evans, who worked on it! Just learned this via &lt;a href="https://twitter.com/robcaron?ref_src=twsrc%5Etfw"&gt;&amp;#64;robcaron&lt;/a&gt; about &lt;a href="https://twitter.com/jlzander?ref_src=twsrc%5Etfw"&gt;&amp;#64;jlzander&lt;/a&gt;&lt;/p&gt;&amp;mdash; Scott Hanselman (&amp;#64;shanselman) &lt;a href="https://twitter.com/shanselman/status/1438657727417315328?ref_src=twsrc%5Etfw"&gt;September 17, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET CLR のヘッダーのメタデータヘッダーシグネチャーが &lt;code&gt;42 53 4A 42&lt;/code&gt; で ASCII では 'BSJB' となり、Brian Harry, Susan Radke-Sproull, Jason Zander, Bill Evans (.NET Framework の開発者)のイニシャルであるという小ネタ。これは &lt;a href="https://www.oreilly.com/library/view/programming-in-the/0201770180/"&gt;Programming in the .NET Environment (2002)&lt;/a&gt; の序文に書かれている。&lt;/p&gt;
&lt;!-- https://twitter.com/konradkokosa/status/1438816800368640000?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Generational aware analysis added in .NET 5 is just a killer feature! Now you may have a full insight what was alive in a given generation AND from which generations🤯 &lt;a href="https://t.co/F6a6QcdbzX"&gt;pic.twitter.com/F6a6QcdbzX&lt;/a&gt;&lt;/p&gt;&amp;mdash; Konrad Kokosa (&amp;#64;konradkokosa) &lt;a href="https://twitter.com/konradkokosa/status/1438816800368640000?ref_src=twsrc%5Etfw"&gt;September 17, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 5 で PerfView でのスナップショット解析で GC のジェネレーション単位の分類ができるようになったという話。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1439336245730025472?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;You can also declare the Program class as partial and add things to it while keeping your top level statements. This makes it possible to expose properties/fields/etc, declare a base class or implement an interface on the type that hosts the Program&amp;#39;s entry point.&lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://t.co/er9oSTc0Gf"&gt;pic.twitter.com/er9oSTc0Gf&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1439336245730025472?ref_src=twsrc%5Etfw"&gt;September 18, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 RC1 以降で Top-level statements のコードを書いた際に生成される Program クラスにアクセスできるようになった。また、Program クラスは partial として生成されるので partial class を定義することで拡張できるというテクニック。&lt;/p&gt;
&lt;!-- https://twitter.com/mattleibow/status/1439036843287269378?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Literally just finished the pre-alpha-hack-poc for &lt;a href="https://twitter.com/hashtag/SkiaSharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#SkiaSharp&lt;/a&gt; running on &lt;a href="https://twitter.com/hashtag/Blazor?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#Blazor&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/WebAssembly?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#WebAssembly&lt;/a&gt; &lt;a href="https://t.co/s4Dt8Kj1em"&gt;https://t.co/s4Dt8Kj1em&lt;/a&gt; &lt;a href="https://t.co/Ys6tTvB2dy"&gt;pic.twitter.com/Ys6tTvB2dy&lt;/a&gt;&lt;/p&gt;&amp;mdash; Matthew &amp;quot;V 50%&amp;quot; Leibowitz (&amp;#64;mattleibow) &lt;a href="https://twitter.com/mattleibow/status/1439036843287269378?ref_src=twsrc%5Etfw"&gt;September 18, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;SkiaSharp と Blazor WASM で Canvas 操作などを行える PoC ができたという話。&lt;/p&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1438926317383294982?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Previous C# versions don&amp;#39;t support field initializers in the structs.&lt;br&gt;&lt;br&gt;C# 10 fixes it and closes the gap between struct and class declarations.&lt;br&gt;&lt;br&gt;If the struct has field initializers, the compiler will synthesize a public parameterless constructor.&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt; &lt;a href="https://t.co/5XVfU0xQTS"&gt;pic.twitter.com/5XVfU0xQTS&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1438926317383294982?ref_src=twsrc%5Etfw"&gt;September 17, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;C# 10 では struct に対してフィールド初期化子を記述した場合、パラメータなしのコンストラクターが自動生成されるようになった。なおパラメータありコンストラクターを記述した場合はパラメータなしコンストラクターは生成されないので注意。&lt;/p&gt;
&lt;!-- https://twitter.com/konradkokosa/status/1440344667820752907?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;TIL: PerfView has live events view command. For example, to observe all .NET exceptions on the machine:&lt;br&gt;.\PerfView.exe UserCommand Listen Microsoft-Windows-DotNETRuntime:0x8000:Verbose:&amp;#64;EventIDsToEnable=80 &lt;a href="https://t.co/Pdfv89xpEK"&gt;pic.twitter.com/Pdfv89xpEK&lt;/a&gt;&lt;/p&gt;&amp;mdash; Konrad Kokosa (&amp;#64;konradkokosa) &lt;a href="https://twitter.com/konradkokosa/status/1440344667820752907?ref_src=twsrc%5Etfw"&gt;September 21, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;&lt;code&gt;.\PerfView.exe UserCommand Listen Microsoft-Windows-DotNETRuntime:0x8000:Verbose:&amp;#64;EventIDsToEnable=80&lt;/code&gt; を実行することでコンピューター上のすべての .NET アプリケーションのあらゆる Exception を観測できるというテクニック。&lt;/p&gt;
&lt;!-- https://twitter.com/kirillosenkov/status/1440192351528374279?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Folks, a quick PSA about large MSBuild builds on CI.&lt;br&gt;&lt;br&gt;Too often I see a build taking upwards of 10-20 minutes with all sorts of text loggers (file loggers, console loggers), worst of all text loggers of diagnostic verbosity.&lt;br&gt;&lt;br&gt;Text loggers absolutely kill your build performance.&lt;/p&gt;&amp;mdash; Kirill Osenkov (&amp;#64;KirillOsenkov) &lt;a href="https://twitter.com/KirillOsenkov/status/1440192351528374279?ref_src=twsrc%5Etfw"&gt;September 21, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;CI などでの巨大な MSBuild ビルドを実行するときはテキストログを止めるとパフォーマンス向上できるという話。スレッドにはその方法や binlog の使用を進めるといった話も。&lt;/p&gt;
&lt;!-- https://twitter.com/jaredpar/status/1439973140910641155?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;This will not RTM in C# 10 as there are significant toolchain issues that need to be sorted out before they can be generally used.&lt;/p&gt;&amp;mdash; Jared Parsons (&amp;#64;jaredpar) &lt;a href="https://twitter.com/jaredpar/status/1439973140910641155?ref_src=twsrc%5Etfw"&gt;September 20, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Generic 属性は .NET 6 にはツールチェイン側の対応の都合などもあり入らず(C++/CLI コンパイラーがクラッシュするなど)、.NET 7 / C# 11 になるという話。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1439630163872944129?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;This is the best thing I&amp;#39;ve found today. The [BestFriend] attribute 🤣 &lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://t.co/VgN9peJFHj"&gt;https://t.co/VgN9peJFHj&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1439630163872944129?ref_src=twsrc%5Etfw"&gt;September 19, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;ML.NET に &lt;code&gt;BestFriend&lt;/code&gt; 属性という変わった名前の属性があるという話。&lt;/p&gt;
&lt;p&gt;この属性は外部のアセンブリから内部 (internal) に対してアクセス可能であることを示すもので、外部のアセンブリは &lt;code&gt;WantsToBeBestFriends&lt;/code&gt; 属性を持つ。&lt;code&gt;InternalsVisibleTo&lt;/code&gt; 属性との違いは &lt;code&gt;BestFriend&lt;/code&gt; 属性自体は特別な効果を持つものではなく &lt;code&gt;InternalsVisibleTo&lt;/code&gt; 属性で internal にアクセスできるようになっている前提で、各種 internal なメンバーが外部のアセンブリからのアクセスを意図しているかどうかを Analyzer でチェックするためのマーカー。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/machinelearning/blob/3bf8cba75fd94241d2f918fc5330e8cda3b36432/src/Microsoft.ML.Core/BestFriendAttribute.cs#L25"&gt;machinelearning/BestFriendAttribute.cs at 3bf8cba75fd94241d2f918fc5330e8cda3b36432 · dotnet/machinelearning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/machinelearning/blob/3bf8cba75fd94241d2f918fc5330e8cda3b36432/tools-local/Microsoft.ML.InternalCodeAnalyzer/BestFriendAnalyzer.cs"&gt;machinelearning/BestFriendAnalyzer.cs at 3bf8cba75fd94241d2f918fc5330e8cda3b36432 · dotnet/machinelearning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-09-17: .NET 6 RC1, Visual Studio 2022 Preview 4, WinUI 2.7, Uno Platform 3.10</title>
			<link>/2021/09/17/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/09/17/updates</guid>
			<pubDate>Fri, 17 Sep 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;h2 id="section"&gt;主なトピックス&lt;/h2&gt;
&lt;p&gt;.NET 6 RC 1 と Visual Studio 2022 Preview 4 がリリースされました。RC ということで若干の breaking changes はありますが GA に向けたステップといったリリースです。Preview から Go live ライセンスとなったのでプロダクション環境での利用が可能になります。&lt;/p&gt;
&lt;p&gt;また、マルチプラットフォームアプリを作るためのフレームワーク MAUI は .NET 6 には入らないことなどがアナウンスされています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-1/"&gt;Announcing .NET 6 Release Candidate 1 - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-preview-4-is-now-available/"&gt;Visual Studio 2022 Preview 4 is now available! - Visual Studio Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-dotnet-maui/"&gt;Update on .NET Multi-platform App UI (.NET MAUI) - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Uno Platform 3.10 がリリースされました。.NET 6 RC1 への対応や Windows 11 のスタイルなどに対応したようです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://platform.uno/blog/uno-platform-3-10-day-0-support-for-net-6-rc1-winui-infobadge-windows-11-fluent-styles/"&gt;Uno Platform 3.10: Day-0 support for .NET 6 RC1, WinUI InfoBadge, Windows 11 Fluent Styles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Silverlight のオープンソース代替実装、OpenSilver のベータがリリースされました。これは C#/WPF を Web 技術上で動かす CSHTML5 をベースとして Silverlight のコードを Web 技術上で動かすものです。Silverlight は2021年10月12日でサポート終了するため、その延命処置としてといった目的が大きそうです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://opensilver.net/announcements/introducing-opensilver.aspx"&gt;Introducing OpenSilver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NETのクラスライブラリ設計 改訂新版の予約が Amazon でできるようになりました。10月7日に発売だそうです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.co.jp/dp/4296080040"&gt;.NETのクラスライブラリ設計 改訂新版 (マイクロソフト関連書) | Krzysztof Cwalina、Jeremy Barton、Brad Abrams, 猪股 健太郎、河合 宜文 (監訳), 藤原 雄介 |本 | 通販 | Amazon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;ヘッドライン&lt;/h2&gt;
&lt;h3 id="announcing.net-6-release-candidate-1.net-blog"&gt;Announcing .NET 6 Release Candidate 1 - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-1/"&gt;https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 Release Candidate 1 がリリース。RC1 以降では機能の追加などから GA に向けて品質の向上にフォーカスする形。
また、このバージョンから &amp;quot;go live&amp;quot; ライセンスとなり実運用環境での使用がサポートされる。
Visual Studio 2022 Preview 4と共に使用することが前提で Visual Studio 2022 for Mac Preview 1 は追って対応。&lt;/p&gt;
&lt;p&gt;記事ではソースからビルドすること(.NET 6 で tarball からビルドできるようになったなど)、Profile-guided optimization、Crossgen2、セキュリティー関連についてなどが触れられている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-6-rc-1/"&gt;ASP.NET Core updates in .NET 6 Release Candidate 1 - ASP.NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-dotnet-maui/"&gt;Update on .NET Multi-platform App UI (.NET MAUI) - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="visual-studio-2022-preview-4-is-now-available-visual-studio-blog"&gt;Visual Studio 2022 Preview 4 is now available! - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-preview-4-is-now-available/"&gt;https://devblogs.microsoft.com/visualstudio/visual-studio-2022-preview-4-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 Preview 4 がリリース。&lt;/p&gt;
&lt;p&gt;ファイル内検索が改善され、大きいソリューションなどでは3倍近く早くなった。&lt;/p&gt;
&lt;p&gt;ブレークポイントの条件に &amp;quot;Dependent Breakpoint&amp;quot; という「特定のブレークポイントにかかっていた場合にブレークする」という設定の追加。ASP.NET での CSS 同期や MAUI サポートを初めとするホットリロード機能の強化。フォルダー階層と名前空間を合わせる &amp;quot;Sync Namespaces&amp;quot; の追加(ReSharper の Adjust Namespaces 相当)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#17.0.0-pre.4.0"&gt;Visual Studio 2022 Preview Release Notes | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="update-on.net-multi-platform-app-ui.net-maui.net-blog"&gt;Update on .NET Multi-platform App UI (.NET MAUI) - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-dotnet-maui/"&gt;https://devblogs.microsoft.com/dotnet/update-on-dotnet-maui/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MAUI の状況と .NET MAUI Preview 8 について。&lt;/p&gt;
&lt;p&gt;MAUI は開発状況的に .NET 6 の11月の GA には入らず、2022年の Q2 での GA を目指すとのこと。それまでは Xamarin の強化を行い、製品開発への採用は Xamarin を推奨する。.NET 6 GA の段階で必要な機能は提供するがしばらくはプレビューで品質向上と移行のための準備を進める。&lt;/p&gt;
&lt;p&gt;また .NET 6 RC1 では &amp;quot;Go Live&amp;quot; だが、MAUI は除外され、RC2 で Preview となる。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 Preview 4 の Mobile development with .NET ワークロードに MAUI が含まれるようになった。Windows デスクトップアプリケーションをターゲットにしたい場合には &amp;quot;Desktop Development with .NET&amp;quot;, &amp;quot;UWP&amp;quot;, &amp;quot;Desktop Development with C++&amp;quot; ワークロードも必要。&lt;/p&gt;
&lt;p&gt;また、XAML のホットリロードにも対応し、Windows をはじめ iOS, Android でも同様に動作する。&lt;/p&gt;
&lt;p&gt;.NET MAUI SDK はアップデートで ASP.NET Core などと同様に .NET Host Builder パターンを使用するようになった。&lt;/p&gt;
&lt;h3 id="winui-2.7-release-notes-windows-apps-microsoft-docs"&gt;WinUI 2.7 Release Notes - Windows apps | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/apps/winui/winui2/release-notes/winui-2.7"&gt;https://docs.microsoft.com/en-us/windows/apps/winui/winui2/release-notes/winui-2.7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows UI Library 2.7 がリリース。&lt;/p&gt;
&lt;p&gt;InfoBadge コントロール、ColorPicker の方向設定(横置き)の追加。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/microsoft-ui-xaml/releases/tag/v2.7.0"&gt;Release Microsoft.UI.Xaml 2.7.0 · microsoft/microsoft-ui-xaml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-september-2021-updates-5.0.10-and-3.1.19.net-blog"&gt;.NET September 2021 Updates – 5.0.10 and 3.1.19 - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/september-2021-updates/"&gt;https://devblogs.microsoft.com/dotnet/september-2021-updates/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5.0.10 と 3.1.19 がリリース。&lt;/p&gt;
&lt;p&gt;セキュリティーアップデートを含まない、信頼性やその他バグ修正等の改善。&lt;/p&gt;
&lt;p&gt;.NET 5 の Runtime には &lt;code&gt;GCConserveMemory&lt;/code&gt; という GC の設定が追加された。&lt;code&gt;GCConserveMemory&lt;/code&gt; は Gen 2 で意味のある生きたデータの割合の閾値で設定値として 1-9 をとる。例えば 3 を指定した場合には Gen 2 にあるべきデータは 30% となり、これによってフラグメンテーションが 70% 以上になるとよりブロッキング Gen 2 GC が実行される(つまり大きい値を指定すると Gen 2 をコンパクトに保とうとする)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/announcements/issues/200"&gt;September 2021 .NET Updates · Issue #200 · dotnet/announcements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/48601"&gt;Fix high frag in gen2 by PeterSolMS · Pull Request #48601 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="uno-platform-3.10-day-0-support-for.net-6-rc1-winui-infobadge-windows-11-fluent-styles"&gt;Uno Platform 3.10: Day-0 support for .NET 6 RC1, WinUI InfoBadge, Windows 11 Fluent Styles&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://platform.uno/blog/uno-platform-3-10-day-0-support-for-net-6-rc1-winui-infobadge-windows-11-fluent-styles/"&gt;https://platform.uno/blog/uno-platform-3-10-day-0-support-for-net-6-rc1-winui-infobadge-windows-11-fluent-styles/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Uno Platform 3.10 がリリース。&lt;/p&gt;
&lt;p&gt;.NET 6 RC1 への対応や Windows 11 のスタイルなどに対応、WinUI に追加された InfoBadge への対応など。多くの改善と修正、サンプルコードの追加が行われた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/unoplatform/uno/releases/tag/3.10.7"&gt;Release 3.10.7 · unoplatform/uno&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="http3-enable-in-kestrel-by-default-in.net-7-issue-36486-dotnetaspnetcore"&gt;HTTP/3: Enable in Kestrel by default in .NET 7 · Issue #36486 · dotnet/aspnetcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/issues/36486"&gt;https://github.com/dotnet/aspnetcore/issues/36486&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 7 で Kestrel の HTTP/3 サポートがデフォルトで有効になる予定。&lt;/p&gt;
&lt;h3 id="introducing-opensilver"&gt;Introducing OpenSilver&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://opensilver.net/announcements/introducing-opensilver.aspx"&gt;https://opensilver.net/announcements/introducing-opensilver.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Silverlight のオープンソース代替実装、OpenSilver のベータがリリース。&lt;/p&gt;
&lt;p&gt;C#/WPF を Web 技術上で動かす CSHTML5 をベースとして Silverlight のコードを Web 技術上で動かすツールキット。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/OpenSilver/OpenSilver"&gt;OpenSilver/OpenSilver: This repository contains the source of both OpenSilver and CSHTML5. More information is available at: www.opensilver.net and www.cshtml5.com - Read README.md for the instructions on how to build the source code and how to test it.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://support.microsoft.com/ja-jp/windows/silverlight-%E3%81%AE%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E7%B5%82%E4%BA%86%E6%97%A5-0a3be3c7-bead-e203-2dfd-74f0a64f1788"&gt;Silverlight のサポート終了日&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="open-sourcing-the.net-5-c-language-extension-for-sql-server-microsoft-sql-server-blog"&gt;Open sourcing the .NET 5 C# Language Extension for SQL Server - Microsoft SQL Server Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://cloudblogs.microsoft.com/sqlserver/2021/09/08/open-sourcing-the-net-5-c-language-extension-for-sql-server/"&gt;https://cloudblogs.microsoft.com/sqlserver/2021/09/08/open-sourcing-the-net-5-c-language-extension-for-sql-server/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SQL Server 2019 から利用できる外部コードを実行することで様々な言語を呼び出せる仕組みで .NET 5 / C# を使用する拡張がオープンソースで公開された。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.engineer-memo.com/2021/09/12/sql-server-2019-on-windows-%E3%81%AE-language-extension-%E3%81%A7-net-5-c-%E3%81%8C%E5%8B%95%E4%BD%9C%E3%81%99%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F/"&gt;SQL Server 2019 on Windows の Language Extension で .NET 5 C# が動作するようになりました at SE の雑記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/sql/language-extensions/language-extensions-overview?view=sql-server-ver15"&gt;SQL Server 言語拡張とは? | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/sql-server-language-extensions/tree/main/language-extensions/dotnet-core-CSharp"&gt;sql-server-language-extensions/language-extensions/dotnet-core-CSharp at main · microsoft/sql-server-language-extensions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-1.4.0-beta.3-mysql-netmysqlconnector"&gt;Release 1.4.0-beta.3 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/1.4.0-beta.3"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/1.4.0-beta.3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector の 1.4.0-beta.3 がリリース。&lt;/p&gt;
&lt;p&gt;1.4.0 シリーズでは .NET 6 のサポートの追加や、netstandard1.3 のサポートの削除などが行われている。&lt;/p&gt;
&lt;h3 id="release-v5.0.10-npgsqlnpgsql"&gt;Release v5.0.10 · npgsql/npgsql&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/npgsql/npgsql/releases/tag/v5.0.10"&gt;https://github.com/npgsql/npgsql/releases/tag/v5.0.10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Npgsql 5.0.10 がリリース。&lt;/p&gt;
&lt;p&gt;様々な不具合の修正と、&lt;code&gt;xid8&lt;/code&gt; データ型のサポートの追加など。&lt;/p&gt;
&lt;h3 id="security-bulletin-announcements-travis-ci-community"&gt;Security Bulletin - Announcements - Travis CI Community&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://travis-ci.community/t/security-bulletin/12081"&gt;https://travis-ci.community/t/security-bulletin/12081&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Travis CI の脆弱性について。パブリックなリポジトリをフォークした先で PR を作った際に元リポジトリの Secrets が露出してしまう問題があった。&lt;/p&gt;
&lt;p&gt;経緯や対応方法は下記の記事が詳しいので Travis CI を使用していた場合には対応が推奨。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zenn.dev/azu/articles/110528f8963686"&gt;Travis CIのGitHub連携を停止する方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="introducing-package-source-mapping-the-nuget-blog"&gt;Introducing Package Source Mapping - The NuGet Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/nuget/introducing-package-source-mapping/"&gt;https://devblogs.microsoft.com/nuget/introducing-package-source-mapping/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;複数の NuGet パッケージソースを持つ場合に特定のパッケージやパッケージ名のパターンでどのパッケージソースを使用するか指定できる機能についての記事。&lt;/p&gt;
&lt;p&gt;例えば特定の名前のパッケージ(&lt;code&gt;Contoso&lt;/code&gt; や &lt;code&gt;Contoso.*&lt;/code&gt;)は常に社内の NuGet パッケージレジストリを使うといったことが可能となる。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 Preview 4 または nuget.exe 6.0.0-preview.4 または .NET SDK 6.0.100-rc.1 (.NET 6 RC1) 以降が必要。&lt;/p&gt;
&lt;h3 id="reflection-via-source-generators"&gt;Reflection via source generators&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/byme8/aot-reflection-4ijb"&gt;https://dev.to/byme8/aot-reflection-4ijb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Source Generator でリフレクションで取得するようなものをあらかじめ生成しておくことでリフレクションのようなことをする場合でもパフォーマンスを稼げるのではないかというアイデアの記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/byme8/Apparatus.AOT.Reflection"&gt;byme8/Apparatus.AOT.Reflection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="cidisposableusingdispose"&gt;C#でIDisposableをusingしたのにDisposeしてくれない件&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://makiuchi-d.github.io/2021/09/16/csharp-using-idisposable.ja.html"&gt;http://makiuchi-d.github.io/2021/09/16/csharp-using-idisposable.ja.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;場合によっては &lt;code&gt;try-finally&lt;/code&gt; の &lt;code&gt;finally&lt;/code&gt; が呼び出されないことがあるという話。&lt;/p&gt;
&lt;p&gt;通常例外がエントリーポイントまでさかのぼって &lt;code&gt;catch&lt;/code&gt; されなかった場合、「ハンドルされていない例外 (Unhandled Exception)」となりアプリケーションが終了される。その際、一番外側でも &lt;code&gt;catch&lt;/code&gt; がない場合 &lt;code&gt;finally&lt;/code&gt; が実行されない可能性がある。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static void Main(string[] args)
{
    try
    {
        try
        {
            throw new Exception();
        }
        finally
        {
            // 実行される
            Console.WriteLine(&amp;quot;Finally2&amp;quot;);
        }
    }
    catch (Exception e)
    {
        // ここで throw すると結局 Unhandled Exception となるので try-catch-finally の finally は実行されない可能性がある
        throw;
    }
    finally
    {
        // 実行されない可能性がある
        Console.WriteLine(&amp;quot;Finally&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大抵はユーザーコードにたどり着くまでにフレームワークのどこかで try-catch が含まれているので問題にならないが、素のコンソールアプリケーションや Top-level Statements などで、&lt;code&gt;using&lt;/code&gt; / &lt;code&gt;using var&lt;/code&gt; を利用している場合等で問題になる可能性がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/keywords/try-finally"&gt;try-finally - C# リファレンス | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="system.diagnostics.metrics-api-qiita"&gt;計量的な統計を扱うためのSystem.Diagnostics.Metrics API - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/skitoy4321/items/ae506268fb18fc2ac54d"&gt;https://qiita.com/skitoy4321/items/ae506268fb18fc2ac54d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で追加される System.Diagnosics.Metrics API についての記事。API の概要とシナリオ、実際の使い方などを解説。&lt;/p&gt;
&lt;h3 id="web-api-openapi-httprepl"&gt;Web API (OpenAPI) の探索やテストに便利な HttpRepl を使ってみた&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/08thse/articles/47-tool-httprepl"&gt;https://zenn.dev/08thse/articles/47-tool-httprepl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Tools として提供されている HTTP を REPL のような形で操作できる HttpRepl の使い方の記事。&lt;/p&gt;
&lt;h3 id="apples-in-maui"&gt;Apples in MAUI&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.telerik.com/amp/apples-maui/WEx1ZE1sRUVUWkE5S0dNbEhBNXJyUkU3T1Q4PQ2"&gt;https://www.telerik.com/amp/apples-maui/WEx1ZE1sRUVUWkE5S0dNbEhBNXJyUkU3T1Q4PQ2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MAUI で iOS アプリケーションを動かすまでの macOS 開発環境でのステップバイステップ。&lt;/p&gt;
&lt;h3 id="section-3"&gt;[雑記] コンパイル結果に影響を及ぼす属性&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ufcpp.net/study/csharp/start/miscreservedattribute/"&gt;https://ufcpp.net/study/csharp/start/miscreservedattribute/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AttributeUsage&lt;/code&gt; や &lt;code&gt;Conditional&lt;/code&gt;, &lt;code&gt;Obsolete&lt;/code&gt; など実行時に属性を解釈するのではなくコンパイル時にコンパイラーが知るためにある属性についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NullableContext&lt;/code&gt; のようなコンパイラーが生成する属性についても。&lt;/p&gt;
&lt;h3 id="api-versioning-in-asp.net-core.net-core-tutorials"&gt;API Versioning in ASP.net Core - .NET Core Tutorials&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dotnetcoretutorials.com/2017/01/17/api-versioning-asp-net-core/"&gt;https://dotnetcoretutorials.com/2017/01/17/api-versioning-asp-net-core/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core で API のバージョニングを実現する Microsoft.AspNetCore.Mvc.Versioning の使い方についての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/alicial/items/f095ef52c5677abc3f7e"&gt;.NETCoreでアクション別のバージョン管理 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net5.0rest-apiaws-codepipelineecs-qiita"&gt;.NET5.0製のREST APIサーバーを、AWS CodePipelineでビルドしてコンテナ化してECSでデプロイする。 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/tricrow/items/dad78c99cb77c7c6be9b"&gt;https://qiita.com/tricrow/items/dad78c99cb77c7c6be9b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 アプリケーションを AWS CodePipeline/CodeBuild でビルドして、ARM (Graviton) な ECS インスタンスで動かすという話。&lt;/p&gt;
&lt;h3 id="debugging-a.net-app-on-linux-from-windows-visual-studio-with-wsl-ndepend"&gt;Debugging a .NET App on Linux from Windows Visual Studio with WSL - NDepend&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.ndepend.com/debugging-a-net-app-on-linux-from-windows-visual-studio-with-wsl"&gt;https://blog.ndepend.com/debugging-a-net-app-on-linux-from-windows-visual-studio-with-wsl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio から .NET 5 アプリケーションを WSL 2 上の Linux で動かしてデバッグするための手順についての記事。&lt;/p&gt;
&lt;p&gt;.NET Framework のアプリを移植してきた場合、&lt;code&gt;DebugType&lt;/code&gt; が &lt;code&gt;full&lt;/code&gt; となっている場合があるので &lt;code&gt;portable&lt;/code&gt; にするようにといった話も。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/visualstudio/debugger/debug-dotnet-core-in-wsl-2?view=vs-2019"&gt;Linux で WSL を使用して .NET アプリをデバッグする - Visual Studio (Windows) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="socks-proxy-support-in.net.net-core-tutorials"&gt;SOCKS Proxy Support In .NET - .NET Core Tutorials&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dotnetcoretutorials.com/2021/07/11/socks-proxy-support-in-net/"&gt;https://dotnetcoretutorials.com/2021/07/11/socks-proxy-support-in-net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で　SOCKS プロキシーに対応したのでその使用方法についての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/48883"&gt;SOCKS4/4a/5 proxy support in SocketsHttpHandler by huoyaoyuan · Pull Request #48883 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="looking-inside-configurationmanager-in.net-6-exploring.net-core-6-part-1"&gt;Looking inside ConfigurationManager in .NET 6: Exploring .NET Core 6 - Part 1&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-1-looking-inside-configurationmanager-in-dotnet-6/"&gt;https://andrewlock.net/exploring-dotnet-6-part-1-looking-inside-configurationmanager-in-dotnet-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ConfigurationBuilder の代わりとなる .NET 6 で導入された ConfigurationManager についての違いと利点などについての記事。&lt;/p&gt;
&lt;p&gt;ConfigurationManager は &lt;code&gt;IConfigurationBuilder&lt;/code&gt; を実装しているが ConfigurationBuilder と異なり、設定ソースの追加と削除が行われた時点で設定が確定するため部分的な取り出しが簡単になっている (&lt;code&gt;IConfigurationRoot&lt;/code&gt; を実装していて自身を返すだけになっている)。&lt;code&gt;ConfigurationBuilder&lt;/code&gt; は一度 &lt;code&gt;Build&lt;/code&gt; しないと読めないため、設定に依存する設定がある場合の取り回しが悪かった。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationmanager?view=dotnet-plat-ext-6.0"&gt;ConfigurationManager Class (Microsoft.Extensions.Configuration) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="web.net-maui-essentialsxamarin.essentials-1.7"&gt;新たなWeb認証オプションと.NET MAUI Essentialsを加えたXamarin.Essentials 1.7&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.infoq.com/jp/news/2021/09/xamarin-essentials-1-7/"&gt;https://www.infoq.com/jp/news/2021/09/xamarin-essentials-1-7/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xamarin.Essentials 1.7 についての記事。Web 認証と MAUI 対応について。&lt;/p&gt;
&lt;h3 id="backend-for-frontend-authentication-pattern-with-auth0-and-asp.net-core"&gt;Backend For Frontend Authentication Pattern with Auth0 and ASP.NET Core&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://auth0.com/blog/backend-for-frontend-pattern-with-auth0-and-dotnet/"&gt;https://auth0.com/blog/backend-for-frontend-pattern-with-auth0-and-dotnet/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Backend for Frontend (BFF) のような構成で Auth0 と ASP.NET Core を使った認証実装パターンについての記事。&lt;/p&gt;
&lt;h3 id="minimal-apis-at-a-glance-in.net-6"&gt;Minimal APIs at a glance in .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/minimal-apis-at-a-glance-in-net-6"&gt;https://www.hanselman.com/blog/minimal-apis-at-a-glance-in-net-6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 (ASP.NET Core) の Minimal API を使用したサンプルコードの記事。&lt;/p&gt;
&lt;h2 id="section-4"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="egorbostaticpgo_example-how-to-collect-a-static-not-the-dynamic-one-pgo-and-re-use-it-during-dotnet-publish"&gt;EgorBo/StaticPGO_Example: How to collect a static (not the dynamic one) PGO and re-use it during &amp;quot;dotnet publish&amp;quot;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/EgorBo/StaticPGO_Example"&gt;https://github.com/EgorBo/StaticPGO_Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Static PGO を試すためのサンプルリポジトリ。&lt;/p&gt;
&lt;h3 id="mayukikokuban-simplifies-styling-strings-in-the-terminal-for.net-application"&gt;mayuki/Kokuban: Simplifies styling strings in the terminal for .NET application&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mayuki/Kokuban"&gt;https://github.com/mayuki/Kokuban&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンソールに表示される文字列に対して色や下線など装飾を行うためのライブラリ。&lt;/p&gt;
&lt;h3 id="mayukichell-write-scripts-with-the-power-of-c-and.net"&gt;mayuki/Chell: Write scripts with the power of C# and .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mayuki/Chell"&gt;https://github.com/mayuki/Chell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;シェルスクリプトのような作業を C# でも書きやすくするためのプロセス実行とユーティリティのライブラリ。&lt;/p&gt;
&lt;h2 id="section-5"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="scott-hanselman-shanselman-tiktok-watch-scott-hanselmans-newest-tiktok-videos"&gt;Scott Hanselman (&amp;#64;shanselman) TikTok | Watch Scott Hanselman's Newest TikTok Videos&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.tiktok.com/&amp;#64;shanselman"&gt;https://www.tiktok.com/&amp;#64;shanselman&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Scott Hanselman の TikTok。&lt;/p&gt;
&lt;h3 id="net-krzysztof-cwalinajeremy-bartonbrad-abrams-amazon"&gt;.NETのクラスライブラリ設計 改訂新版 (マイクロソフト関連書) | Krzysztof Cwalina、Jeremy Barton、Brad Abrams, 猪股 健太郎、河合 宜文 (監訳), 藤原 雄介 |本 | 通販 | Amazon&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.amazon.co.jp/dp/4296080040"&gt;https://www.amazon.co.jp/dp/4296080040&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NETのクラスライブラリ設計 改訂新版の発売日が10月7日となり、Amazon での予約が開始。&lt;/p&gt;
&lt;h3 id="section-6"&gt;ツイート&lt;/h3&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;New create option in &lt;a href="https://twitter.com/AzureFunctions?ref_src=twsrc%5Etfw"&gt;&amp;#64;AzureFunctions&lt;/a&gt; to create apps with .NET 6 🎉 &lt;br&gt;&lt;br&gt;Go give it a try! &lt;a href="https://t.co/El855SLeGM"&gt;pic.twitter.com/El855SLeGM&lt;/a&gt;&lt;/p&gt;&amp;mdash; Jeff Hollan (&amp;#64;jeffhollan) &lt;a href="https://twitter.com/jeffhollan/status/1436422895350153217?ref_src=twsrc%5Etfw"&gt;September 10, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Azure Functions で .NET 6 が Preview という形で使用できるように(これまでは Early Preview 扱い)。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Your binlogs will be smaller and your builds will be faster! &lt;a href="https://t.co/uEhA1t3zIE"&gt;https://t.co/uEhA1t3zIE&lt;/a&gt;&lt;/p&gt;&amp;mdash; Kirill Osenkov (&amp;#64;KirillOsenkov) &lt;a href="https://twitter.com/KirillOsenkov/status/1395510072348868609?ref_src=twsrc%5Etfw"&gt;May 20, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;MSBuild が 16.10 で文字列の dedup するようになって binlog が小さくなって、ビルドが速くなったという話。他にも binlog にファイルを埋め込めるようになった等の改善点など。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/msbuild/pull/6017"&gt;Deduplicate strings in binlogs by KirillOsenkov · Pull Request #6017 · dotnet/msbuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/msbuild/pull/6339"&gt;Add support for embedding arbitrary files into binlog by KirillOsenkov · Pull Request #6339 · dotnet/msbuild&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Optimized version 🏎️&lt;br&gt;If build time only is enough for your codegen, you can still use RegisterForSyntaxNotifications and detect build time by checking entry assembly != null &lt;a href="https://t.co/fXKdxTSzSA"&gt;https://t.co/fXKdxTSzSA&lt;/a&gt;&lt;br&gt;By doing so, your codegen will have *zero* impact at IDE time/keystrokes! 😎 &lt;a href="https://t.co/HZx3VObLlB"&gt;pic.twitter.com/HZx3VObLlB&lt;/a&gt;&lt;/p&gt;&amp;mdash; Alexandre Mutel (&amp;#64;xoofx) &lt;a href="https://twitter.com/xoofx/status/1437054965789470729?ref_src=twsrc%5Etfw"&gt;September 12, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Source Generator から &lt;code&gt;Assembly.GetEntryAssembly()&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; かどうかを調べることで IDE 上で動いているかどうか確認できるので、ビルド時にのみ実行したい Source Generator を作る場合には使えるというテクニック。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;For 17.0, we have fully NGEN&amp;#39;d most major assemblies, most of which is in Preview 4, with a trailing set of assemblies in a future preview.&lt;/p&gt;&amp;mdash; David Kean (&amp;#64;davkean) &lt;a href="https://twitter.com/davkean/status/1438027246623547394?ref_src=twsrc%5Etfw"&gt;September 15, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Visual Studio が 64bit になったことでアドレス空間に余裕ができた。例えばアドレス空間を節約するため NGEN の対象はよく使われるコードパスのもののみに絞っていた(のでたまに JIT が走る)が、主要なアセンブリの大半を NGEN できるようになったという話。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;&lt;a href="https://t.co/4PmXMQN7SX"&gt;https://t.co/4PmXMQN7SX&lt;/a&gt; Core SignalR is one of the things I&amp;#39;m most proud of engineering wise. Lots of lessons were learnt building the first version that went into building its successor. Here is an example of native IAsyncEnumerable&amp;lt;T&amp;gt; streaming &lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/signalr?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#signalr&lt;/a&gt; &lt;a href="https://t.co/7wEmonu6Zp"&gt;pic.twitter.com/7wEmonu6Zp&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1437994847252606978?ref_src=twsrc%5Etfw"&gt;September 15, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;SignalR の Hub は &lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; をサポートしているのでデータのストリーミングできるという話。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="add-initial-regex-source-generator-by-stephentoub-pull-request-59186-dotnetruntime"&gt;Add initial regex source generator by stephentoub · Pull Request #59186 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59186"&gt;https://github.com/dotnet/runtime/pull/59186&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Regex の Source Generator の初期実装のPR。&lt;/p&gt;
&lt;p&gt;Source Generator であらかじめ正規表現マッチ用のコードを生成しておくことでパフォーマンスを向上することが目的。
現時点では &lt;code&gt;RegexOptions.Compiled&lt;/code&gt; のコードを流用して、C# の Regex のマッチ用のコードを生成する形。&lt;/p&gt;
&lt;h3 id="need-to-run-non-english-text-through-utf8encoding-for-pgo-scenarios-issue-57698-dotnetruntime-github"&gt;Need to run non-English text through UTF8Encoding for PGO scenarios · Issue #57698 · dotnet/runtime · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/57698"&gt;https://github.com/dotnet/runtime/issues/57698&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で PGO をかけた結果 UTF8Encoding が遅くなってしまうケースが発生しているという話。&lt;/p&gt;
&lt;p&gt;Non-English なテキストを処理するようなデータでプロファイルしていないため、ギリシャ語やキリル文字を処理するようなケースでパフォーマンスが若干低下している。多分日本語も該当する可能性がある。コアライブラリは元から PGO で最適化された R2R の形式で出荷されているので影響を受ける。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/52313"&gt;[Perf] Regressions in System.Text.Perf_Utf8Encoding for Greek and Cyrillic · Issue #52313 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="add-freebsd-rids-to-known-targets-by-josteink-pull-request-11972-dotnetinstaller"&gt;Add FreeBSD RIDs to known targets by josteink · Pull Request #11972 · dotnet/installer&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/installer/pull/11972"&gt;https://github.com/dotnet/installer/pull/11972&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;インストーラーが知っている Runtime Identifier に FreeBSD が追加することでインストールできるようにする PR。&lt;/p&gt;
&lt;h3 id="support-multi-targeting-for-roslyn-components-by-eerhardt-pull-request-20793-dotnetsdk"&gt;Support multi-targeting for Roslyn components by eerhardt · Pull Request #20793 · dotnet/sdk&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/sdk/pull/20793"&gt;https://github.com/dotnet/sdk/pull/20793&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roslyn のバージョンが Visual Studio 2019 (Roslyn 3.10) と 2022 (Roslyn 4.0) という形で複数ある都合、読み込むものを分けられるようにするという PR (マルチターゲット化)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sdk/issues/20355"&gt;Support multi-targeting for Roslyn components · Issue #20355 · dotnet/sdk · GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="marshal.allochglobalfreehglobal-is-150x-slower-in.net-than-legacy-mono-on-device-tvos-issue-58939-dotnetruntime"&gt;Marshal.AllocHGlobal/FreeHGlobal is ~150x slower in .NET than legacy mono on device (tvOS) · Issue #58939 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/58939"&gt;https://github.com/dotnet/runtime/issues/58939&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;tvOS で Marshal.AllocHGlobal/FreeHGlobal が急激に遅くなったのだけどなぜ?という話。レガシー Mono では問題なかったが .NET ではとても遅い、となっているが実際はランタイム自体はどちらも Mono で .NET 6 世代で &lt;code&gt;Marshal.AllocHGlobal&lt;/code&gt; の実装が .NET の &lt;code&gt;NativeMemory.Alloc&lt;/code&gt; に変わった影響。&lt;/p&gt;
&lt;p&gt;Mono の固有実装と異なり素直に P/Invoke を使うようになった影響で P/Invoke 呼び出しの GC セーフにするための処理でオーバーヘッドが生まれてしまった。&lt;/p&gt;
&lt;h3 id="api-proposal-add-arm64-to-processorarchitecture-and-imagefilemachine-enums-issue-58970-dotnetruntime"&gt;[API Proposal]: Add Arm64 to ProcessorArchitecture and ImageFileMachine enums · Issue #58970 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/58970"&gt;https://github.com/dotnet/runtime/issues/58970&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ProcessorArchitecture&lt;/code&gt; と &lt;code&gt;ImageFileMachine&lt;/code&gt; に ARM64 の値がないので増やしたいという提案。
ところがそもそもこの値は .NET Core/.NET 5 以降では事実上の非推奨でほぼ機能しておらず、むしろ &lt;code&gt;AssemblyName&lt;/code&gt; にある &lt;code&gt;ProcessorArchitecture&lt;/code&gt; は Obsolete にしたいという話に。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59061"&gt;Obsolete thumbtacked AssemblyName properties · Issue #59061 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="create-using-alias-types.md-by-cyrusnajmabadi-pull-request-5174-dotnetcsharplang"&gt;Create using-alias-types.md by CyrusNajmabadi · Pull Request #5174 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/pull/5174"&gt;https://github.com/dotnet/csharplang/pull/5174&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;名前を持つ型に対するエイリアスとして &lt;code&gt;using A = Foo.Bar.Baz;&lt;/code&gt; はできるが、&lt;code&gt;using Position = (int X, int Y);&lt;/code&gt; のようなタプルや配列型、ポインター型などに対するエイリアスは定義できないので定義できるようにする提案。&lt;/p&gt;
&lt;h3 id="proposal-event-hookup-in-object-initializer-issue-5176-dotnetcsharplang"&gt;[Proposal]: Event hookup in object initializer · Issue #5176 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/5176"&gt;https://github.com/dotnet/csharplang/issues/5176&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オブジェクト初期化子で event ハンドラーをセットできてもいいのではないかという提案。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>