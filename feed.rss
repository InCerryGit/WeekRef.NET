<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:content="http://purl.org/rss/1.0/modules/content/" version="2.0">
	<channel>
		<title>WeekRef.NET</title>
		<link>/</link>
		<description>.NET 関連の情報をほぼ週刊配信</description>
		<copyright>Copyright © Mayuki Sawatari &lt;mayuki@misuzilla.org&gt;</copyright>
		<managingEditor>Mayuki Sawatari</managingEditor>
		<pubDate>Fri, 22 Oct 2021 11:57:04 GMT</pubDate>
		<lastBuildDate>Fri, 22 Oct 2021 11:57:04 GMT</lastBuildDate>
		<item>
			<title>2021-10-22: Visual Studio 2022 RC2, LINQPad 7 Beta, Hot Reload, F# 6</title>
			<link>/2021/10/22/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/10/22/updates</guid>
			<pubDate>Fri, 22 Oct 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#1700-pre60--visual-studio-2022-version-170-rc2-and-preview-6-newreleasebutton"&gt;Visual Studio 2022 version 17.0 RC2 and Preview 6&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;.NET 自体の更新はなく Visual Studio のバグ修正が主な更新点です。何か不具合のようなものを踏んでいる方は更新をおすすめします。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://www.linqpad.net/LINQPad7.aspx"&gt;LINQPad 7 Beta&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;.NET 6 および C# 10 に対応し、ARM64 向けのバイナリーも含まれるようになりました。Surface Pro X のような ARM 版 Windows でも C# を書いて ARM ネイティブで動かせるようになりました。現在 6 のライセンスは無償アップグレードとなっていて、既にライセンスを持っている人でも割引で購入できるようになっています。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-net-hot-reload-progress-and-visual-studio-2022-highlights/"&gt;ホットリロードについてのステータスアップデート&lt;/a&gt;がアナウンスされました。&lt;/p&gt;
&lt;p&gt;アナウンスでは Visual Studio とターゲットフレームワークによる対応具合や MAUI/ASP.NET での対応についても書かれていますが、地味に大きな点としては &lt;code&gt;dotnet watch&lt;/code&gt; をリリースしないという決定がなされたという点です。特に Visual Studio を使用していない開発者がホットリロードの恩恵を受けられなくなるということで大きな反響が生まれています。&lt;/p&gt;
&lt;p&gt;元々バギーではあったのですが .NET 6 の目玉機能かつ RC2 をリリースした後、GA までもう少しという直前の段階で削除をしてリリースしないというアナウンスをしたので余計に不満になっていそうです。今後何らかの形で戻されたりする可能性は十分あるのではないかと思います。&lt;/p&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="visual-studio-2022-version-17.0-rc2-and-preview-6"&gt;Visual Studio 2022 version 17.0 RC2 and Preview 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#1700-pre60--visual-studio-2022-version-170-rc2-and-preview-6-newreleasebutton"&gt;https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#1700-pre60--visual-studio-2022-version-170-rc2-and-preview-6-newreleasebutton&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 version 17.0 RC2 と Preview 6 がリリースされた。&lt;/p&gt;
&lt;p&gt;RC と Preview 5 のリリースからの Visual Studio 固有のバグ修正が行われており、.NET 6 SDK などへの変更はない。&lt;/p&gt;
&lt;h3 id="linqpad-7-beta"&gt;LINQPad 7 Beta&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.linqpad.net/LINQPad7.aspx"&gt;https://www.linqpad.net/LINQPad7.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;LINQPad 7 Beta がリリースされた。&lt;/p&gt;
&lt;p&gt;LINQPad 7 は .NET 6 および C# 10 に対応したリリースとなり、.NET 6, .NET 5, .NET Core 3.1, .NET Framework をサポートする。
また ARM64 ビルドも提供され Surface Pro X をはじめとする ARM64 環境でのネイティブ動作が可能となった。&lt;/p&gt;
&lt;p&gt;正式なリリースは .NET 6 のリリース後となり、現在 LINQPad 6 のライセンスを購入することでリリース時にアップグレードが可能。&lt;/p&gt;
&lt;!-- https://twitter.com/linqpad/status/1450036548506767363?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;LINQPad 7 Preview has just been released, with full support for C# 10, &lt;a href="https://twitter.com/dotnet?ref_src=twsrc%5Etfw"&gt;&amp;#64;dotnet&lt;/a&gt; 6 and EF Core 6. There&amp;#39;s also now an ARM64 build, so you can run and debug C# and F# code on your Surface Pro X at native speed!&lt;a href="https://t.co/1sC2iOFwoW"&gt;https://t.co/1sC2iOFwoW&lt;/a&gt;&lt;/p&gt;&amp;mdash; LINQPad·Joe Albahari (&amp;#64;linqpad) &lt;a href="https://twitter.com/linqpad/status/1450036548506767363?ref_src=twsrc%5Etfw"&gt;October 18, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="update-on.net-hot-reload-progress-and-visual-studio-2022-highlights"&gt;Update on .NET Hot Reload progress and Visual Studio 2022 Highlights&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-net-hot-reload-progress-and-visual-studio-2022-highlights/"&gt;https://devblogs.microsoft.com/dotnet/update-on-net-hot-reload-progress-and-visual-studio-2022-highlights/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET のホットリロードについてのアップデートの記事。&lt;/p&gt;
&lt;p&gt;記事では次のようなトピックについて書かれている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;サポートされるフレームワークとシナリオ&lt;/li&gt;
&lt;li&gt;Visual Studio 2022 での体験の向上&lt;/li&gt;
&lt;li&gt;MAUI と ASP.NET でのシナリオ&lt;/li&gt;
&lt;li&gt;.NET アプリの編集に関する追加サポート&lt;/li&gt;
&lt;li&gt;.NET 6 ユニットテストのホットリロード (Experimental)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dotnet watch&lt;/code&gt; コマンドラインツールに関する変更&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;サポートされるフレームワークとシナリオについては Visual Studio 2022 からデバッガーを使用しているかそうでないか、Visual Studio 2022 と .NET 6 をターゲットとしたアプリかどうかといった場合について書かれている。大まかには従来のフレームワークをターゲットとしている場合にはデバッグ時のみ、.NET 6 をターゲットとしている場合はデバッガーなしも含め殆どのケースでサポートされる。&lt;/p&gt;
&lt;p&gt;ただし Blazor WebAssembly は GA の時点では対応されず、他に対応しないシナリオとして iOS と Android の Xamarin.Forms や F# アプリケーション、.NET Native アプリケーションなどがあるとのこと。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 での体験の向上は、ラベルが Hot Reload となったこと、ファイル保存時にホットリロードする機能が付いたことなどがあげられている。&lt;/p&gt;
&lt;p&gt;MAUI と ASP.NET でのシナリオは MAUI (iOS/Android) でのホットリロードが可能になること、ASP.NET では Razor CSHTML の変更と自動リロード、CSS のホットリロードなどが可能となった。ただし MAUI のホットリロードは Mono ランタイムの制限上メソッドボディーの編集に限られるとのこと。&lt;/p&gt;
&lt;p&gt;その他 XAML のホットリロードとユニットテスト実行時のホットリロードがプレビュー(オプトイン)で提供されていることについて。&lt;/p&gt;
&lt;p&gt;最後に &lt;code&gt;dotnet watch&lt;/code&gt; コマンドラインツールについて、ホットリロードは開発の集中のため Visual Studio 2022 でのみの提供となり、コマンドラインツールはリリースしないと決定したとのこと。Visual Studio 2022 for Mac に関しては将来のリリースで追加する予定。&lt;/p&gt;
&lt;p&gt;これに伴い &lt;code&gt;dotnet watch&lt;/code&gt; が削除されたが、Visual Studio Code や Rider といった Visual Studio 以外のユーザーからは不満の声が上がっているので今後何らか動きがある可能性がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sdk/pull/22217"&gt;Remove Hot Reload support from dotnet watch by pranavkm · Pull Request #22217 · dotnet/sdk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sdk/issues/22247"&gt;Hot Reload removed from dotnet watch - Why? · Issue #22247 · dotnet/sdk&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="whats-new-in-f-6"&gt;What’s new in F# 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/whats-new-in-fsharp-6/"&gt;https://devblogs.microsoft.com/dotnet/whats-new-in-fsharp-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 に含まれる F# 6 についての記事。&lt;/p&gt;
&lt;p&gt;F# で速くなった点、均一化された点、シンプルになった点、ツーリングの改善などについて触れている。&lt;/p&gt;
&lt;h3 id="introducing-new-javascript-engine-yantrajs-for-dotnet"&gt;Introducing new JavaScript Engine YantraJS for DotNet&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.webatoms.in/blog/yantra-js/Introducing-new-JavaScript-Engine-YantraJS-for-DotNet-2g"&gt;https://www.webatoms.in/blog/yantra-js/Introducing-new-JavaScript-Engine-YantraJS-for-DotNet-2g&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オープンソースの JavaScript エンジンの YantraJS がリリースされた。&lt;/p&gt;
&lt;p&gt;.NET との相互運用や JavaScript を .NET のアセンブリーに変換するコンパイラーなどが提供されることが特徴。
現時点で ECMAScript 6 の適合率は70%程度で今後100%を目指すとのこと。その他 V8 Debugger Protocol のサポートなどが今後のロードマップにあがっている。&lt;/p&gt;
&lt;p&gt;ライセンスは LGPL、YantraJS Standard License (主にサーバーサイド利用目的)、YantraJS Enterprise License となっている。MIT ライセンスに変更できるようスポンサーも求めているとのこと。(ただ LGPL 版を NuGet で参照した場合でもソースコードを公開する必要があると書かれているので LGPL ではない可能性がある)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/yantrajs/yantra/wiki/License"&gt;License · yantrajs/yantra Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="weve-upgraded-the-ui-in-visual-studio-2022"&gt;We've upgraded the UI in Visual Studio 2022&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/weve-upgraded-the-ui-in-visual-studio-2022/"&gt;https://devblogs.microsoft.com/visualstudio/weve-upgraded-the-ui-in-visual-studio-2022/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 における UI の変更についての記事。&lt;/p&gt;
&lt;p&gt;一貫性や視認性、親しみやすさを考慮したアイコンの刷新、ダークモードでのコントラスト調整や新しいアクセントカラー、Cascadia フォントの導入などについて触れている。&lt;/p&gt;
&lt;h3 id="contributing-to.net-maui-community-toolkit"&gt;Contributing to .NET MAUI Community Toolkit&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/contributing-to-net-maui-community-toolkit/"&gt;https://devblogs.microsoft.com/dotnet/contributing-to-net-maui-community-toolkit/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET MAUI Community Toolkit にコントリビュートする方法についての記事。&lt;/p&gt;
&lt;p&gt;.NET MAUI Community Toolkit がコミュニティーのコントリビュートを受け入れるようになり、新機能を提案したい場合のフローについて解説している。
フローは C# チームのものを参考にしたものとなっている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Discussion をオープン&lt;/li&gt;
&lt;li&gt;フィーチャーの Proposal (Issue) をオープン&lt;/li&gt;
&lt;li&gt;チームによって Champion を選出&lt;/li&gt;
&lt;li&gt;.NET MAUI Community Toolkit Monthly Standup (YouTube 配信) で投票の上、承認&lt;/li&gt;
&lt;li&gt;Pull Request 承認&lt;/li&gt;
&lt;li&gt;ドキュメント承認&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;承認された Proposal は &lt;code&gt;help wanted&lt;/code&gt; ラベルがつけられるため、簡単なコントリビュートとしてはこの実装を提供する(Pull Request)という方法も提示されている。&lt;/p&gt;
&lt;h3 id="release-2.0.0-beta.5-mysql-netmysqlconnector"&gt;Release 2.0.0-beta.5 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/2.0.0-beta.5"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/2.0.0-beta.5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector 2.0.0-beta.5 がリリースされた。&lt;/p&gt;
&lt;p&gt;変更点は &lt;code&gt;ActivitySource&lt;/code&gt; によるトレースへの対応。今回のリリースよりバージョニングが 1.4.0 ベータでの変更範囲を鑑みて 2.0 へと変更された。&lt;/p&gt;
&lt;h3 id="release-1.3.14-mysql-netmysqlconnector"&gt;Release 1.3.14 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/1.3.14"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/1.3.14&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector 1.3.14 がリリースされた。&lt;/p&gt;
&lt;p&gt;バグ修正が主な変更となっている。&lt;/p&gt;
&lt;h3 id="release-ef-core-3.1.20-dotnetefcore"&gt;Release EF Core 3.1.20 · dotnet/efcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/releases/tag/v3.1.20"&gt;https://github.com/dotnet/efcore/releases/tag/v3.1.20&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 3.1.20 がリリースされた。&lt;/p&gt;
&lt;p&gt;SQLite の不具合対応に伴い、依存しているバージョンが 2.0.2 から 2.0.4 へアップデートされた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ericsink/SQLitePCL.raw/issues/321"&gt;System.AccessViolationException at System.Text.UTF8Encoding.GetCharCount(Byte*, Int32, System.Text.DecoderNLS) · Issue #321 · ericsink/SQLitePCL.raw&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-diagnostics-release-v5.0.251802-dotnetdiagnostics"&gt;Release Diagnostics Release - v5.0.251802 · dotnet/diagnostics&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/diagnostics/releases/tag/v5.0.251802"&gt;https://github.com/dotnet/diagnostics/releases/tag/v5.0.251802&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET の診断ツール 5.0.251802 がリリースされた。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;dotnet-dump&lt;/code&gt; と &lt;code&gt;dotnet-sos&lt;/code&gt; は Linux と Windows 上でのシングルファイルアプリケーションのプロセスとファイルの解析がサポートされた。その他バグ修正など。&lt;/p&gt;
&lt;h3 id="developing-for-windows-with-the-windows-app-sdk-discussion-1615-microsoftwindowsappsdk"&gt;Developing for Windows with the Windows App SDK · Discussion #1615 · microsoft/WindowsAppSDK&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/microsoft/WindowsAppSDK/discussions/1615"&gt;https://github.com/microsoft/WindowsAppSDK/discussions/1615&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows App SDK と WinUI 3 の開発についての FAQ。&lt;/p&gt;
&lt;p&gt;今後 UWP はバグや信頼性に関連する修正のみが行われ、Windows App SDK を使用する場合には新しいデスクトッププロジェクトに移行する必要があること、といった点など。&lt;/p&gt;
&lt;h3 id="net-framework-october-2021-security-and-quality-rollup"&gt;.NET Framework October 2021 Security and Quality Rollup&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/net-framework-october-2021-security-and-quality-rollup/"&gt;https://devblogs.microsoft.com/dotnet/net-framework-october-2021-security-and-quality-rollup/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Framework の2021年10月のセキュリティーと累積アップデートについて。&lt;/p&gt;
&lt;p&gt;セキュリティーに関する更新はなく、正しくない GC の設定によるパフォーマンスの低下や GC.AddMemoryPressure での GC トリガーのアルゴリズムの調整などが含まれている。&lt;/p&gt;
&lt;h3 id="bouncycastle-c-1.9.0"&gt;BouncyCastle C# 1.9.0&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.bouncycastle.org/csharp/index.html#DOWNLOAD1900"&gt;https://www.bouncycastle.org/csharp/index.html#DOWNLOAD1900&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;BouncyCastle C# 1.9.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;TLS API の更新や Format Preserving Encryption、ParallelHash と TupleHash、ARIA cipher のサポートが追加された。バグ修正も行われている。&lt;/p&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="net-6-qiita"&gt;.NET 6 で追加されるタスクベースの新しいタイマー - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/karuakun/items/677b2e58260634d86d0d"&gt;https://qiita.com/karuakun/items/677b2e58260634d86d0d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で追加されたタスクベースとなる新しいタイマーの使い方とそれ以前のタイマーについての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.periodictimer?view=net-6.0"&gt;PeriodicTimer Class (System.Threading)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="unity-improving-iteration-time-on-c-script-changes"&gt;Unity - Improving iteration time on C# script changes&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://forum.unity.com/threads/improving-iteration-time-on-c-script-changes.1184446/"&gt;https://forum.unity.com/threads/improving-iteration-time-on-c-script-changes.1184446/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Unity で C# コードを変更したときのドメインリロードの時間が長くなってしまった件についての調査と進捗報告。&lt;/p&gt;
&lt;p&gt;リグレッションは 2020.x から発生し、メトリクスの不足や問題が多岐にわたっていること、幾つかの側面から解決を図っていることなど。&lt;/p&gt;
&lt;p&gt;例えば 2020.1 以降ではドメインリロードの診断メトリクスを保存する機能が追加されたので利用者が調べることができるようになった。コードベース全体を通してリグレッションを探すタスクフォースを立ち上げ細かく最適化を行うことなど。今後も継続して改善を進め、必要なものはバックポートし、その進捗はスレッドに報告するとのこと。&lt;/p&gt;
&lt;h3 id="helpful-nuget-package-for-unit-testing-in.net"&gt;5 helpful Nuget package for Unit Testing in .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;niteshsinghal85/5-helpful-nuget-package-for-unit-testing-in-net-87c2e087c6d"&gt;https://medium.com/&amp;#64;niteshsinghal85/5-helpful-nuget-package-for-unit-testing-in-net-87c2e087c6d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ユニットテストをするときに役に立つ5つの NuGet パッケージの紹介の記事。&lt;/p&gt;
&lt;h3 id="supporting-integration-tests-with-webapplicationfactory-in.net-6-exploring.net-core-6-part-6"&gt;Supporting integration tests with WebApplicationFactory in .NET 6: Exploring .NET Core 6 - Part 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-6-supporting-integration-tests-with-webapplicationfactory-in-dotnet-6/"&gt;https://andrewlock.net/exploring-dotnet-6-part-6-supporting-integration-tests-with-webapplicationfactory-in-dotnet-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core を WebApplicationFactory を使用して統合テストを行うことについての記事。&lt;/p&gt;
&lt;p&gt;WebApplicationFactory が内部で行っている処理についても解説している。&lt;/p&gt;
&lt;h3 id="updated-debugging-experience-uwp-apps-and-debug-windows-docker-containers-in-rider-2021.3-the.net-tools-blog"&gt;Updated Debugging Experience, UWP Apps, and Debug Windows Docker containers in Rider 2021.3 | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/20/debugging-experience-debug-uwp-apps-and-debug-windows-docker-containers-in-rider-2021-3/"&gt;https://blog.jetbrains.com/dotnet/2021/10/20/debugging-experience-debug-uwp-apps-and-debug-windows-docker-containers-in-rider-2021-3/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rider 2021.3 で改善されたデバッグ周りについての記事。&lt;/p&gt;
&lt;p&gt;デバッガーの UI の改善や UWP アプリと Windows Docker コンテナーの対応についてなど。&lt;/p&gt;
&lt;h3 id="bite-size.net-6-linq-ordefault-overloads"&gt;Bite-Size .NET 6 - LINQ OrDefault() Overloads&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://exceptionnotfound.net/bite-size-dotnet-6-linq-ordefault-overloads/"&gt;https://exceptionnotfound.net/bite-size-dotnet-6-linq-ordefault-overloads/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の LINQ の &lt;code&gt;FirstOrDefault&lt;/code&gt; のような &lt;code&gt;*OrDefault&lt;/code&gt; メソッドにデフォルト値を受けるオーパーロードが追加されたことについての記事。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;var name = names.FirstOrDefault(&amp;quot;Unknown&amp;quot;); // 見つからなかったら Unknown が返る
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="exploring-the-auth0-asp.net-core-authentication-sdk"&gt;Exploring the Auth0 ASP.NET Core Authentication SDK&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://auth0.com/blog/exploring-auth0-aspnet-core-authentication-sdk/"&gt;https://auth0.com/blog/exploring-auth0-aspnet-core-authentication-sdk/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;アプリケーションで Auth0 の ASP.NET Core Authentication SDK を使用することについての記事。&lt;/p&gt;
&lt;h3 id="grpc-api-performance-improvement-through-protobuf-fieldmask-in.net"&gt;gRPC API Performance Improvement Through Protobuf FieldMask In .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;AzilenTech/grpc-api-performance-improvement-through-protobuf-fieldmask-in-net-2dff2af6c959"&gt;https://medium.com/&amp;#64;AzilenTech/grpc-api-performance-improvement-through-protobuf-fieldmask-in-net-2dff2af6c959&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Protobuf の FieldMask を使用することで gRPC の API パフォーマンスを向上させることについての記事。&lt;/p&gt;
&lt;p&gt;必要なフィールドだけを明示して取得することでサーバー側の不要な処理を回避して、メッセージサイズも削減できるというテクニック。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://netflixtechblog.com/practical-api-design-at-netflix-part-1-using-protobuf-fieldmask-35cfdc606518"&gt;Practical API Design at Netflix, Part 1: Using Protobuf FieldMask&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://blog.pyspa.org/post/using_protobuf_fieldmask/"&gt;Netflixにおける実用的なAPI設計: gRPCとFieldMask | pyspa&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="implement-a-secure-api-and-a-blazor-app-in-the-same-asp.net-core-project-with-azure-ad-authentication"&gt;Implement a secure API and a Blazor app in the same ASP.NET Core project with Azure AD authentication&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://damienbod.com/2021/10/04/implement-a-secure-api-and-a-blazor-app-in-the-same-asp-net-core-project-with-azure-ad-authentication/"&gt;https://damienbod.com/2021/10/04/implement-a-secure-api-and-a-blazor-app-in-the-same-asp-net-core-project-with-azure-ad-authentication/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly と ASP.NET Core Web API に Azure AD 認証を実装する方法についての記事。&lt;/p&gt;
&lt;h3 id="asp-net-core-rest-api-authorization-with-jwt-roles-vs-claims-vs-policy-step-by-step"&gt;Asp Net Core - Rest API Authorization with JWT (Roles Vs Claims Vs Policy) - Step by Step&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/moe23/asp-net-core-rest-api-authorization-with-jwt-roles-vs-claims-vs-policy-step-by-step-5bgn"&gt;https://dev.to/moe23/asp-net-core-rest-api-authorization-with-jwt-roles-vs-claims-vs-policy-step-by-step-5bgn&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;REST API に JWT を使った認可を実装する方法についての記事。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="davidfowliiscrossover-a-prototype-running-asp.net-and-asp.net-core-in-the-same-iis-pipeline"&gt;davidfowl/IISCrossover: A prototype running ASP.NET and ASP.NET Core in the same IIS pipeline&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/davidfowl/IISCrossover"&gt;https://github.com/davidfowl/IISCrossover&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;IIS で ASP.NET アプリケーション (.NET Framework) と ASP.NET Core アプリケーションを同居させて同じパイプラインで動かすという仕組みのプロトタイプ。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1449239883529134082?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;If you&amp;#39;re interested in trying it out and looking at the s/hacks/changes, the the repository is here &lt;a href="https://t.co/masxtR85CC"&gt;https://t.co/masxtR85CC&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧🇺🇸💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1449239883529134082?ref_src=twsrc%5Etfw"&gt;October 16, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="devloopedthisassembly-exposes-project-and-assembly-level-information-as-constants-in-the-thisassembly-class-using-source-generators-powered-by-roslyn"&gt;devlooped/ThisAssembly: Exposes project and assembly level information as constants in the ThisAssembly class using source generators powered by Roslyn.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/devlooped/ThisAssembly"&gt;https://github.com/devlooped/ThisAssembly&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;自身のプロジェクトやアセンブリの情報を取得できるコードを生成する Source Generator。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;Console.WriteLine(ThisAssembly.Info.Company); // AssemblyCompanyAttribute
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;アセンブリの情報だけでなく、定数の定義やメタデータ、プロジェクトのプロパティーにアクセスできるようなものも提供されている。&lt;/p&gt;
&lt;h3 id="amis92csharp-source-generators-a-list-of-c-source-generators-not-necessarily-awesome-and-associated-resources-articles-talks-demos"&gt;amis92/csharp-source-generators: A list of C# Source Generators (not necessarily awesome) and associated resources: articles, talks, demos.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/amis92/csharp-source-generators"&gt;https://github.com/amis92/csharp-source-generators&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# Source Generator のまとめリポジトリ。&lt;/p&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="windows-subsystem-for-androidtm"&gt;Windows Subsystem for Android™️&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/android/wsa/"&gt;https://docs.microsoft.com/en-us/windows/android/wsa/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows Subsystem for Android™️ の開発者ドキュメント。考慮すべき点やアプリケーションのデバッグ方法などについて触れている。&lt;/p&gt;
&lt;h3 id="overall-migration-strategy-windows-apps"&gt;Overall migration strategy - Windows apps&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/apps/windows-app-sdk/migrate-to-windows-app-sdk/overall-migration-strategy"&gt;https://docs.microsoft.com/en-us/windows/apps/windows-app-sdk/migrate-to-windows-app-sdk/overall-migration-strategy&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Universal Windows Platform から Windows App SDK へのマイグレーションのガイドドキュメント。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/steplyakov/status/1449056693568958466?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;It is amazing how &lt;a href="https://twitter.com/VisualStudio?ref_src=twsrc%5Etfw"&gt;&amp;#64;VisualStudio&lt;/a&gt; can show a deadlock in the async code in the &amp;#39;Parallel Stacks&amp;#39; view!&lt;br&gt;&lt;br&gt;It&amp;#39;s not possible to figure out an issue like this one simply by looking into the stack traces. You need to look at how the async machinery is linked together to show it. &lt;a href="https://t.co/9WlANzaI5t"&gt;pic.twitter.com/9WlANzaI5t&lt;/a&gt;&lt;/p&gt;&amp;mdash; Sergey Teplyakov (&amp;#64;STeplyakov) &lt;a href="https://twitter.com/STeplyakov/status/1449056693568958466?ref_src=twsrc%5Etfw"&gt;October 15, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;非同期処理のデッドロックの発見に Parallel Stacks ビューが便利という話(これは以前のバージョンの Visual Studio にある)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/visualstudio/debugger/using-the-parallel-stacks-window?view=vs-2019"&gt;[並列スタック] ウィンドウでスレッドを表示する - Visual Studio (Windows)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1449098382111346692?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;In .NET 6, you can easily generate a random sequence of values from a Cryptographically Secure Pseudorandom Number Generator (CSPNG).&lt;br&gt;&lt;br&gt;It&amp;#39;s useful for cryptographic applications for:&lt;br&gt;• key generation&lt;br&gt;• nonces&lt;br&gt;• salts in certain signature schemes&lt;a href="https://twitter.com/hashtag/dotnet6?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet6&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt; &lt;a href="https://t.co/O1AmnBVTVE"&gt;pic.twitter.com/O1AmnBVTVE&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1449098382111346692?ref_src=twsrc%5Etfw"&gt;October 15, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 では暗号論的擬似乱数生成器 (CSPRNG) を使用してランダムなデータを生成するのが &lt;code&gt;RandomNumberGenerator&lt;/code&gt; クラスの静的メソッドで簡単に取得できるようになったという話。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.security.cryptography.randomnumbergenerator.getbytes?view=net-6.0#System_Security_Cryptography_RandomNumberGenerator_GetBytes_System_Span_System_Byte__"&gt;RandomNumberGenerator.GetBytes メソッド (System.Security.Cryptography)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/xoofx/status/1449047838017589252?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Thrilled to announce we have formed a C#/.NET Tech Group within Unity, bringing Scripting (C# compilation, .NET Runtime integration...), Burst &amp;amp; VM/IL2CPP teams all together to further standardize, modernize, and innovate with .NET technologies within the Unity platform! ♥️&lt;/p&gt;&amp;mdash; Alexandre Mutel (&amp;#64;xoofx) &lt;a href="https://twitter.com/xoofx/status/1449047838017589252?ref_src=twsrc%5Etfw"&gt;October 15, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Unity 社で C#/.NET の技術グループが立ち上がってスクリプティング (C# や .NET ランタイムの統合)、Burst と VM/IL2CPP チームがまとまって Unity における .NET 技術の推進をしていくという話。今後 &lt;q&gt;exciting news&lt;/q&gt; があるとのこと。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1451230807197040649?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;One of my slides from the &lt;a href="https://t.co/4PmXMQN7SX"&gt;https://t.co/4PmXMQN7SX&lt;/a&gt; Core performance talk &lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/aspnetcore?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#aspnetcore&lt;/a&gt; &lt;a href="https://t.co/kfkYo2uKM9"&gt;pic.twitter.com/kfkYo2uKM9&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧🇺🇸💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1451230807197040649?ref_src=twsrc%5Etfw"&gt;October 21, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;ASP.NET Core の .NET 6 まででどのぐらいパフォーマンスが改善されたのかという話のスライドからの抜粋。WebSocket のアロケーションやリクエスト/TLS ハンドシェイクでのアロケーション、ヘッダー周りの高速化などについて。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="datetime.now-on-linux-has-wrong-timezone-issue-60469-dotnetruntime"&gt;&lt;code&gt;DateTime.Now&lt;/code&gt; on Linux has wrong timezone · Issue #60469 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60469"&gt;https://github.com/dotnet/runtime/issues/60469&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DateTime.Now&lt;/code&gt; が Linux で正しいタイムゾーンを返さないようだという Issue。クローズされているが self-contained な物で発生しているという報告。&lt;/p&gt;
&lt;h3 id="where-is-the-asp.net-branding-and-logo-issue-37550-dotnetaspnetcore"&gt;Where is the ASP.NET Branding and Logo? · Issue #37550 · dotnet/aspnetcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/issues/37550"&gt;https://github.com/dotnet/aspnetcore/issues/37550&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET のブランディングロゴはどこにあるのかという Issue。&lt;/p&gt;
&lt;p&gt;現時点では個別のロゴは存在しないがあってもいいのではないかとか、ブランディングのガイドラインではアプリモデルの形では例があり、今後更新していくといった話も。&lt;/p&gt;
&lt;h3 id="experiment-with-unsafe.stackalloct-by-stephentoub-pull-request-60428-dotnetruntime"&gt;Experiment with Unsafe.StackAlloc&amp;lt;T&amp;gt; by stephentoub · Pull Request #60428 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60428"&gt;https://github.com/dotnet/runtime/pull/60428&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hackathon で実装されたスタック上に &lt;code&gt;T&lt;/code&gt; の &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; を作れる &lt;code&gt;Unsafe.StackAlloc&amp;lt;T&amp;gt;&lt;/code&gt; のサンプル利用例の PR。&lt;/p&gt;
&lt;p&gt;この PR で見られるように現在の dotnet/runtime では &lt;code&gt;Span&amp;lt;参照型&amp;gt;&lt;/code&gt; をスタック上に作成するために次のようなテクニックを使っている。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;ThreeMyClasses tmp = default;
Span&amp;lt;MyClass&amp;gt; threeMyClasses = MemoryMarshal.CreateSpan(ref Unsafe.As(ref tmp._value1), 3);

ref struct ThreeMyClasses
{
    internal MyClass _value1;
    private MyClass _value2;
    private MyClass _value3;
}

class MyClass { }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;これによりスタック上の構造体を &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; に見せかけることで参照型を含む配列的なものをアロケーションなしで作ることができる。ただし、&lt;code&gt;stackalloc&lt;/code&gt; と異なりコンパイラーがコードをチェックできず &lt;code&gt;return&lt;/code&gt; できてしまう危険性がある点に注意。&lt;/p&gt;
&lt;h3 id="proposal-readonlyspan-initialization-from-static-data-issue-5295-dotnetcsharplang"&gt;[Proposal]: ReadOnlySpan initialization from static data · Issue #5295 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/5295"&gt;https://github.com/dotnet/csharplang/issues/5295&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;private static ReadOnlySpan&amp;lt;byte&amp;gt; Bytes =&amp;gt; new byte[] { ... };&lt;/code&gt; のような最適化テクニックがあるが、一部のプリミティブでのみ使用できるものでそれ以外のケースでは罠となってしまうのでそれ用の構文が欲しいという提案。&lt;/p&gt;
&lt;h3 id="update-docs-for-pipereader.tryread-by-waf-pull-request-52237-dotnetruntime"&gt;Update docs for PipeReader.TryRead by waf · Pull Request #52237 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/52237"&gt;https://github.com/dotnet/runtime/pull/52237&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Stream&lt;/code&gt; を元にした &lt;code&gt;PipeReader.TryRead&lt;/code&gt; は &lt;code&gt;Stream&lt;/code&gt; に対して読み込みを実行しないということをドキュメントに明記するという PR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-10-15: .NET 6 RC2, Visual Studio 2022 RC2 &amp; Preview 5, .NET 5.0.11, ReSharper/Rider 2021.3 EAP</title>
			<link>/2021/10/15/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/10/15/updates</guid>
			<pubDate>Fri, 15 Oct 2021 10:55:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/"&gt;.NET 6 Release Candidate 2 (RC2) がリリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;それに合わせて ASP.NET Core, MAUI, EF Core もアップデートされ、Visual Studio 2022 も RC と Preview 5 がリリースされています。RC ということもあり新機能はあまりなく、バグ修正がメインのリリースとなっています。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 は今回から RC (リリース) と Preview でチャンネルが分かれました。RC は General Availability (GA) つまり製品版がリリースされたのち製品版へとアップデートされ、Preview チャンネルはそのまま Visual Studio 2022 の次期 Preview 版 (17.1 Preview) へと更新されるという違いがあります。&lt;/p&gt;
&lt;p&gt;以前より11月9日の &lt;a href="https://www.dotnetconf.net/"&gt;.NET Conf&lt;/a&gt; で .NET 6 がローンチされるということがアナウンスされていましたが、&lt;a href="https://visualstudio.microsoft.com/ja/launch/"&gt;Visual Studio 2022 のオンラインローンチイベントも11月8日(日本時間では11月9日)に行われる&lt;/a&gt;こともアナウンスされました。(Visual Studio 2022 に .NET 6 がついてくることを考えると、.NET 6 の実質的なリリース日はそちらになるのでしょうか…)。&lt;/p&gt;
&lt;p&gt;ASP.NET Core の Blazor WebAssembly にはネイティブ依存関係のサポートが入りました。これは Emscripten でコンパイルされたネイティブコードを C# から呼び出せるようになる仕組みです。WASM でコンパイルできる C/C++ などのライブラリーを C# から呼び出すといったことができるようになるので、できることが増えそうです。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/october-2021-updates/"&gt;.NET 5.0.11 と 3.1.20 がリリース&lt;/a&gt;されました。&lt;/p&gt;
&lt;p&gt;バグ修正とセキュリティー修正が行われています。セキュリティーに関しては Linux および macOS での &lt;code&gt;System.DirectoryServices.Protocols.LdapConnection&lt;/code&gt; で機密情報がプレーンテキストで送信されてしまうという問題が修正されています。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;ReSharper と Rider の 2021.3 EAP4 がリリースされました。&lt;/p&gt;
&lt;p&gt;ReSherper はコードフォーマットの改善と dotTrace のタイムラインを開く操作やフィルター操作が高速化しました。Rider はフォーマッティングの設定や &lt;code&gt;EditorBrowsable&lt;/code&gt; のサポート追加、Unity とXamarin のサポート強化が行われています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.jetbrains.com/resharper/nextversion/"&gt;Early Access Program (EAP) - ReSharper&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.jetbrains.com/rider/nextversion/"&gt;Early Access Program (EAP) - Rider: Cross-platform .NET IDE&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="announcing.net-6-release-candidate-2"&gt;Announcing .NET 6 Release Candidate 2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/"&gt;https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 Release Candidate 2 (RC2) がリリースされ、合わせて Visual Studio 2022 RC および Preview 5 もリリースされた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/uikou/items/c96bbd477898a466a191"&gt;[お知らせ] Visual Studio 2022 のローンチが決定しました（日本時間 11/9 1:30 にオンラインイベントで発表）※随時アップデート予定 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://visualstudio.microsoft.com/ja/launch/"&gt;Visual Studio 2022 のローンチ イベント - Visual Studio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/join-us-november-8th-for-the-launch-of-visual-studio-2022/"&gt;Join us November 8 for the Launch of Visual Studio 2022&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;11月9日の &lt;a href="https://www.dotnetconf.net/"&gt;.NET Conf&lt;/a&gt; で .NET 6 がローンチされ、前日の11月8日(日本時間では11月9日)に&lt;a href="https://visualstudio.microsoft.com/ja/launch/"&gt;Visual Studio 2022 のオンラインローンチイベントが行われる&lt;/a&gt;こともアナウンスされた。&lt;/p&gt;
&lt;p&gt;.NET 6 は Visual Studio 2022 をサポートし、Visual Studio 2019 をサポートしないことにも触れている。なお Visual Studio は RC (リリース) と Preview でチャンネルが分かれ、RC は General Availability (GA) 時には製品版へとアップデートされ、Preview チャンネルは次期 Preview 版 (17.1 Preview) へと更新される。&lt;/p&gt;
&lt;p&gt;前回 (RC1) の記事では .NET の基礎機能について触れていたが、今回の記事では C# 10 とテンプレートについてと ARM64 対応について触れている。&lt;/p&gt;
&lt;p&gt;C# 10 については &lt;code&gt;record struct&lt;/code&gt;、&lt;code&gt;global using&lt;/code&gt;、ファイルスコープ 名前空間、&lt;code&gt;const&lt;/code&gt; と文字列補完の強化、拡張プロパティーパターンについてなど。&lt;/p&gt;
&lt;p&gt;プロジェクトテンプレートについては新しいコンソール、Web、Windows Forms 向けに生成されるものについて。その他、暗黙の using と Nullable reference types の有効化、コマンドライン引数が &lt;code&gt;args&lt;/code&gt; としてアクセス可能といった点に触れている。&lt;/p&gt;
&lt;p&gt;ARM64 の対応については &lt;a href="/2021/10/08/updates#net-6-rc2-update-for-macos-and-windows-arm64-issue-21686-dotnetsdk"&gt;2021/10/08 のトピックスで触れたものと同様&lt;/a&gt;のアナウンスがされている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x64 版と ARM64 版のインストールの共存可能になる&lt;/li&gt;
&lt;li&gt;.NET 6 RC2 以降では一度すべての .NET をアンインストールする必要がある&lt;/li&gt;
&lt;li&gt;コマンドラインから ARM64 のコマンドを使用して x64 の開発が行える (逆も)&lt;/li&gt;
&lt;li&gt;パフォーマンス上の理由からも ARM64 SDK を使用してほしい&lt;/li&gt;
&lt;li&gt;SDK は .NET 6+ の ARM64 のみをサポートする&lt;/li&gt;
&lt;li&gt;ランタイムはすべてのバージョンの ARM64, x64 共にサポートする&lt;/li&gt;
&lt;li&gt;.NET 6 RC2 で x64 エミュレーションも含む ARM64 の .NET 6 体験を提供&lt;/li&gt;
&lt;li&gt;.NET Core 3.1, .NET 5 のランタイムも .NET 6 に合わせて更新予定 (ただし時期は未定)&lt;/li&gt;
&lt;li&gt;RC2 ナイトリービルドは現在壊れているため数週間後にリリースされる RC2 を待ってほしい&lt;/li&gt;
&lt;li&gt;.NET 5 SDK for Windows ARM64 は .NET 6 RTM 後に早期終了予定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NET 6 がリリース後は .NET 5 SDK のサポートが終了することに注意が必要。&lt;/p&gt;
&lt;h3 id="visual-studio-2022-for-mac-preview-2-is-now-available"&gt;Visual Studio 2022 for Mac Preview 2 is now available&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-2-is-now-available/"&gt;https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-2-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac Preview 2 がリリースされた。&lt;/p&gt;
&lt;p&gt;.NET 6 RC2 への対応と UI の修正やネイティブ化が進んだ。.NET 6 RC2 は手動でインストールが必要。現時点では Intel 環境のみのサポートで M1 (Apple Silicon) 環境での動作はサポートしていないことに注意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/uikou/items/83393ddf65eaae068bc4"&gt;Visual Studio 2022 for Mac の Public Preview 2 がリリースされました - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#1700-pre2--visual-studio-2022-for-mac-version-170-preview-2-newreleasebutton"&gt;Visual Studio 2022 for Mac v17.0 Preview - Release Notes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="asp.net-core-updates-in.net-6-release-candidate-2"&gt;ASP.NET Core updates in .NET 6 Release Candidate 2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-6-rc-2/"&gt;https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-6-rc-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 RC2 での ASP.NET Core のアップデートについての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/uikou/items/918f49aebb086c6d0b57"&gt;.NET 6 Release Candidate 2 における ASP.NET Core アップデート - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;既存のプロジェクトのアップデート方法や、Blazor WebAssembly のネイティブ依存関係のサポートとその呼び出し、Minimal API の強化について触れている。&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly のネイティブ依存関係のサポートは ネイティブコードを .NET WebAssembly ビルドツール (Emscripten) でリンクすることで .NET WebAssembly から P/Invoke で呼び出すことが可能となるもの。記事では C のソースコードを作成し、それをプロジェクトに含めてビルドし、C# から呼び出す例が掲載されている。依存として使用できるものは C/C++ のソースコードと事前に Emscripten によってコンパイルされている &lt;code&gt;.a&lt;/code&gt;, &lt;code&gt;.o&lt;/code&gt;, &lt;code&gt;.bc&lt;/code&gt;, &lt;code&gt;.wasm&lt;/code&gt; といったファイル。&lt;/p&gt;
&lt;p&gt;また、ネイティブ依存関係を NuGet パッケージにパッケージングする方法や SkiaSharp を例に既に WebAssembly がパッケージングされたものを使用する方法についても触れている。&lt;/p&gt;
&lt;p&gt;Minimal API の強化についてはパラメータバインディングと OpenAPI 対応、アナライザーの追加などが行われた。パラメータバインディングは &lt;code&gt;TryParse&lt;/code&gt; と &lt;code&gt;BindAsync&lt;/code&gt; という名前の静的メソッドをバインド対象の型に定義することで呼び出される仕組みとなっている。&lt;/p&gt;
&lt;h3 id="announcing.net-maui-preview-9"&gt;Announcing .NET MAUI Preview 9&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-9/"&gt;https://devblogs.microsoft.com/dotnet/announcing-net-maui-preview-9/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET MAUI Preview 9 がリリースされた。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BoxView&lt;/code&gt;, &lt;code&gt;IndicatorView&lt;/code&gt;, &lt;code&gt;ImageButton&lt;/code&gt;, &lt;code&gt;WebView&lt;/code&gt; といったコントロールの実装が更新された。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Border&lt;/code&gt; コントロールが新たに導入され、角丸を含むボーダーを描画できるようになった。またレイアウトや画像などのコントロールに影をつける &lt;code&gt;Shadow&lt;/code&gt; も導入された。&lt;/p&gt;
&lt;p&gt;Android においてスタートアップ部分のトレーシングを行うことで部分的に AOT を行い、スタートアップのパフォーマンスを改善するプロファイルが追加された。通常の AOT ではアプリケーション全体をコンパイルするため、パフォーマンスは改善される反面アプリケーションサイズが肥大化してしまう問題があり、スタートアップトレーシングではそのバランスをとることができる。&lt;/p&gt;
&lt;h3 id="release-ef-core-6.0-rc2-dotnetefcore"&gt;Release EF Core 6.0 RC2 · dotnet/efcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/releases/tag/v6.0.0-rc.2.21480.5"&gt;https://github.com/dotnet/efcore/releases/tag/v6.0.0-rc.2.21480.5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 6.0 RC2 がリリースされた。&lt;/p&gt;
&lt;p&gt;RC1 の時点でほぼ feature complete となっていたため、バグ修正が主な変更内容となっている。一点 RC1 時点で積み残しであったカラムの並びを &lt;code&gt;Column&lt;/code&gt; 属性で指定する機能が含まれている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/efcore/issues/10059"&gt;Allow defining column order via [ColumnAttribute.Order] when creating tables · Issue #10059 · dotnet/efcore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-october-2021-updates-5.0.11-and-3.1.20"&gt;.NET October 2021 Updates – 5.0.11 and 3.1.20&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/october-2021-updates/"&gt;https://devblogs.microsoft.com/dotnet/october-2021-updates/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5.0.11 と 3.1.20 がリリースされた。&lt;/p&gt;
&lt;p&gt;バグ修正とセキュリティー対応が行われ、Linux および macOS での &lt;code&gt;System.DirectoryServices.Protocols.LdapConnection&lt;/code&gt; で機密情報がプレーンテキストで送信されてしまうという問題が修正された。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/announcements/issues/202"&gt;Microsoft Security Advisory CVE-2021-41355 | .NET Core Information Disclosure Vulnerability · Issue #202 · dotnet/announcements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="resharper-2021.3-eap4-rider-2021.3-eap4"&gt;ReSharper 2021.3 EAP4 / Rider 2021.3 EAP4&lt;/h3&gt;
&lt;p&gt;ReSharper と Rider の 2021.3 EAP4 がリリースされた。&lt;/p&gt;
&lt;p&gt;ReSherper はコードフォーマットの改善と dotTrace のタイムラインを開く操作やフィルター操作が高速化。&lt;/p&gt;
&lt;p&gt;Rider はフォーマッティングの設定や &lt;code&gt;EditorBrowsable&lt;/code&gt; のサポート追加、Unity の外部パッケージに含まれるファイルの取り扱いや .asmdef のサポート強化、Xamarin の Android レイアウトエディターの強化や AndroidX ライブラリーのサポート強化など。&lt;/p&gt;
&lt;!-- https://twitter.com/resharper/status/1448589029226713091?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;ReSharper 2021.3 EAP4 brings new formatting settings and better performance in dotTrace Timeline snapshots. Read more here: &lt;a href="https://t.co/SdZYUC5gcf"&gt;https://t.co/SdZYUC5gcf&lt;/a&gt; &lt;a href="https://t.co/7QXNS33sJe"&gt;pic.twitter.com/7QXNS33sJe&lt;/a&gt;&lt;/p&gt;— JetBrains ReSharper (@resharper) &lt;a href="https://twitter.com/resharper/status/1448589029226713091?ref_src=twsrc%5Etfw"&gt;October 14, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;!-- https://twitter.com/jetbrainsrider/status/1448600182367662080?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Rider 2021.3 EAP4 is out with new Code Vision metrics and updates for Unity, Xamarin, the debugger, and environment configuration. Learn more and download it here: &lt;a href="https://t.co/2dPfI9RjQI"&gt;https://t.co/2dPfI9RjQI&lt;/a&gt; &lt;a href="https://t.co/cdgNEShjxQ"&gt;pic.twitter.com/cdgNEShjxQ&lt;/a&gt;&lt;/p&gt;— JetBrains Rider (@JetBrainsRider) &lt;a href="https://twitter.com/JetBrainsRider/status/1448600182367662080?ref_src=twsrc%5Etfw"&gt;October 14, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="resharper-2021.2.2-and-rider-2021.2.2-bug-fixes-have-landed-the.net-tools-blog"&gt;ReSharper 2021.2.2 and Rider 2021.2.2 bug fixes have landed | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/13/resharper-and-rider-2021-2-2/"&gt;https://blog.jetbrains.com/dotnet/2021/10/13/resharper-and-rider-2021-2-2/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReSharper 2021.2.2 と Rider 2021.2.2 がリリースされた。&lt;/p&gt;
&lt;p&gt;それぞれバグ修正がメインのリリース。ReSharper では C# 10 の const を使用した文字列補完、Rider ではビルトインのコンソールに関する問題が修正された。&lt;/p&gt;
&lt;h3 id="release-0.10.8-avaloniauiavalonia"&gt;Release 0.10.8 · AvaloniaUI/Avalonia&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/AvaloniaUI/Avalonia/releases/tag/0.10.8"&gt;https://github.com/AvaloniaUI/Avalonia/releases/tag/0.10.8&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Avalonia 0.10.8 がリリースされた。&lt;/p&gt;
&lt;p&gt;タスクトレイアイコンサポートやマスクされたテキストボックスの追加、様々なバグ修正が行われている。&lt;/p&gt;
&lt;h3 id="cake-cake-v1.3.0-released"&gt;Cake - Cake v1.3.0 released&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://cakebuild.net/blog/2021/10/cake-v1.3.0-released"&gt;https://cakebuild.net/blog/2021/10/cake-v1.3.0-released&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Cake 1.3.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;.NET 6 のサポートや Visual Studio 2022、MSBuild 17 への対応が含まれている。その他終了コードを指定してビルドプロセスを終了させる機能やディレクトリが存在する場合に削除する &lt;code&gt;EnsureDirectoryDoesNotExist&lt;/code&gt; の追加など。&lt;/p&gt;
&lt;h3 id="release-ilspy-7.2-preview-1-icsharpcodeilspy"&gt;Release ILSpy 7.2 Preview 1 · icsharpcode/ILSpy&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/icsharpcode/ILSpy/releases/tag/v7.2-preview1"&gt;https://github.com/icsharpcode/ILSpy/releases/tag/v7.2-preview1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ILSpy 7.2 Preview 1 がリリースされた。&lt;/p&gt;
&lt;p&gt;Roslyn 3.11 に合わせたパターン検出、C# 7.0 のパターンマッチングと C# 9 の共変戻り値のサポート、その他修正や機能強化がふくまれる。&lt;/p&gt;
&lt;h3 id="a-preview-of-wsl-in-the-microsoft-store-is-now-available-windows-command-line"&gt;A preview of WSL in the Microsoft Store is now available! - Windows Command Line&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/commandline/a-preview-of-wsl-in-the-microsoft-store-is-now-available/"&gt;https://devblogs.microsoft.com/commandline/a-preview-of-wsl-in-the-microsoft-store-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WSL のプレビュー版が Microsoft Store からインストール可能となった。&lt;/p&gt;
&lt;p&gt;現在の WSL は Windows の機能としてインストールする形だが、WSL のプレビュー版は Microsoft Store から提供される。これにより Windows のアップデートに依存せず WSL の更新が行えるようになるため、新機能の提供サイクルを早められるとしている。将来的には WSL のインストールは Microsoft Store からにしたいとのこと。&lt;/p&gt;
&lt;p&gt;現在のプレビューでは WSLg や VHD のマウント、カーネルアップデートなどが含まれている。&lt;/p&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="dotnet-centralized-package-versioning"&gt;dotnet centralized package versioning&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/kritner/dotnet-centralized-package-versioning-4i41"&gt;https://dev.to/kritner/dotnet-centralized-package-versioning-4i41&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NuGet パッケージのバージョンを一か所 (&lt;code&gt;Directory.Packages.props&lt;/code&gt;) に定義することで、リポジトリワイドでパッケージのバージョンを統一する &lt;code&gt;&amp;lt;ManagePackageVersionsCentrally&amp;gt;&lt;/code&gt; についての記事。&lt;/p&gt;
&lt;p&gt;プレビューな機能ではあるが &lt;code&gt;Directory.Packages.props&lt;/code&gt; を作成して、プロジェクト側に &lt;code&gt;&amp;lt;ManagePackageVersionsCentrally&amp;gt;true&amp;lt;/ManagePackageVersionsCentrally&amp;gt;&lt;/code&gt; を指定することで使用できる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/NuGet/Home/wiki/Centrally-managing-NuGet-package-versions"&gt;Centrally managing NuGet package versions · NuGet/Home Wiki&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spanmemoryintptrarray-qiita"&gt;SpanとかMemoryとかIntPtrとかArrayの変換方法チートシート - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/kenichiuda/items/510a3443181e3602e2eb"&gt;https://qiita.com/kenichiuda/items/510a3443181e3602e2eb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Span や Memory, IntPtr や配列といったものを相互で変換する方法についてのチートシート。&lt;/p&gt;
&lt;h3 id="prime-your-flux-capacitor-sql-server-temporal-tables-in-ef-core-6.0"&gt;Prime your flux capacitor: SQL Server temporal tables in EF Core 6.0&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/prime-your-flux-capacitor-sql-server-temporal-tables-in-ef-core-6-0/"&gt;https://devblogs.microsoft.com/dotnet/prime-your-flux-capacitor-sql-server-temporal-tables-in-ef-core-6-0/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 6.0 でサポートされた、SQL Server のテンポラル テーブル (バージョニング) を扱うことについての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/sql/relational-databases/tables/temporal-tables?view=sql-server-ver15"&gt;テンポラル テーブル - SQL Server | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-6"&gt;.NET 6 で動的にコンポーネントをレンダリングする機能が追加されたので試してみる&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/okazuki/articles/blazor-dynamic-component"&gt;https://zenn.dev/okazuki/articles/blazor-dynamic-component&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Blazor で追加された、型を指定して動的にコンポーネントをレンダリングする &lt;code&gt;DynamicComponent&lt;/code&gt; コンポーネントについての記事。&lt;/p&gt;
&lt;h3 id="javascript-equivalent-of-c-out-keyword"&gt;JavaScript equivalent of C# 'out' keyword&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/sincovschi/javascript-equivalent-of-c-out-keyword-2l2b"&gt;https://dev.to/sincovschi/javascript-equivalent-of-c-out-keyword-2l2b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JavaScript を書く際に C# の &lt;code&gt;out&lt;/code&gt; キーワードと同じことをするにはどうすればいいかという記事。&lt;/p&gt;
&lt;p&gt;例えば &lt;code&gt;TryParse&lt;/code&gt; に相当する関数を書くようなケースの書き方。&lt;code&gt;null&lt;/code&gt; を返す方法、&lt;code&gt;{ isNumber, number }&lt;/code&gt; のようにオブジェクトで返す方法、オブジェクトを渡すことで書き換える方法、他にもトリッキーな方法について触れている。&lt;/p&gt;
&lt;h3 id="dotnet-code-generation-overview-by-example"&gt;Dotnet code generation overview by example&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/maximtkachenko/dotnet-code-generation-overview-by-example-1m16"&gt;https://dev.to/maximtkachenko/dotnet-code-generation-overview-by-example-1m16&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;簡単なパーサーを例としたコード生成を行う手法についての比較の記事。&lt;/p&gt;
&lt;p&gt;IL Emit, Expression Tree, Reflection, Sigil, Roslyn, Source Generator, 手書きといったパターンでのコード例とパーサーの生成時間、呼び出しコストなどの比較をしている。&lt;/p&gt;
&lt;h3 id="worlds-smallest-c-program-featuring-n"&gt;World's Smallest C# Program (featuring &lt;code&gt;N&lt;/code&gt;)&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://nietras.com/2021/10/09/worlds-smallest-csharp-program/"&gt;https://nietras.com/2021/10/09/worlds-smallest-csharp-program/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET で最小のプログラムはどうなるのかという記事。&lt;/p&gt;
&lt;p&gt;結論としては .NET 5 以降と C# 9.0 以降であれば &lt;code&gt;{}&lt;/code&gt; の2文字で何もしないプログラムを記述でき、.NET 6 と C# 10 以降であれば &lt;code&gt;N();&lt;/code&gt; という4文字で何かをするプログラムを記述できる。記事ではそれぞれにたどり着くまでの経過と、.NET 6 で何かする &lt;code&gt;N();&lt;/code&gt; を記述できるようになるまでのパッケージ等について書かれている。&lt;/p&gt;
&lt;h3 id="testing-asp.net-core-web-applications-with-webapplicationfactory-its-all-about-tech"&gt;Testing ASP.NET Core web applications with WebApplicationFactory - It’s all about tech&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://renatogolia.com/2021/10/11/testing-asp-net-core-web-applications-with-webapplicationfactory/"&gt;https://renatogolia.com/2021/10/11/testing-asp-net-core-web-applications-with-webapplicationfactory/&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="bring-vs-code-themes-to-visual-studio-2022-visual-studio-blog"&gt;Bring VS Code themes to Visual Studio 2022! - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/vs-code-themes-in-vs/"&gt;https://devblogs.microsoft.com/visualstudio/vs-code-themes-in-vs/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio Code のテーマを Visual Studio 2022 にコンバートするという記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/theme-converter-for-vs"&gt;microsoft/theme-converter-for-vs: CLI tool that allows you to convert your VS Code color theme to a VS 2022 color theme.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="copy-code-reference-in-resharper-and-rider-2021.3-eap-the.net-tools-blog"&gt;Copy Code Reference in ReSharper and Rider 2021.3 EAP | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/11/copy-code-reference-in-resharper-and-rider-2021-3-eap/"&gt;https://blog.jetbrains.com/dotnet/2021/10/11/copy-code-reference-in-resharper-and-rider-2021-3-eap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReSharper と Rider 2021.3 EAP に搭載された、コードの参照をコピーする機能についての記事。&lt;/p&gt;
&lt;p&gt;コードの参照は FQN (&lt;code&gt;Namespace.Type.Member&lt;/code&gt; の形式) や XML ドキュメントの ID でのコピーに加え、カスタムのパターンに展開する方法についても触れている。&lt;/p&gt;
&lt;h3 id="supporting-ef-core-migrations-with-webapplicationbuilder-exploring.net-core-6-part-5"&gt;Supporting EF Core migrations with WebApplicationBuilder: Exploring .NET Core 6 - Part 5&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-5-supporting-ef-core-tools-with-webapplicationbuilder/"&gt;https://andrewlock.net/exploring-dotnet-6-part-5-supporting-ef-core-tools-with-webapplicationbuilder/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Entity Framework Core のマイグレーションをはじめとするツールが &lt;code&gt;IServiceProvider&lt;/code&gt; を取得する流れについての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WebApplicationBuilder&lt;/code&gt; のような Minimal API に対応するために、&lt;code&gt;DiagnosticSource&lt;/code&gt; を駆使して &lt;code&gt;IHost&lt;/code&gt; の生成をとらえているといった話。&lt;/p&gt;
&lt;h3 id="reading-asynclocal-values-from-a-memory-dump"&gt;Reading AsyncLocal values from a memory dump&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://kevingosse.medium.com/reading-asynclocal-values-from-a-memory-dump-8be356a46b29"&gt;https://kevingosse.medium.com/reading-asynclocal-values-from-a-memory-dump-8be356a46b29&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AsyncLocal&amp;lt;T&amp;gt;&lt;/code&gt; が内部ではどのように格納されているのかについての記事。&lt;/p&gt;
&lt;p&gt;実際にメモリーダンプを取って WinDbg で読み取る方法や ClrMD で読み取ってみるといったことをしている。&lt;/p&gt;
&lt;h3 id="refactor-functional-tests-to-support-minimal-web-apis"&gt;Refactor Functional Tests to support Minimal Web APIs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/this-is-learning/refactor-functional-tests-to-support-minimal-web-apis-4p2e"&gt;https://dev.to/this-is-learning/refactor-functional-tests-to-support-minimal-web-apis-4p2e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Minimal API を使用した ASP.NET Core アプリのファンクショナルテストを行う方法についての記事。&lt;/p&gt;
&lt;h3 id="try-out.net-6-inside-your-own-development-environment-built-with-devcontainers-docker-and-vscode"&gt;Try out .NET 6 inside your own development environment built with devcontainers, docker, and vscode&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/nikiforovall/try-out-net-6-inside-your-own-development-environment-built-with-devcontainers-docker-and-vscode-4fe4"&gt;https://dev.to/nikiforovall/try-out-net-6-inside-your-own-development-environment-built-with-devcontainers-docker-and-vscode-4fe4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio Code の Devcontainer を使って .NET 6 を試すという記事。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="github-jpobstclassic-dotnet-templates.net-6-project-templates-that-do-not-use-top-level-statements"&gt;GitHub - jpobst/classic-dotnet-templates: .NET 6+ project templates that do not use top level statements&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/jpobst/classic-dotnet-templates"&gt;https://github.com/jpobst/classic-dotnet-templates&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 向けの Top-level Statements を使用しない、昔ながらのプロジェクトを作成するテンプレート。&lt;/p&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="internalsvisibleto-msbuild-msbuild"&gt;InternalsVisibleTo - MSBuild プロジェクトの共通項目 - MSBuild&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/visualstudio/msbuild/common-msbuild-project-items?view=vs-2019#internalsvisibleto"&gt;https://docs.microsoft.com/ja-jp/visualstudio/msbuild/common-msbuild-project-items?view=vs-2019#internalsvisibleto&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core または .NET 5 SDK のプロジェクトでは &lt;code&gt;InternalsVisibleTo&lt;/code&gt; をプロジェクトに定義することでビルド時にアセンブリの属性を出力する。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-xml"&gt;&amp;lt;ItemGroup&amp;gt;
    &amp;lt;InternalsVisibleTo Include="Nantoka.Test" /&amp;gt;
&amp;lt;/ItemGroup&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="performancemicrobenchmark-design-guidelines.md-at-main-dotnetperformance"&gt;performance/microbenchmark-design-guidelines.md at main · dotnet/performance&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/performance/blob/main/docs/microbenchmark-design-guidelines.md"&gt;https://github.com/dotnet/performance/blob/main/docs/microbenchmark-design-guidelines.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET ランタイムのマイクロベンチマークのガイドライン。&lt;/p&gt;
&lt;h3 id="carbon"&gt;Carbon&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://carbon.now.sh/"&gt;https://carbon.now.sh/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ソースコードを画像にしてシェアできるサービス。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/9012/137476689-d20dd453-0b4f-4388-9592-3489e12d4561.png" alt="carbon"&gt;&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/egorbo/status/1447221009950593032?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;This .NET benchmark is 4x faster on M1 Rosetta (x64 emulation) then on the same M1 but natively (arm64) 🙃 &lt;a href="https://t.co/9gr8kt9Zth"&gt;pic.twitter.com/9gr8kt9Zth&lt;/a&gt;&lt;/p&gt;— Egor Bogatov (@EgorBo) &lt;a href="https://twitter.com/EgorBo/status/1447221009950593032?ref_src=twsrc%5Etfw"&gt;October 10, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;メモリーオーダーリングの違いで M1 の Rosetta (x64 エミュレーション) のほうが M1 (arm64) ネイティブよりも速くなってしまうケースがあるという話。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60232"&gt;[arm64] Volatile.Read/Write is 2x faster than "volatile" loads/stores · Issue #60232 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1446893764694380548?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;.NET 6 introduces a new Reflection API for nullability information.&lt;br&gt;&lt;br&gt;It provides nullability information and context from reflection members:&lt;br&gt;• ParameterInfo&lt;br&gt;• FieldInfo&lt;br&gt;• PropertyInfo&lt;br&gt;• EventInfo&lt;a href="https://twitter.com/hashtag/dotnet6?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet6&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/reflection?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#reflection&lt;/a&gt; &lt;a href="https://t.co/GbW3uIHIBF"&gt;pic.twitter.com/GbW3uIHIBF&lt;/a&gt;&lt;/p&gt;— Oleg Kyrylchuk (@okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1446893764694380548?ref_src=twsrc%5Etfw"&gt;October 9, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 で導入された Nullability を取得する Reflection API について。&lt;/p&gt;
&lt;!-- https://twitter.com/james_m_south/status/1447010033510744066?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Really looking forward to the coming year of working on ImageSharp. Once we ship V2 which will include some awesome features and performance improvements the focus will switch immediately to V3 which will drop all the legacy target frameworks.&lt;/p&gt;— JimBobSquarePants (@James_M_South) &lt;a href="https://twitter.com/James_M_South/status/1447010033510744066?ref_src=twsrc%5Etfw"&gt;October 10, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;ImageSharp は V2 をリリースしたのち V3 にフォーカスし、レガシーフレームワークのサポートを削除する予定 (.NET Core 3.1 が最低ライン) とのこと。&lt;/p&gt;
&lt;!-- https://twitter.com/sergiopedri/status/1448397332572213255?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Our DevDiv friends have been going absolutely crazy this hackaton! This stuff is now checked in (not in main):&lt;br&gt;- stackalloc for all Ts&lt;br&gt;- Constant ReadOnlySpan&amp;lt;T&amp;gt; for all primitives&lt;br&gt;- ref fields (!)&lt;br&gt;- Generic *everything* (!!)&lt;br&gt;- refs to refs&lt;br&gt;Don't wake me up now 🚀&lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt;&lt;/p&gt;— Sergio Pedri (@SergioPedri) &lt;a href="https://twitter.com/SergioPedri/status/1448397332572213255?ref_src=twsrc%5Etfw"&gt;October 13, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;DevDiv でハッカソンをやっているという話。実際幾つかのリポジトリにハッカソンのようなブランチとその PR が上がっているのでそのことのよう。Spec がないようなものもあり、デモ用のブランチにマージされているので PoC を兼ねている模様。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/57104"&gt;Support params SpanT by cston · Pull Request #57104 · dotnet/roslyn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/57123"&gt;RuntimeHelpers.CreateSpan optimization for stackalloc by svick · Pull Request #57123 · dotnet/roslyn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/57135"&gt;Support 'ref' type arguments in delegates by RikkiGibson · Pull Request #57135 · dotnet/roslyn&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60303"&gt;Checkin the work for coreclr around stackalloc, ref fields and arbitrary generics to hackathon tree by davidwrighton · Pull Request #60303 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60320"&gt;Constraint generic work by davidwrighton · Pull Request #60320 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="add-simpler-way-to-get-the-old-style-console-templates-issue-3985-dotnettemplating"&gt;Add simpler way to get the "old style" console templates · Issue #3985 · dotnet/templating&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/templating/issues/3985"&gt;https://github.com/dotnet/templating/issues/3985&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 とそれ以前のスタイルのコンソールアプリケーションテンプレートを使いたいという話の Issue。現時点では .NET 6 GA にそのようなものは含めるつもりはないとのこと。&lt;/p&gt;
&lt;h3 id="file.alltext-optimizations-by-adamsitnik-pull-request-58167-dotnetruntime"&gt;File.&lt;em&gt;AllText&lt;/em&gt; optimizations by adamsitnik · Pull Request #58167 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/58167"&gt;https://github.com/dotnet/runtime/pull/58167&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File.*AllText*&lt;/code&gt; メソッドの実装を最適化することでメモリーアロケーションと処理時間を削減するという PR。&lt;code&gt;StreamWriter&lt;/code&gt;/&lt;code&gt;FileStream&lt;/code&gt; を介さないようにすることでメモリーの削減、大き目のバッファの確保とファイルシステムの事前アロケーションによって CPU 負荷を削減。&lt;/p&gt;
&lt;h3 id="add-support-for-non-seekable-files-to-randomaccess-by-adamsitnik-pull-request-58506-dotnetruntime"&gt;Add support for non-seekable files to RandomAccess by adamsitnik · Pull Request #58506 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/58506"&gt;https://github.com/dotnet/runtime/pull/58506&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;シークできないハンドル(ネットワークや名前付きパイプなど)に対して &lt;code&gt;RandomAccess&lt;/code&gt; クラスの &lt;code&gt;Write&lt;/code&gt;/&lt;code&gt;Read&lt;/code&gt; を使用できるようにする PR (なぜかクローズされた)。&lt;/p&gt;
&lt;h3 id="plaintextmvc-benchmark-is-slow-on-arm64-issue-60166-dotnetruntime"&gt;PlaintextMVC benchmark is slow on arm64 · Issue #60166 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60166"&gt;https://github.com/dotnet/runtime/issues/60166&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ARM64 の PlaintextMVC ベンチマーク(とその他ベンチマーク)が x64 に比べて遅いという Issue。プロセッサーのキャッシュサイズによって決まる Gen0 のサイズによって GC が影響を受けているといった話。&lt;/p&gt;
&lt;h3 id="is-new-crashes-csc.exe-issue-57088-dotnetroslyn"&gt;"is new()" crashes csc.exe · Issue #57088 · dotnet/roslyn&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/roslyn/issues/57088"&gt;https://github.com/dotnet/roslyn/issues/57088&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;T is new()&lt;/code&gt; で C# コンパイラーがクラッシュするという Issue (Visual Studio もエラーを吐く)。17.1 で修正される可能性がある。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;void Foo&amp;lt;T&amp;gt;()
{
    if (T is new ())
    { }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="how-to-properly-benchmark-filestream.write-vs-writefile-issue-60268-dotnetruntime"&gt;How to properly benchmark FileStream.Write vs WriteFile? · Issue #60268 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60268"&gt;https://github.com/dotnet/runtime/issues/60268&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Win32 API の &lt;code&gt;WriteFile&lt;/code&gt; と &lt;code&gt;FileStream.Write&lt;/code&gt; では &lt;code&gt;FileStream.Write&lt;/code&gt; のほうが遅い、という話が元々の Issue。&lt;/p&gt;
&lt;p&gt;コメントで BenchmarkDotNet でこうすると良いし、その結果特に遅くないという結果が出たため件名が変更された。他にも Issue を立てた人のシナリオであれば .NET 6 で Preallocaiton を使用したり、バッファリングをオフにすると良いといった話も。&lt;/p&gt;
&lt;h3 id="make-upgrade-install-new-host-first-then-uninstall-old-by-ericstj-pull-request-60307-dotnetruntime"&gt;Make upgrade install new host first, then uninstall old by ericstj · Pull Request #60307 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60307"&gt;https://github.com/dotnet/runtime/pull/60307&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dotnet コマンドへのパスは PATH の後ろに追加されるため、x86 と x64 の SDK がインストールされたような環境でアップグレードインストールすると x86 のものが残り、x64 環境においても x86 版が使用されてしまう問題。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sdk/issues/22047"&gt;[Known Issue]  Installing VS2022 Preview 5.0 and/or .NET 6.0 RC2 results in x86 dotnet on the PATH · Issue #22047 · dotnet/sdk&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60317"&gt;[release/6.0] Make upgrade install new host first, then uninstall old by github-actions[bot] · Pull Request #60317 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="lateapexearlyspeed-issue-30778-create-method-tryreadexact.by-lateapexearlyspeed-pull-request-57921-dotnetruntime"&gt;lateapexearlyspeed-issue-30778 Create method: TryReadExact(). by lateapexearlyspeed · Pull Request #57921 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/57921"&gt;https://github.com/dotnet/runtime/pull/57921&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;SequenceReader&amp;lt;T&amp;gt;&lt;/code&gt; に指定したサイズを読むことを試みる &lt;code&gt;TryReadExact&lt;/code&gt; を追加する PR。.NET 7 に入る予定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/30778"&gt;API Proposal: SequenceReader&lt;t&gt;.TryRead overloads to read a specified number of elements · Issue #30778 · dotnet/runtime&lt;/t&gt;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="implement-iasyncenumerablet.toblockingenumerable-by-eiriktsarpalis-pull-request-60363-dotnetruntime"&gt;Implement IAsyncEnumerable&amp;lt;T&amp;gt;.ToBlockingEnumerable by eiriktsarpalis · Pull Request #60363 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/60363"&gt;https://github.com/dotnet/runtime/pull/60363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; をブロッキングな &lt;code&gt;IEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; に変換する拡張メソッドの追加 PR と提案 Issue。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/60106"&gt;[API Proposal]: Add an IAsyncEnumerable&amp;lt;T&amp;gt;.ToEnumerable extension method. · Issue #60106 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-10-08: .NETのクラスライブラリ設計 改訂新版, Umbraco 9, Visual Studio 2022 for Mac Preview 1</title>
			<link>/2021/10/08/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/10/08/updates</guid>
			<pubDate>Fri, 08 Oct 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://www.nikkeibp.co.jp/atclpubmkt/book/21/S80040/"&gt;.NETのクラスライブラリ設計 改訂新版&lt;/a&gt; (&lt;a href="https://www.amazon.co.jp/gp/product/4296080040"&gt;Amazon&lt;/a&gt;) が10/7に発売されました。&lt;/p&gt;
&lt;p&gt;この本は .NET Framework を開発した中で出てきたクラスライブラリーを作る上でのノウハウをまとめたベストプラクティス集のようなものです。&lt;/p&gt;
&lt;p&gt;クラスライブラリーを設計するうえでどういった部分に気を付ければよいのか、何をすべきで何をすべきではないのかといったものが書かれているのですが、この本の特徴的な部分は .NET 開発チームの声が注釈としてたくさん入っていることです。そこには .NET でなぜその選択をしたのかといった理由をはじめ、時には後悔なども書かれており、それを読むだけでも楽しめます。&lt;/p&gt;
&lt;p&gt;前の翻訳版は .NET 開発者の中では知る人ぞ知るといった本だったのですが既に12年が経過し内容も古くなっていたこともあり、待望の改訂となりました。この改訂では .NET Framework から .NET Core 世代に変化したような時代に合わせた内容となっています。例えば C# 5 以降に関する記述や Task ベースの非同期、&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; などを含むバッファパターンについてなど多くの項目が増えています。&lt;/p&gt;
&lt;p&gt;また付録もボリュームがあり、コーディング規約や破壊的変更について、さらには日本語翻訳版独自の翻訳者と監訳者による座談会風の雑感なども収録されて読み応えが増しています。&lt;/p&gt;
&lt;p&gt;今では NuGet や GitHub といったものが一般的になりライブラリーを作る人が増えたためそういった方々にお勧めできるのはもちろん、クラスライブラリーに限らずアプリケーションのコードにおいても一貫性や使いやすさといった面で多くの .NET 開発の上で参考になる一冊だと思います。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://umbraco.com/blog/umbraco-9-release/"&gt;Umbraco 9&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;Umbraco は .NET 界の中では比較的歴史のあるオープンソースの CMS です。その Umbraco が 9 で .NET Framework から .NET 5 への移行を完了しています。これによりパフォーマンスの向上や開発体験の向上、マルチプラットフォームでの動作が可能となるといった恩恵を受けられるようになったそうです。&lt;/p&gt;
&lt;p&gt;Umbraco も実際に .NET Core 世代に移行を検討してから年単位で時間がかかったようなので、先日の Paint.NET のように歴史のあるプロジェクトが .NET 5 以降に移行するものがそろそろ増え始めるのかもしれません。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-1-is-now-available/"&gt;Visual Studio 2022 for Mac Preview 1&lt;/a&gt; がリリースされました。先日まで Private Preview だったのですが Public Preview として一般公開されました。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac は目玉として UI の macOS ネイティブ化が進められています。これにより UI のフィーリング(見た目や挙動)が macOS のものと近くなりパフォーマンスと安定性も向上するとしています。またアクセシビリティ面でも VoiceOver の対応といった利点があります。&lt;/p&gt;
&lt;p&gt;Preview 1 では主に C# 10 と .NET 6 SDK 対応が含まれており、MAUI の対応は後ほどとなるようです。全体的な UI の再構築を行っていることもあり、現時点では設定画面や一部機能がまだ不完全なところが多くある(未実装や項目が減っている)のでその点は注意が必要です。&lt;/p&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="umbraco-9-release-umbraco-powered-by.net-5-asp.net-core"&gt;Umbraco 9 release | Umbraco powered by .NET 5 &amp;amp; ASP.NET Core&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://umbraco.com/blog/umbraco-9-release/"&gt;https://umbraco.com/blog/umbraco-9-release/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オープンソースの CMS の Umbraco 9 がリリースされた。&lt;/p&gt;
&lt;p&gt;2年前からスタートした .NET Framework から .NET 5 および ASP.NET Core へ移行が完了。&lt;/p&gt;
&lt;p&gt;.NET 5 へ移行したことによりパフォーマンス向上や Microsoft.Extensions.DependencyInjection や Configuration を元にしたアーキテクチャへの変更による開発しやすさの向上、Windows 以外のプラットフォームのサポートが可能となった。&lt;/p&gt;
&lt;h3 id="visual-studio-2022-for-mac-preview-1-is-now-available-visual-studio-blog"&gt;Visual Studio 2022 for Mac Preview 1 is now available! - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-1-is-now-available/"&gt;https://devblogs.microsoft.com/visualstudio/visual-studio-2022-for-mac-preview-1-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac の Preview 1 がリリースされた。Private Preview から Public Preview となったことで登録不要でインストール可能となった。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac は UI の macOS ネイティブへの刷新がフォーカスされている。これによりパフォーマンスと安定性の向上、操作や表示のフィーリングの改善、アクセシビリティの対応 (VoiceOver) といった恩恵を受けられる。&lt;/p&gt;
&lt;p&gt;その他 .NET 6 と C# 10 への対応や Git ツーリングの改善などが含まれている。&lt;/p&gt;
&lt;p&gt;Preview 1 では多くの機能が不完全であり(例えば設定画面等)、MAUI への対応ものちの Preview にて提供予定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/uikou/items/ae0a54d18b0557f8477e"&gt;Visual Studio 2022 for Mac Preview 1 がリリースされました - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ml.net-updates-announcing-notebooks-in-visual-studio.net-blog"&gt;ML.NET Updates &amp;amp; Announcing Notebooks in Visual Studio - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/ml-net-and-model-builder-october-updates/"&gt;https://devblogs.microsoft.com/dotnet/ml-net-and-model-builder-october-updates/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 に .NET のインタラクティブなノートブックを統合する拡張がリリースされた。&lt;/p&gt;
&lt;p&gt;以前より .NET Interactive Notebooks や Visual Studio Code 拡張といったものが提供されていたがその Visual Studio 向けの拡張。.NET のインタラクティブなノートブックは ML.NET の Model Builder や .ipynb ファイルを直接作成することで使用可能。&lt;/p&gt;
&lt;p&gt;その他 ML.NET のアップデートや、以前フィードバックされていた ML.NET に関する懸念点に関する進捗についてにも触れている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://marketplace.visualstudio.com/items?itemName=MLNET.notebook"&gt;Notebook Editor - Visual Studio Marketplace&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-1.4.0-beta.4-mysql-netmysqlconnector"&gt;Release 1.4.0-beta.4 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/1.4.0-beta.4"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/1.4.0-beta.4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector の 1.4.0-beta.4 がリリース。&lt;/p&gt;
&lt;p&gt;不具合の修正のほか &lt;code&gt;ConnectionIdlePingTime&lt;/code&gt; オプションの削除など。&lt;/p&gt;
&lt;h3 id="net-6-rc2-update-for-macos-and-windows-arm64-issue-21686-dotnetsdk"&gt;.NET 6 RC2 Update for macOS and Windows Arm64 · Issue #21686 · dotnet/sdk&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/sdk/issues/21686"&gt;https://github.com/dotnet/sdk/issues/21686&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 RC2 で macOS と Windows の ARM64 対応がほぼ完了したとのこと。&lt;/p&gt;
&lt;p&gt;それにより .NET 6 RC2 以降での macOS と Windows の ARM64 対応は次のような状況となる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;x64 版と ARM64 版のインストールの共存可能になる&lt;/li&gt;
&lt;li&gt;.NET 6 RC2 以降では一度すべての .NET をアンインストールする必要がある&lt;/li&gt;
&lt;li&gt;コマンドラインから ARM64 のコマンドを使用して x64 の開発が行える (逆も)&lt;/li&gt;
&lt;li&gt;パフォーマンス上の理由からも ARM64 SDK を使用してほしい&lt;/li&gt;
&lt;li&gt;SDK は .NET 6+ の ARM64 のみをサポートする&lt;/li&gt;
&lt;li&gt;ランタイムはすべてのバージョンの ARM64, x64 共にサポートする&lt;/li&gt;
&lt;li&gt;.NET 6 RC2 で x64 エミュレーションも含む ARM64 の .NET 6 体験を提供&lt;/li&gt;
&lt;li&gt;.NET Core 3.1, .NET 5 のランタイムも .NET 6 に合わせて更新予定 (ただし時期は未定)&lt;/li&gt;
&lt;li&gt;RC2 ナイトリービルドは現在壊れているため数週間後にリリースされる RC2 を待ってほしい&lt;/li&gt;
&lt;li&gt;.NET 5 SDK for Windows ARM64 は .NET 6 RTM 後に早期終了予定&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他にもインストールした際にネイティブアーキテクチャーの dotnet コマンドにのみ PATH が通ることやアーキテクチャーを指定する &lt;code&gt;-a&lt;/code&gt; 引数が追加されたこと、Windows 11 においては特別な対応がないことなどにも触れている。&lt;/p&gt;
&lt;h3 id="release-release-v2.40.0-grpcgrpc-dotnet"&gt;Release Release v2.40.0 · grpc/grpc-dotnet&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/grpc/grpc-dotnet/releases/tag/v2.40.0"&gt;https://github.com/grpc/grpc-dotnet/releases/tag/v2.40.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Grpc.Net の v2.40.0 がリリースされた。&lt;/p&gt;
&lt;p&gt;幾つかの不具合対応、ターゲットフレームワークとして .NET 6 が追加、ProtoBuf のバージョンアップなど。&lt;/p&gt;
&lt;h3 id="release-diagnostics-release-v5.0.248003-dotnetdiagnostics"&gt;Release Diagnostics Release - v5.0.248003 · dotnet/diagnostics&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/diagnostics/releases/tag/v5.0.248003"&gt;https://github.com/dotnet/diagnostics/releases/tag/v5.0.248003&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Diagnostics ツールの v5.0.248003 がリリースされた。&lt;/p&gt;
&lt;p&gt;各種バグの修正や Microsoft.Diagnostics.NetCore.Client (Diagnostics API) の非同期対応など。&lt;/p&gt;
&lt;p&gt;その他 .NET 6 で PDB を配置していなかった場合にメタデータトークンのオフセットがスタックトレースに出力できるようになったが、それから元のコードの位置を割り出す &lt;code&gt;symbolicate&lt;/code&gt; コマンドが &lt;code&gt;dotnet-stack&lt;/code&gt; に実装された。なおメタデータトークンのオフセットを出力する機能はデフォルトで無効化されているため、&lt;code&gt;Switch.System.Diagnostics.StackTrace.ShowILOffsets&lt;/code&gt; AppContext スイッチを有効にする必要がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/diagnostics/pull/2436"&gt;Add new 'symbolicate' commands to dotnet-stack by JongHeonChoi · Pull Request #2436 · dotnet/diagnostics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/44013"&gt;Add IL Offset and Method Token to stacktrace by wscho77 · Pull Request #44013 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/56780"&gt;disable token info in traces. by mangod9 · Pull Request #56780 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="net-core-api-in-azure-container-instances-secured-with-https-using-caddy2"&gt;.NET Core API in Azure Container Instances, secured with HTTPS using Caddy2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/kedzior_io/net-core-api-in-azure-container-instances-secured-with-https-using-caddy2-32jm"&gt;https://dev.to/kedzior_io/net-core-api-in-azure-container-instances-secured-with-https-using-caddy2-32jm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core API アプリケーションを Azure Container Instances 上で動かすときに Caddy2 をセットで使用することで簡単に HTTPS 対応をするという記事。&lt;/p&gt;
&lt;h3 id="asp.net-mvc5.net-frameworkmicrosoft.extensions.dependencyinjection-qiita"&gt;ASP.NET MVC5(.NET Framework)にMicrosoft.Extensions.DependencyInjectionを導入する - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/jun1s/items/cedf917a9de98830e97c"&gt;https://qiita.com/jun1s/items/cedf917a9de98830e97c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Framework の ASP.NET MVC 5 に Microsoft.Extensions.DependencyInjection を導入する方法についての記事。&lt;/p&gt;
&lt;p&gt;DependencyResolver に登録するためのアダプターとなるライブラリーを使用することで、ASP.NET MVC のコントローラーでもコンストラクターインジェクションやメソッドパラメーターインジェクションを行えるようにする。&lt;/p&gt;
&lt;h3 id="differences-between-hashtable-vs-dictonary-vs-concurrentdictionary-vs-immutabledictionary"&gt;Differences between Hashtable vs Dictonary vs ConcurrentDictionary vs ImmutableDictionary&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/differences-between-hashtable-vs-dictonary-vs-concurrentdictionary-vs-immutabledictionary"&gt;https://www.hanselman.com/blog/differences-between-hashtable-vs-dictonary-vs-concurrentdictionary-vs-immutabledictionary&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET はマップ/辞書を実現するクラスが &lt;code&gt;Hashtable&lt;/code&gt; と &lt;code&gt;Dictonary&lt;/code&gt; と &lt;code&gt;ConcurrentDictionary&lt;/code&gt; と &lt;code&gt;ImmutableDictionary&lt;/code&gt; 4種類あるがどう違うのかの記事。David Fowler 氏のツイートから。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Hashtable&lt;/code&gt; は .NET 1.x 世代の弱い型付けであり、box 化も発生するため .NET 2.0 以降では &lt;code&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; に変わられた。&lt;/p&gt;
&lt;p&gt;スレッドセーフティーを考慮する必要があるのであれば &lt;code&gt;System.Collections.Concurrent&lt;/code&gt; か&lt;code&gt;System.Collections.Immutable&lt;/code&gt; を使用することになる。それを踏まえてそれぞれ次のような違いがある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;ConcurrentDictionary&lt;/code&gt;: 並列実行時の読み取りは良好、作成は重い、更新速度は遅い&lt;/li&gt;
&lt;li&gt;ロックあり &lt;code&gt;Dictionary&lt;/code&gt;: 読み取りは遅く、作成は軽量、更新速度はまあまあ&lt;/li&gt;
&lt;li&gt;イミュータブルな &lt;code&gt;Dictionary&lt;/code&gt;: 読み取りは最速、作成は軽量、 更新速度はとても遅い
&lt;ul&gt;
&lt;li&gt;イミュータブルな Dictionary とは &lt;code&gt;var newDict = new Dictionary&amp;lt;T,K&amp;gt;(oldDict); newDict.Add(key, value);&lt;/code&gt; のようにコピーする方式&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Hashtable&lt;/code&gt;: 読み取りは良好、作成は Dictionary と同様に軽量、更新は重く、ジェネリクスもない&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ImmutableDictionary&lt;/code&gt;: 読み取りは遅め、ロックは不要ただし更新時にアロケーションが多い&lt;/li&gt;
&lt;/ul&gt;
&lt;!-- https://twitter.com/davidfowl/status/1444467842418548737?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;.NET has 4 built-in dictionary/map types:&lt;br&gt;- Hashtable&lt;br&gt;- Dictionary&lt;br&gt;- ConcurrentDictionary&lt;br&gt;- ImmutableDictionary&lt;br&gt;&lt;br&gt;There’s no guidance on when to use what, mostly individual documentation on each implementation.&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧🇺🇸💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1444467842418548737?ref_src=twsrc%5Etfw"&gt;October 3, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/archive/msdn-magazine/2017/march/net-framework-immutable-collections"&gt;.NET Framework - 不変コレクション | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/standard/collections/thread-safe/when-to-use-a-thread-safe-collection"&gt;スレッドセーフなコレクションを使用する状況 | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/premier-developer/read-only-frozen-and-immutable-collections/"&gt;Read only, frozen, and immutable collections - Developer Support&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="spaphp-conference-japan-2021"&gt;SPAセキュリティ入門～PHP Conference Japan 2021&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.slideshare.net/ockeghem/phpconf2021spasecurity"&gt;https://www.slideshare.net/ockeghem/phpconf2021spasecurity&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Single Page Application におけるフロントエンドを中心としたサーバーとのセキュリティーについてのスライド。&lt;/p&gt;
&lt;p&gt;JWT をセッションに使うことについてや、Cookie/localStorage について、CORS などについて落とし穴と共に解説している。&lt;/p&gt;
&lt;h3 id="net-annotated-monthly-october-2021-the.net-tools-blog"&gt;.NET Annotated Monthly | October 2021 | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/10/05/net-annotated-monthly-october-2021/"&gt;https://blog.jetbrains.com/dotnet/2021/10/05/net-annotated-monthly-october-2021/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JetBrains による9月から10月にあった .NET 関連の記事やトピックスのまとめの記事。&lt;/p&gt;
&lt;h3 id="c"&gt;(C#) 構造体で列挙型ライクな定義を作る - ネコのために鐘は鳴る&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ikorin2.hatenablog.jp/entry/2021/10/04/043527"&gt;https://ikorin2.hatenablog.jp/entry/2021/10/04/043527&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enum (列挙型) の代わりとなるような値/タイプセーフな定義型を作る方法について。&lt;/p&gt;
&lt;p&gt;struct として定義することのメリットとして定義外の値を防ぐことやメソッドの定義ができること、内部値の変更が可能といった点があり、デメリットとして定数とできない、デフォルト引数値として扱えない、switch での分岐ができない、Enum の機能を使えないといった点をあげている。&lt;/p&gt;
&lt;h3 id="a-look-at-the-upcoming-improvements-to-linq-in.net-6"&gt;A look at the upcoming improvements to LINQ in .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://raygun.com/blog/linq-net-6-improvements/"&gt;https://raygun.com/blog/linq-net-6-improvements/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で強化される LINQ に関する紹介の記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Chunk&lt;/code&gt; の追加, &lt;code&gt;ElementAt&lt;/code&gt; の Index 対応、&lt;code&gt;Take&lt;/code&gt; の Range 対応、&lt;code&gt;Zip&lt;/code&gt; の3パラメータ版 の追加、&lt;code&gt;FirstOrDefault&lt;/code&gt; などでのデフォルト値、&lt;code&gt;TryGetNonEnumeratedCount&lt;/code&gt; ヘルパーメソッド、&lt;code&gt;MaxBy&lt;/code&gt;/&lt;code&gt;MinBy&lt;/code&gt; の追加について。&lt;/p&gt;
&lt;h3 id="hacktoberfest-for.net-developers-c-edition"&gt;Hacktoberfest for .NET Developers (C# Edition)&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/arafattehsin/hacktoberfest-for-net-developers-c-edition-3bha"&gt;https://dev.to/arafattehsin/hacktoberfest-for-net-developers-c-edition-3bha&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hacktoberfest に参加しコントリビュートを受け付けている .NET (C# 向け) のプロジェクトの紹介記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://hacktoberfest.digitalocean.com/"&gt;Hacktoberfest 2021&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="odata-with.net-6"&gt;OData with .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/berviantoleo/odata-with-net-6-5e1p"&gt;https://dev.to/berviantoleo/odata-with-net-6-5e1p&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 と PostgreSQL で OData 対応の API アプリケーションを用意するステップバイステップ。&lt;/p&gt;
&lt;h3 id="aws-dotnet-lambda-functions-powered-by-aws-graviton2-processors-c-cdk"&gt;AWS DotNet Lambda Functions powered by AWS Graviton2 Processors (C#, CDK)&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://collin-smith.medium.com/aws-dotnet-lambda-functions-powered-by-aws-graviton2-processors-c-cdk-c7efc160324d"&gt;https://collin-smith.medium.com/aws-dotnet-lambda-functions-powered-by-aws-graviton2-processors-c-cdk-c7efc160324d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET による AWS Lambda Functions を AWS Graviton 2 (ARM) インスタンスの上で動かす記事。&lt;/p&gt;
&lt;p&gt;CDK を使用して Lambda Functions のプロジェクトを作成し、デプロイする方法について触れている。&lt;/p&gt;
&lt;h3 id="building-a-middleware-pipeline-with-webapplication-exploring.net-core-6-part-4"&gt;Building a middleware pipeline with WebApplication: Exploring .NET Core 6 - Part 4&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-4-building-a-middleware-pipeline-with-webapplication/"&gt;https://andrewlock.net/exploring-dotnet-6-part-4-building-a-middleware-pipeline-with-webapplication/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core の WebApplication が開始、終了するまでの流れと HTTP ミドルウェアパイプラインの構築についての解説記事。&lt;/p&gt;
&lt;p&gt;WebApplication を介してミドルウェアを登録した場合にどのようにしてパイプラインを構築されるかに触れている。&lt;/p&gt;
&lt;h3 id="switchbotwindowscble-qiita"&gt;SwitchBot温湿度計の値を、WindowsでC#でBLEで直接受信する - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/ShTair/items/3fef7dad7668bd4e8fa5"&gt;https://qiita.com/ShTair/items/3fef7dad7668bd4e8fa5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SwitchBot の温湿度計を .NET 5 と Windows 10 の Bluetooth LE の API を使用して読み取ることについての記事。&lt;/p&gt;
&lt;h3 id="graphql-mutation-errors-union-erros-with-interface-aka-6a-with-hotchocolate-graphql-server"&gt;GraphQL mutation errors (union erros with interface aka 6a) with Hotchocolate GraphQL Server&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/damikun/graphql-mutation-union-erros-6a-with-hotchocolate-graphql-server-1b70"&gt;https://dev.to/damikun/graphql-mutation-union-erros-6a-with-hotchocolate-graphql-server-1b70&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hotchocolate GraphQL サーバーでミューテーションのエラーを Union と Interface の組み合わせ (Stage 6a) で返す方法についての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://productionreadygraphql.com/2020-08-01-guide-to-graphql-errors"&gt;A Guide to GraphQL Errors | Production Ready GraphQL | Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="blazor-webassembly-svg-drag-and-drop"&gt;Blazor Webassembly SVG Drag And Drop&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/codex/blazor-webassembly-svg-drag-and-drop-e680769ac682"&gt;https://medium.com/codex/blazor-webassembly-svg-drag-and-drop-e680769ac682&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly で SVG の要素をドラッグアンドドロップできるようにする実装についての記事。&lt;/p&gt;
&lt;h3 id="exploring-c-10-save-space-with-file-scoped-namespaces"&gt;Exploring C# 10: Save Space with File-Scoped Namespaces&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/daveabrock/exploring-c-10-save-space-with-file-scoped-namespaces-1jfi"&gt;https://dev.to/daveabrock/exploring-c-10-save-space-with-file-scoped-namespaces-1jfi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 10 で使用できるファイルスコープの &lt;code&gt;namespace&lt;/code&gt; についての記事。&lt;/p&gt;
&lt;p&gt;従来の指定方法と混ぜることができない点や、複数回指定できないなどの注意点にも触れている。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="adamralphminver-minimalistic-versioning-using-git-tags"&gt;adamralph/minver: 🏷 Minimalistic versioning using Git tags.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/adamralph/minver"&gt;https://github.com/adamralph/minver&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Git のタグをベースにアプリケーション/ライブラリーのバージョニングを簡単に行うためのライブラリー/コマンドラインツール。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/karuakun/items/26a2496fb5874980637b"&gt;MinVerでお手軽にライブラリのバージョン番号の管理を行う - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="marusykgrok.net.net-implementation-of-the-grok"&gt;Marusyk/grok.net: .net implementation of the grok 📝&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/Marusyk/grok.net"&gt;https://github.com/Marusyk/grok.net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ログ解析などで使用される Grok パターンを解析する .NET 向けライブラリー。&lt;/p&gt;
&lt;h3 id="devloopedwebsocketchannel-high-performance-system.threading.channels-api-adapter-for-system.net.websockets"&gt;devlooped/WebSocketChannel: High-performance System.Threading.Channels API adapter for System.Net.WebSockets&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/devlooped/WebSocketChannel"&gt;https://github.com/devlooped/WebSocketChannel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WebSockets をバックにした &lt;code&gt;System.Threading.Channels.Channel&amp;lt;T&amp;gt;&lt;/code&gt; の実装。&lt;/p&gt;
&lt;p&gt;サーバー/クライアントで Channel インターフェースを通して &lt;code&gt;ReadOnlyMemory&amp;lt;byte&amp;gt;&lt;/code&gt; を WebSocket の上で送受信できる。&lt;/p&gt;
&lt;!-- https://twitter.com/kzu/status/1445083345520562181?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Continuing my exploration of &lt;a href="https://twitter.com/Azure?ref_src=twsrc%5Etfw"&gt;&amp;#64;Azure&lt;/a&gt; Web PubSub, I think the &lt;a href="https://twitter.com/dotnet?ref_src=twsrc%5Etfw"&gt;&amp;#64;dotnet&lt;/a&gt; System.Threading.Channels API is actually even nicer than raw WebSockets and pipelines. So I created another small thingy you might find useful too 🤟 &lt;a href="https://t.co/r4xn3cc7Kx"&gt;https://t.co/r4xn3cc7Kx&lt;/a&gt;&lt;/p&gt;&amp;mdash; Daniel Cazzulino (&amp;#64;kzu) &lt;a href="https://twitter.com/kzu/status/1445083345520562181?ref_src=twsrc%5Etfw"&gt;October 4, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h3 id="sonarlint-code-quality-and-code-security-starts-in-your-ide"&gt;SonarLint | Code Quality and Code Security starts in your IDE&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.sonarlint.org/"&gt;https://www.sonarlint.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ソースコードに問題がある点などを検出する Visual Studio に対応した IDE 拡張。&lt;/p&gt;
&lt;h3 id="damikuntrouble-training-fullstack-app-workshop-with-distributed-tracing-and-monitoring.this-shows-the-configuration-from-react-frontend-to.netcore-backend"&gt;damikun/trouble-training: FullStack app workshop with distributed tracing and monitoring. This shows the configuration from React frontend to .NetCore backend.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/damikun/trouble-training"&gt;https://github.com/damikun/trouble-training&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET を使用したフルスタックなアプリケーションのワークショップ。&lt;/p&gt;
&lt;p&gt;サーバーアプリケーションのみではなく、フロントエンドやロギング基盤や分散トレーシングなども含む比較的複雑な構成を持つのが特徴。&lt;/p&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="wcf-asp.net-core-grpc-wcf-grpc"&gt;WCF 開発者向け ASP.NET Core gRPC - WCF 開発者向け gRPC&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/architecture/grpc-for-wcf-developers/"&gt;https://docs.microsoft.com/ja-jp/dotnet/architecture/grpc-for-wcf-developers/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WCF 開発者に向けた ASP.NET Core の gRPC のガイドとなるのドキュメント。&lt;/p&gt;
&lt;p&gt;WCF 開発者以外でも参考となるような gRPC の特性、ProtoBuf について、gRPC のセキュリティーや運用環境での考慮点についても書かれている。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/tannergooding/status/1443758012980555794?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;&lt;a href="https://t.co/cLdGgzD0bx"&gt;https://t.co/cLdGgzD0bx&lt;/a&gt; gives an example of a Sum method before/after these APIs.&lt;br&gt;&lt;br&gt;There are likely a few APIs we can expose to help simplify/remove the Unsafe logic (while also avoiding pinning) &amp;amp; to handle trailing elements as well, but its something I’m still looking into.&lt;/p&gt;&amp;mdash; Tanner Gooding (&amp;#64;tannergooding) &lt;a href="https://twitter.com/tannergooding/status/1443758012980555794?ref_src=twsrc%5Etfw"&gt;October 1, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;クロスプラットフォームなハードウェア Intrinstic なコードを書けるようにするサポートに取り掛かり始めたという話。&lt;/p&gt;
&lt;!-- https://twitter.com/akarpov89/status/1443957219834400773?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I&amp;#39;ve just found really cool and unexpected application of C# 10 interpolated string handlers: scanf-like parsing!&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://t.co/3VYDEunYuB"&gt;pic.twitter.com/3VYDEunYuB&lt;/a&gt;&lt;/p&gt;&amp;mdash; Andrew Karpov (&amp;#64;akarpov89) &lt;a href="https://twitter.com/akarpov89/status/1443957219834400773?ref_src=twsrc%5Etfw"&gt;October 1, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;C# 10 の String interpolation のハンドラーを使用することで、&lt;code&gt;scanf&lt;/code&gt; のようなフォーマットを元に入力をパースして変数にセットするという黒魔術的なテクニック。(実際のコードも危険な雰囲気が漂っている)&lt;/p&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1445465823938682881?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;A thread about LINQ improvements in .NET 6 🧵&lt;br&gt;&lt;br&gt;As always, retweets are appreciated 😌&lt;a href="https://twitter.com/hashtag/dotnet6?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet6&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/linq?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#linq&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1445465823938682881?ref_src=twsrc%5Etfw"&gt;October 5, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 の LINQ に関する強化点についてのスレッド。新規追加されたメソッドなどを .NET 5 と比較しながら紹介。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="add-pattern-variables.md-by-alrz-pull-request-4592-dotnetcsharplang"&gt;Add pattern-variables.md by alrz · Pull Request #4592 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/pull/4592"&gt;https://github.com/dotnet/csharplang/pull/4592&lt;/a&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if (e is (int i, 0))
  Use(i);
else if (e is (0, int j))
  Use(j);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;の代わりに&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;if (e is (int i, 0) or (0, int i))
  Use(i);
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;のような is パターンマッチ中で同じ型であれば共用できるようにするという提案。&lt;/p&gt;
&lt;h3 id="optimize-datetime.equals-by-egorbo-pull-request-59857-dotnetruntime"&gt;Optimize DateTime.Equals by EgorBo · Pull Request #59857 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59857"&gt;https://github.com/dotnet/runtime/pull/59857&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DateTime.Equals&lt;/code&gt; は Ticks を比較していたが、Ticks は内部表現 (ulong) の上位2ビットをマスクしたものを返すプロパティなので、直接内部表現同士で XOR を取って上位2bitを無視するようにすることでより速くなるというPR。&lt;/p&gt;
&lt;h3 id="guarded-devirt-multiple-type-checks-by-egorbo-pull-request-59604-dotnetruntime"&gt;Guarded Devirt: multiple type checks by EgorBo · Pull Request #59604 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59604"&gt;https://github.com/dotnet/runtime/pull/59604&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gurded Devirtualization が「最もよく使われるもの」と「それ以外」だったのを「よく使われるいくつか」と「それ以外」といった形にするというPR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-10-01: NuGet.org, Windows Community Toolkit v7.1, Npgsql 6.0.0 RC1, ReSharper 2021.3 &amp; Rider 2021.3 EAP</title>
			<link>/2021/10/01/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/10/01/updates</guid>
			<pubDate>Fri, 01 Oct 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/nuget/introducing-the-new-nuget-org-package-details-page/"&gt;NuGet.org のパッケージ詳細ページのデザインが新しくなりました&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;いろいろな情報がすべて表示されていましたが、ターゲットフレームワークのバッジなど今後も追加したい要素があるということでタブベースのデザインに変更したそうです。README を表示する機能は少し前から実装されていましたが、より目立つ形になっているのでこれからリリースするパッケージには含めるのがよさそうです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blogs.windows.com/windowsdeveloper/2021/09/23/announcing-windows-community-toolkit-v7-1/"&gt;Windows Community Toolkit v7.1&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;Microsoft ID 認証に関する刷新やドロップシャドウを実現するためのスタイルの追加などが行われています。ドロップシャドウに関しては Microsoft Store アプリで使用されているそうです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/npgsql/npgsql/releases/tag/v6.0.0-rc.1"&gt;Npgsql v6.0.0 RC1&lt;/a&gt;がリリースされました。&lt;/p&gt;
&lt;p&gt;複数ホストへの接続や Raw SQL、バッチ実行といったものがサポートされ、.NET 6 に向けた対応も含まれています。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/09/28/resharper-2021-3-eap/"&gt;ReSharper 2021.3 EAP&lt;/a&gt; と &lt;a href="https://blog.jetbrains.com/dotnet/2021/09/28/rider-2021-3-eap/"&gt;Rider 2021.3 EAP&lt;/a&gt; がリリースされました (EAP == プレビュー的なリリース)。&lt;/p&gt;
&lt;p&gt;それぞれ C# 10 への対応や ReSharper は Visual Studio 2022 の対応、Rider は .NET 6 SDK への対応をはじめ、プロジェクトプロパティーや Debug の UI の変更などが含まれています。また Apple Silicon 向けのビルドも別途リリースされています。&lt;/p&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="introducing-the-new-nuget.org-package-details-page-the-nuget-blog"&gt;Introducing the New NuGet.org Package Details Page - The NuGet Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/nuget/introducing-the-new-nuget-org-package-details-page/"&gt;https://devblogs.microsoft.com/nuget/introducing-the-new-nuget-org-package-details-page/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NuGet.org のパッケージ詳細ページが4年ぶりに新デザインに刷新された。&lt;/p&gt;
&lt;p&gt;デザイン変更した理由として、2021年の5月からパッケージに含まれる README を表示する機能が追加され、今後&lt;a href="https://github.com/NuGet/Home/pull/10900"&gt;ターゲットフレームワークに関する情報を表示する予定もある&lt;/a&gt;が、要素を追加するためのスペースが不足してきたためタブデザインで逃がすことにした。&lt;/p&gt;
&lt;p&gt;記事では実際にリリースされるまでのフィードバックについても触れている。&lt;/p&gt;
&lt;h3 id="announcing-windows-community-toolkit-v7.1-windows-developer-blog"&gt;Announcing Windows Community Toolkit v7.1 - Windows Developer Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blogs.windows.com/windowsdeveloper/2021/09/23/announcing-windows-community-toolkit-v7-1/"&gt;https://blogs.windows.com/windowsdeveloper/2021/09/23/announcing-windows-community-toolkit-v7-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows Community Toolkit v7.1 がリリース。&lt;/p&gt;
&lt;p&gt;Microsoft ID 認証のヘルパーとプロバイダーの刷新と Microsoft Graph API と OneDrive をサポートするヘルパー API とコントロールの提供。&lt;/p&gt;
&lt;p&gt;コントロールにドロップシャドウをつけるためのスタイルを追加。既存の DropShadowPanel コントロールに代わるものでコントロールをラップせずスタイルとして適用する。実装には Win2D ベースの　&lt;code&gt;AttachedCardShadow&lt;/code&gt; と UWP の Composition ベースの &lt;code&gt;AttachedDropShadow&lt;/code&gt; がある。&lt;code&gt;AttachedCardShadow&lt;/code&gt; は Win2D への依存があり矩形のみのサポートとなるがパフォーマンスもよい、&lt;code&gt;AttachedDropShadow&lt;/code&gt; は Composition を使用するため UWP アプリでのみ使用できるがマスク画像やテキストなどもサポートするといった違いがある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/communitytoolkit/helpers/attachedshadows"&gt;Attached Shadows - Windows Community Toolkit | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RichSuggestBox コントロールの追加。&lt;code&gt;&amp;#64;&lt;/code&gt; によるユーザー名のサジェストのようなものを提供できる RichEditBox。&lt;/p&gt;
&lt;p&gt;MVVM Source Generator がプレビューで追加され、&lt;code&gt;ObservableProperty&lt;/code&gt;, &lt;code&gt;ICommand&lt;/code&gt;, &lt;code&gt;INotifyPropertyChanged&lt;/code&gt; 属性などでマークすることでボイラープレートコードの生成が行えるようになった。&lt;/p&gt;
&lt;p&gt;そのほか Toolkit Labs という形で実験的なパッケージが提供されるようになった。今後 Lab リポジトリなどが用意される予定。すでに物体認識のような Intelligent APIs や視線入力の Gaze Controls といったものがある。&lt;/p&gt;
&lt;h3 id="release-v6.0.0-rc.1-npgsqlnpgsql"&gt;Release v6.0.0-rc.1 · npgsql/npgsql&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/npgsql/npgsql/releases/tag/v6.0.0-rc.1"&gt;https://github.com/npgsql/npgsql/releases/tag/v6.0.0-rc.1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Npgsql v6.0.0 RC1 がリリース。&lt;/p&gt;
&lt;p&gt;6.0 ではロードバランシングなどを含むマルチホスト接続、タイムスタンプの改善、Raw SQL の発行や .NET 6 で導入されたバッチ API を使用したバッチ実行、.NET 6 の DateOnly/TimeOnly のサポートの追加など。&lt;/p&gt;
&lt;p&gt;Raw SQL の発行は Npgsql がクエリーを書き換えずパラメータを送信するようにする仕組みで、以前の名前付きパラメータに代わるもの。名前付きパラメータはクエリーをパースし、書き換えてから PostgreSQL に送信していたが Raw SQL ではクエリーはそのまま PostgreSQL へ送信するため安全性が高まり、クエリーも効果的になるとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.npgsql.org/doc/release-notes/6.0.html"&gt;Npgsql 6.0 Release Notes | Npgsql Documentation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://www.roji.org/parameters-batching-and-sql-rewriting"&gt;Query parameters, batching and SQL rewriting - Shay Rojansky’s Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/28633"&gt;New System.Data.Common batching API · Issue #28633 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-v1.41.0-grpcgrpc"&gt;Release v1.41.0 · grpc/grpc&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/grpc/grpc/releases/tag/v1.41.0"&gt;https://github.com/grpc/grpc/releases/tag/v1.41.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gRPC v1.41.0 がリリース。&lt;/p&gt;
&lt;p&gt;C# (C-core) に関連する変更としては非常に稀なケースでレスポンスのメタデータが破損してしまう問題の修正、non-ASCII な環境でネイティブライブラリーへのパスに non-ASCII な文字が含まれる場合に読み込み失敗してしまうことがある問題の修正など。&lt;/p&gt;
&lt;h3 id="rider-2021.3-early-access-program-has-launched-the.net-tools-blog"&gt;Rider 2021.3 Early Access Program Has Launched! | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/09/28/rider-2021-3-eap/"&gt;https://blog.jetbrains.com/dotnet/2021/09/28/rider-2021-3-eap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rider 2021.3 EAP (早期アクセス) がリリース。&lt;/p&gt;
&lt;p&gt;ソリューションにまつわる問題点を一覧できる Problems View が追加。コードに関連する問題以外も NuGet や .NET SDK といったツールや環境に関する問題を列挙してその場で対応できる。&lt;/p&gt;
&lt;p&gt;.NET 6 SDK に対応、Debug タブの UI 変更、デバッガーの改善により UWP のサポートと Windows 上での Windows Docker コンテナー内でのデバッグが可能となった。&lt;/p&gt;
&lt;p&gt;file-scoped namespace のような C# 10 に関連した言語の対応やコード解析、SQL 言語 Injection のサポート改善、Unity 向けのコードで XML ドキュメントを &lt;code&gt;Tooltip&lt;/code&gt; 属性に変換する機能、Apple Silicon 向けビルドの提供、プロジェクトとソリューションのプロパティーウィンドウの改修など。&lt;/p&gt;
&lt;h3 id="resharper-2021.3-starts-early-access-program-the.net-tools-blog"&gt;ReSharper 2021.3 Starts Early Access Program! | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/09/28/resharper-2021-3-eap/"&gt;https://blog.jetbrains.com/dotnet/2021/09/28/resharper-2021-3-eap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReSharper 2021.3 EAP (早期アクセス) がリリース。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 Preview がサポートされ、file-scoped namespace のような C# 10 に関連した言語の対応やコード解析の改善が行われた。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Namespace.Type.Member&lt;/code&gt; といった FQN 形式でコピーする Copy FQN が Copy Code Reference に変わり、GitHub へのリンクやカスタム URL パターンを定義してコピーできるようになった。&lt;/p&gt;
&lt;p&gt;.NET 5 SDK から対応した AnalyzerConfig ファイルに ReSherper も対応した。パラメータやフィールドを &lt;code&gt;LanguageInjection&lt;/code&gt; 属性でマークすることで Language Injection を有効化できるようになった。&lt;/p&gt;
&lt;p&gt;dotMemory は Windows では ETW イベントを使用してアロケーションをサンプリングできるように。正確さは以前の手法には劣るがパフォーマンスペナルティがない、集めるために有効にする必要がない、すでに動作中のアプリケーションでも集められるといった利点がある。&lt;/p&gt;
&lt;h3 id="avoiding-memory-leaks-in-visual-studio-editor-extensions-visual-studio-blog"&gt;Avoiding Memory Leaks in Visual Studio Editor Extensions - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/avoiding-memory-leaks-in-visual-studio-editor-extensions/"&gt;https://devblogs.microsoft.com/visualstudio/avoiding-memory-leaks-in-visual-studio-editor-extensions/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio のインプロセス拡張でのメモリーリークを防ぐための VS IDE チームが持つベストプラクティスの紹介。&lt;/p&gt;
&lt;p&gt;MEF パーツによるメモリーリークでは &lt;code&gt;ITextView&lt;/code&gt; のような重いオブジェクトの参照を一つ持つだけでも関連するソリューションまで参照が広がり、多くのリークが発生する例が挙げられている。対策として MEF パーツには強参照/ステートを持たない、持つ場合にはスコープのライフタイムに限定できるようにする、どうしても参照を持つ場合には WeakReference を使う。&lt;/p&gt;
&lt;p&gt;C# のイベントリスナーのリークの例も同様に、イベントを購読する際に重いオブジェクトへの参照が間接的に発生してしまう。対策として &lt;code&gt;ITextView.Close&lt;/code&gt; のような不要になるタイミングでの購読解除や IDisposable を IDE が呼び出すものであれば Dispose を実装する。&lt;/p&gt;
&lt;p&gt;他にも静的なステートや WPF のデータバインディングの例が挙げられている。また、それらメモリーリークを解析するためのツールについても触れている。&lt;/p&gt;
&lt;h3 id="announcing-azure-credits-for-open-source-projects-microsoft-open-source-blog"&gt;Announcing: Azure credits for open source projects - Microsoft Open Source Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://cloudblogs.microsoft.com/opensource/2021/09/28/announcing-azure-credits-for-open-source-projects/"&gt;https://cloudblogs.microsoft.com/opensource/2021/09/28/announcing-azure-credits-for-open-source-projects/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Open Source Initiative (OSI) に承認されたライセンスで提供しているオープンソースプロジェクトに対して Azure のクレジットを提供するプログラムを開始。現時点で FreeBSD や Haskell といったプロジェクトが参加している。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://opensource.microsoft.com/azure-credits"&gt;Azure Credits for Open Source Projects | Microsoft Open Source&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="vs-code-in-the-browser-for-everyone"&gt;VS Code in the browser for everyone&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.gitpod.io/blog/openvscode-server-launch"&gt;https://www.gitpod.io/blog/openvscode-server-launch&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Gitpod が Gitpod や GitHub Codespaces のように Visual Studio Code をリモートサーバーで稼働させる OpenVSCode Server を公開。&lt;/p&gt;
&lt;p&gt;Visual Studio Code 本体には GitHub Workspaces のような形で実行するためのパーツが欠けているため、フォークして最小の変更で埋めることでサーバーで動作できるようにしている。Docker をはじめ AWS や GCP といったクラウド環境での起動方法も用意されている。&lt;/p&gt;
&lt;p&gt;Gitpod との直接の違いは環境も含めすべてマネージドであって欲しいか、あるいはリモートで Visual Studio Code が動作しそこにアクセスしたいかにあるとしている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/gitpod-io/openvscode-server/"&gt;gitpod-io/openvscode-server: Run upstream VS Code on a remote machine with access through a modern web browser from any device, anywhere.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="how-to-deploy-a-dockerized-web-app-to-heroku-using-the-github-actions"&gt;How to Deploy a Dockerized Web App to Heroku using the GitHub Actions&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://enlear.academy/how-to-deploy-a-dockerized-web-app-to-heroku-using-the-github-actions-f16c00b19621"&gt;https://enlear.academy/how-to-deploy-a-dockerized-web-app-to-heroku-using-the-github-actions-f16c00b19621&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Docker イメージにした .NET の Web アプリケーションを GitHub Actions から Heroku にデプロイして動かす方法についての記事。&lt;/p&gt;
&lt;h3 id="implicit-usings-in.net-6"&gt;Implicit Usings in .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/implicit-usings-in-net-6"&gt;https://www.hanselman.com/blog/implicit-usings-in-net-6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Implicit using について簡単に紹介する記事。&lt;/p&gt;
&lt;h3 id="c-10.0"&gt;C# 10.0 の補間文字列の改善&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ufcpp.net/study/csharp/start/improvedinterpolatedstring/"&gt;https://ufcpp.net/study/csharp/start/improvedinterpolatedstring/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 10 での補完文字列 (String interpolation) の改善についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;InterpolatedStringHandler&lt;/code&gt; 属性を持つハンドラー型を使用した文字列フォーマットの展開例や実装例、オーバーロード解決や .NET 6 で String クラスなどに追加された API についても触れている。&lt;/p&gt;
&lt;h3 id="wpfdicicd1-qiita"&gt;自作のWPFアプリを後から自動テスト・DI・CI/CD対応にしてみる。その1 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/soi/items/273e60b2a48d57ae762f"&gt;https://qiita.com/soi/items/273e60b2a48d57ae762f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WPF アプリケーションの自動テストと DI の導入、CI 対応についての記事。&lt;/p&gt;
&lt;p&gt;テストは xUnit を、DI は Microsoft.Extensions.DependencyInjection を採用。CI は GitHub Actions でカバレッジの取得や Release の作成まで行う。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/soi/items/a19304220c71bdfbc171"&gt;自作のWPFアプリを後から自動テスト・DI・CI/CD対応にしてみる。その2 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://qiita.com/soi/items/e5f01c66c0a303a74c30"&gt;自作のWPFアプリを後から自動テスト・DI・CI/CD対応にしてみる。その3 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-6-blazor"&gt;.NET 6 の Blazor のコンポーネントでクエリ パラメーターを使うのが簡単になりました&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/okazuki/articles/blazor-wasm-rc1-queryparam"&gt;https://zenn.dev/okazuki/articles/blazor-wasm-rc1-queryparam&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 Preview 7 以降の Blazor に追加されたクエリーストリングをパラメーターとして受け取る &lt;code&gt;SupplyParameterFromQuery&lt;/code&gt; についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NavigationManager&lt;/code&gt; クラスに追加されたアプリケーション側から URL やそのパラメーターを変更するためのメソッドについても触れている。&lt;/p&gt;
&lt;h3 id="c-web-url-blazor-webassembly.net-5-jsakamoto"&gt;C# での Web アプリ開発で、要求 URL 中のクエリ文字列をいい感じに読み取る - 特に Blazor WebAssembly (とりわけ .NET 5 以前) での注意点 : &amp;#64;jsakamoto&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devadjust.exblog.jp/28884450/"&gt;https://devadjust.exblog.jp/28884450/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Web アプリケーションでのクエリーストリングのパースについての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;HttpUtility.ParseQueryString&lt;/code&gt; と &lt;code&gt;UriExtensions.ParseQueryString&lt;/code&gt; の違いについてや Blazor (.NET 5) での注意など。&lt;/p&gt;
&lt;h3 id="net-6-blazor-head"&gt;.NET 6 の Blazor で追加された &amp;lt;head&amp;gt; タグの中を変更する機能の紹介&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/okazuki/articles/blazor-dotnet6-headoutlet"&gt;https://zenn.dev/okazuki/articles/blazor-dotnet6-headoutlet&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Blazor で導入された &lt;code&gt;head&lt;/code&gt; 要素に関するコンポーネントについての紹介記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;head&lt;/code&gt; 要素にページごとに要素を追加できる &lt;code&gt;HeadContent&lt;/code&gt; コンポーネントと、ページのタイトルを設定できる &lt;code&gt;PageTitle&lt;/code&gt; コンポーネントが追加された。&lt;/p&gt;
&lt;h3 id="entity-framework-biweekly-status-updates-2021-issue-23884-dotnetefcore"&gt;Entity Framework Biweekly Status Updates (2021) · Issue #23884 · dotnet/efcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/issues/23884#issuecomment-926052851"&gt;https://github.com/dotnet/efcore/issues/23884#issuecomment-926052851&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2週ごとの Entity Framework のステータス更新レポートの9月23日分。EF Core 6.0 のステータスが Feature complete となったことなど。&lt;/p&gt;
&lt;h3 id="how-to-retry-failing-dotnet-tests-in-github-actions"&gt;How to retry failing dotnet tests in GitHub Actions&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.cazzulino.com/dotnet-test-retry.html"&gt;https://www.cazzulino.com/dotnet-test-retry.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ネットワークが絡むテストなどで失敗しやすい (flaky) テストを GitHub Actions で実行する際にリトライする方法についての記事。&lt;/p&gt;
&lt;p&gt;bash シェルスクリプトで失敗をカウントしつつ、失敗したテスト名を抽出して部分的にリトライする (&lt;code&gt;--filter&lt;/code&gt;) といった手法。&lt;/p&gt;
&lt;h3 id="exploring-the-code-behind-webapplicationbuilder-exploring.net-core-6-part-3"&gt;Exploring the code behind WebApplicationBuilder: Exploring .NET Core 6 - Part 3&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-3-exploring-the-code-behind-webapplicationbuilder/"&gt;https://andrewlock.net/exploring-dotnet-6-part-3-exploring-the-code-behind-webapplicationbuilder/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の WebApplicationBuilder についての詳細に解説している記事。&lt;/p&gt;
&lt;p&gt;WebApplicationBuilder は内部に何を抱えていて、どうアプリケーションが構築されるのかといった点に触れている。&lt;/p&gt;
&lt;h3 id="creating-roslyn-api-based-static-analyzer-for-c"&gt;Creating Roslyn API-based static analyzer for C#&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/pvs-studio/creating-roslyn-api-based-static-analyzer-for-c-c0d7c27489f9"&gt;https://medium.com/pvs-studio/creating-roslyn-api-based-static-analyzer-for-c-c0d7c27489f9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roslyn ベースでの静的コードアナライザーの作成についての記事。&lt;/p&gt;
&lt;p&gt;スタンドアローンで実行可能なコードアナライザーの作成方法から、シンタックスツリーの歩き方についてや Semantic Model とシンボルといったものの扱い方などにも触れている。&lt;/p&gt;
&lt;h3 id="efcore-qiita"&gt;EFCore でレコードに対するトリガーを実行する - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/karuakun/items/2db2e7ff8411e3a455cd"&gt;https://qiita.com/karuakun/items/2db2e7ff8411e3a455cd&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework を使用してレコードに対する操作を行う際に C# のコードレベルで追加の処理を行う方法 (更新日のようなカラムを更新するとか) についての記事。&lt;/p&gt;
&lt;p&gt;DataContext の拡張、インターセプターによるフック、EntityFrameworkCore.Triggered を使用した方法が紹介されている。&lt;/p&gt;
&lt;h3 id="azure-active-directorys-gateway-is-on.net-core-3.1.net-blog"&gt;Azure Active Directory's gateway is on .NET Core 3.1! - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/azure-active-directorys-gateway-service-is-on-net-core-3-1/"&gt;https://devblogs.microsoft.com/dotnet/azure-active-directorys-gateway-service-is-on-net-core-3-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Azure Active Directory のゲートウェイサーバーを .NET Framework から .NET Core 3.1 に移行したという2021年1月の記事。&lt;/p&gt;
&lt;p&gt;.NET Core に移行を完遂するにあたって Web サーバーの検討、アプリケーションの移行、段階的なロールアウトを行ったことについて書かれている。
また .NET Framework の ASP.NET との挙動の違いといった移行の中であった学びにも触れている。&lt;/p&gt;
&lt;h3 id="custom-deployment-layout-for-blazor-webassembly-apps-asp.net-blog"&gt;Custom deployment layout for Blazor WebAssembly apps - ASP.NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/aspnet/custom-deployment-layout-for-blazor-webassembly-apps/"&gt;https://devblogs.microsoft.com/aspnet/custom-deployment-layout-for-blazor-webassembly-apps/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Blazor WebAssembly ではカスタムしたアプリケーション配布パッケージを作成する仕組みを NuGet パッケージとして提供できるようになったことについての記事。&lt;/p&gt;
&lt;p&gt;カスタム配置は例として DLL のダウンロードがブロックされている場合にひとまとめにした形でダウンロードするといった利用方法が考えられ、マルチパートなファイルにまとめるというサンプルコード/パッケージが公開されている。&lt;/p&gt;
&lt;p&gt;JavaScript の Blazor の初期化プロセスに介入する部分と MSBuild タスクによってファイルをパブリッシュする部分の拡張ポイントが増えたことで実現可能となったとのこと。&lt;/p&gt;
&lt;h3 id="wpf-window-direct3d12"&gt;WPF の Window 上に Direct3D12 でレンダリングする&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/tan_y/articles/25cc05576ef11a"&gt;https://zenn.dev/tan_y/articles/25cc05576ef11a&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 の WPF アプリケーションのウィンドウ上に Direct3D12 でレンダリングした結果を表示する方法についての記事。&lt;/p&gt;
&lt;p&gt;WindowsFormsHost を使用したウィンドウにレンダリングする方法、D3DImage を使用した WPF を介してレンダリングする方法がそれぞれの長所/短所と共に紹介されている。&lt;/p&gt;
&lt;h3 id="the-code-worked-differently-when-the-moon-was-full"&gt;The code worked differently when the moon was full&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/the-code-worked-differently-when-the-moon-was-full"&gt;https://www.hanselman.com/blog/the-code-worked-differently-when-the-moon-was-full&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;3-4週間おきにスレッドプールのスレッド数がコア数またはコア数+20を行ったり来たりする謎のバグについての記事。&lt;/p&gt;
&lt;p&gt;これは Windows 95 で有名な 49.7 日問題と似て &lt;code&gt;PortableThreadPool&lt;/code&gt; の &lt;code&gt;ShouldAdjustMaxWorkersActive&lt;/code&gt; メソッドの中で &lt;code&gt;Environment.TickCount&lt;/code&gt; による値を使用していたため。PortableThreadPool ではヒルクライム アルゴリズムを用いてスレッド数を調整する仕組みとなっているがこれが適切に呼び出されない周期が発生していた。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;int priorTime = Volatile.Read(ref _separated.priorCompletedWorkRequestsTime);
int requiredInterval = _separated.nextCompletedWorkRequestsTime - priorTime;
// currentTimeMs が Environment.TickCount の値。Environment.TickCount は 24.9 日で負に変わる。
// priorCompletedWorkRequestsTime と nextCompletedWorkRequestsTime は起動時には 0 となっている
// この時 Environment.TickCount が負を返すと elapsedInterval は負になる
int elapsedInterval = currentTimeMs - priorTime;
if (elapsedInterval &amp;gt;= requiredInterval)
{
    // ヒルクライムが実行される == スレッドの数が調整される
    // priorCompletedWorkRequestsTime と nextCompletedWorkRequestsTime も更新する
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/51935"&gt;Hysteresis effect on threadpool hill-climbing · Issue #51935 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="using-the-model-builder-and-automl-for-creating-lead-decision-and-lead-scoring-model-in-microsoft-ml.net"&gt;Using the Model Builder and AutoML for Creating Lead Decision and Lead Scoring Model in Microsoft ML.NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;cekikjmiodrag/utilizing-the-model-builder-and-automl-for-creating-lead-decision-and-lead-scoring-model-in-19888f12d529"&gt;https://medium.com/&amp;#64;cekikjmiodrag/utilizing-the-model-builder-and-automl-for-creating-lead-decision-and-lead-scoring-model-in-19888f12d529&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Model Builder と AutoML を使用してリードスコアリングモデルを ML.NET で使用するステップバイステップの記事。&lt;/p&gt;
&lt;h3 id="a.net-object-from-allocation-to-collection"&gt;A .NET Object from allocation to collection&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/Maoni0/mem-doc/blob/master/presentation/ObjectJourney.pptx"&gt;https://github.com/Maoni0/mem-doc/blob/master/presentation/ObjectJourney.pptx&lt;/a&gt; (&lt;a href="https://view.officeapps.live.com/op/view.aspx?src=https%3A%2F%2Fraw.githubusercontent.com%2FMaoni0%2Fmem-doc%2Fmaster%2Fpresentation%2FObjectJourney.pptx&amp;amp;wdOrigin=BROWSELINK"&gt;PowerPoint Online で開く&lt;/a&gt;)&lt;/p&gt;
&lt;p&gt;オブジェクトのインスタンスを生成した際のアロケーションで OS やハードウェア上でのメモリーから始まり GC されるまでを解説したスライド。&lt;/p&gt;
&lt;!-- https://twitter.com/maoni0/status/1443344910476726274?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I&amp;#39;ve been so busy that I barely look at twitter these days. just published the slides from an internal talk I gave yesterday - very different from my normal GC talks as it touches a bit of all layers - the hardware (MMU), the OS (virtual memory) and the GC &lt;a href="https://t.co/fuZBgq6LGQ"&gt;https://t.co/fuZBgq6LGQ&lt;/a&gt;&lt;/p&gt;&amp;mdash; Maoni Stephens (&amp;#64;maoni0) &lt;a href="https://twitter.com/maoni0/status/1443344910476726274?ref_src=twsrc%5Etfw"&gt;September 29, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="chillicreamhotchocolate-welcome-to-the-home-of-the-hot-chocolate-graphql-server-for.net-the-strawberry-shake-graphql-client-for.net-and-banana-cake-pop-the-awesome-monaco-based-graphql-ide"&gt;ChilliCream/hotchocolate: Welcome to the home of the Hot Chocolate GraphQL server for .NET, the Strawberry Shake GraphQL client for .NET and Banana Cake Pop the awesome Monaco based GraphQL IDE.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/ChilliCream/hotchocolate"&gt;https://github.com/ChilliCream/hotchocolate&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;GraphQL 2021 draft spec に対応した GraphQL サーバーとクライアントのライブラリー。Monaco ベースの GraphQL エディターも提供されている。&lt;/p&gt;
&lt;p&gt;GraphQL for .NET (graphql-dotnet) との違いはパフォーマンス、より良いパーサー、フィルターやミドルウェア、フレキシブルな code-first アプローチなどがあるとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://medium.com/&amp;#64;teodor.siustis/creating-a-graphql-api-with-net5-and-hotchocolate-6dfe94626d10"&gt;Creating a GraphQL API with .NET5 and HotChocolate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/ChilliCream/hotchocolate/issues/392"&gt;Justification for HotChocolate as opposed to GraphQl.Net · Issue #392 · ChilliCream/hotchocolate&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="datageneratormxproject.devs.datagenerator-at-main-mxprojectdatagenerator"&gt;DataGenerator/mxProject.Devs.DataGenerator at main · mxProject/DataGenerator&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mxProject/DataGenerator/tree/main/mxProject.Devs.DataGenerator"&gt;https://github.com/mxProject/DataGenerator/tree/main/mxProject.Devs.DataGenerator&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ランダムなテストデータを含むレコードを返すライブラリー。&lt;code&gt;IDataReader&lt;/code&gt; を介したデータアクセスが可能。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/mxProject/items/194b2ae4c11656ae5a09"&gt;C# データレコード形式のテストデータを生成するライブラリを公開しました。 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ltrzesniewskipcre-net-pcre.net-perl-compatible-regular-expressions-for.net"&gt;ltrzesniewski/pcre-net: PCRE.NET - Perl Compatible Regular Expressions for .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/ltrzesniewski/pcre-net"&gt;https://github.com/ltrzesniewski/pcre-net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;PCRE (Perl 互換正規表現) ライブラリーの .NET 向けのラッパーとなるライブラリー。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.Text.RegularExpressions.Regex&lt;/code&gt; と似たインターフェースを提供している。&lt;/p&gt;
&lt;h3 id="nsubstitutensubstitute-a-friendly-substitute-for.net-mocking-libraries"&gt;nsubstitute/NSubstitute: A friendly substitute for .NET mocking libraries.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/nsubstitute/NSubstitute"&gt;https://github.com/nsubstitute/NSubstitute&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;使いやすさを重視したモックインスタンス生成用ライブラリー。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/arahori/items/8bcb0f770a0bfb5f7e54"&gt;NSubstitute を使った処理の置き換え - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="roubachofsharpnado.materialframe-a-modern-xamarin.forms-frame-component-supporting-blur-acrylic-dark-mode.implemented-with-realtimeblurview-on-android-custom-blurview-and-uivisualeffectview-on-ios"&gt;roubachof/Sharpnado.MaterialFrame: A modern Xamarin.Forms Frame component supporting blur, acrylic, dark mode. Implemented with RealtimeBlurView on Android (custom blurview) and UIVisualEffectView on iOS.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/roubachof/Sharpnado.MaterialFrame"&gt;https://github.com/roubachof/Sharpnado.MaterialFrame&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xamarin.Forms 向けのクロスプラットフォームなブラー/アクリルエフェクトを実現するコンポーネントのライブラリー。&lt;/p&gt;
&lt;h3 id="jamesmhcoravel-near-zero-config.net-core-micro-framework-that-makes-advanced-application-features-like-task-scheduling-caching-queuing-event-broadcasting-and-more-a-breeze"&gt;jamesmh/coravel: Near-zero config .NET Core micro-framework that makes advanced application features like Task Scheduling, Caching, Queuing, Event Broadcasting, and more a breeze!&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/jamesmh/coravel"&gt;https://github.com/jamesmh/coravel&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;設定がほとんど不要なタスクスケジューラーサービスを提供するライブラリー。&lt;/p&gt;
&lt;p&gt;キャッシュやキューイング、メール送信といった機能も持っている。ダッシュボードなどを提供する有償版もある。&lt;/p&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="programming-idioms"&gt;Programming Idioms&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.programming-idioms.org/"&gt;https://www.programming-idioms.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;様々なプログラミング言語によるパターン別の実装例を載せているサイト。(例: &lt;a href="https://www.programming-idioms.org/idiom/41/reverse-a-string#impl5098"&gt;C# で文字列を逆順にするコード&lt;/a&gt;)&lt;/p&gt;
&lt;h3 id="apply-rounded-corners-in-desktop-apps-windows-apps-microsoft-docs"&gt;Apply rounded corners in desktop apps - Windows apps | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/apps/desktop/modernize/apply-rounded-corners"&gt;https://docs.microsoft.com/en-us/windows/apps/desktop/modernize/apply-rounded-corners&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows 11 の角丸ウィンドウに対するアプリケーションで行う対応についてのドキュメント。&lt;/p&gt;
&lt;p&gt;デフォルトでは角丸となるが角丸とならないケース、意図的に角丸を抑制したいケースでの C#/WPF と C++ による対応方法についてなど。&lt;/p&gt;
&lt;h3 id="unoconf-2021"&gt;2021 - UnoConf 2021&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://unoconf.com/"&gt;https://unoconf.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Uno Platform のカンファレンスが2021年11月30日の正午 (日本時間 2021年12月1日午前2時) にオンラインで開催。&lt;/p&gt;
&lt;h3 id="aspnetcorediagnosticscenariosasyncguidance.md-at-master-davidfowlaspnetcorediagnosticscenarios-github"&gt;AspNetCoreDiagnosticScenarios/AsyncGuidance.md at master · davidfowl/AspNetCoreDiagnosticScenarios · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md"&gt;https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Devid Fowler 氏による非同期プログラミングのベストプラクティスガイド。&lt;/p&gt;
&lt;h3 id="hello-world-c-microsoft-docs"&gt;Hello World - C# の概要に関する対話型チュートリアル | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/tour-of-csharp/tutorials/hello-world"&gt;https://docs.microsoft.com/ja-jp/dotnet/csharp/tour-of-csharp/tutorials/hello-world&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Web ブラウザー上で Hello World を出力するような C# コードを記述、実行できるインタラクティブなチュートリアル。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1442194858425274369?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;All my tweets about C# 10 features in one thread. 🧵&lt;br&gt;&lt;br&gt;Retweets are appreciated 😊&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1442194858425274369?ref_src=twsrc%5Etfw"&gt;September 26, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;続くスレッドで C# 10 の数々の新機能を1枚画像で簡単に紹介。Constant string interpolation, Extended property patterns, File scoped namespaces, Global using などなど。&lt;/p&gt;
&lt;!-- https://twitter.com/timheuer/status/1440818713582702598?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;File-scoped namespaces by default...via &lt;a href="https://twitter.com/hashtag/editorconfig?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#editorconfig&lt;/a&gt; &lt;br&gt;&lt;br&gt;csharp_style_namespace_declarations = file_scoped&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/VisualStudio?ref_src=twsrc%5Etfw"&gt;&amp;#64;VisualStudio&lt;/a&gt; &lt;a href="https://t.co/GifWb0M9WM"&gt;pic.twitter.com/GifWb0M9WM&lt;/a&gt;&lt;/p&gt;&amp;mdash; Tim Heuer (&amp;#64;timheuer) &lt;a href="https://twitter.com/timheuer/status/1440818713582702598?ref_src=twsrc%5Etfw"&gt;September 22, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;EditorConfig ファイルに &lt;code&gt;csharp_style_namespace_declarations = file_scoped&lt;/code&gt; と設定しておくことで新しいクラスファイルを作成する際などで File-scoped namespace を使用したものを生成できるというテクニック。&lt;/p&gt;
&lt;!-- https://twitter.com/vs_debugger/status/1441092957277351951?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;The project menu in the solution explorer under the Debug now has the “Start Without Debugging” option. This would be helpful when you are working with a multi-project solution.  &lt;a href="https://twitter.com/hashtag/vstip?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#vstip&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/vsdebuggertip?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#vsdebuggertip&lt;/a&gt; &lt;a href="https://t.co/SPUXbQmqgN"&gt;pic.twitter.com/SPUXbQmqgN&lt;/a&gt;&lt;/p&gt;&amp;mdash; Visual Studio Debugger (&amp;#64;VS_Debugger) &lt;a href="https://twitter.com/VS_Debugger/status/1441092957277351951?ref_src=twsrc%5Etfw"&gt;September 23, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;ソリューションエクスプローラーのプロジェクトのコンテキストメニューに &amp;quot;Start Without Debugging&amp;quot; (デバッグなしで実行) が追加された。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1441576163734818817?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;The biggest problem with async await is the “colored functions” problem brilliantly explained by this article &lt;a href="https://t.co/hz5753G8DM"&gt;https://t.co/hz5753G8DM&lt;/a&gt;. It’s a never ending problem because everything can’t be async and          it’s viral. It’s not a new problem though, it’s always been this way.&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧🇺🇸💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1441576163734818817?ref_src=twsrc%5Etfw"&gt;September 25, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;&lt;code&gt;async&lt;/code&gt; メソッドは &lt;code&gt;async&lt;/code&gt; メソッドからしか呼べない話。&lt;/p&gt;
&lt;p&gt;Go や Java の Project Loom では viral (感染的) ではないアプローチを取っているが、.NET では難しい理由がある。例えば一つは相互運用のためのパフォーマンスにかかわる問題で .NET には高機能な FFI (P/Invoke) があるがグリーンスレッドからのコンテキストスイッチで問題となる。&lt;/p&gt;
&lt;p&gt;他に .NET にはメモリーをピンするという仕組みがあることもあげている。これはユーザーモードスレッドを実装したとするとスタックを動的に広げる必要がある際にコピーが必要となるが、メモリーのアドレスが変わってしまうためできない。代わりに linked list で持つなどが考えられるがパフォーマンスに問題が出る、また async state machine は .NET におけるある種の linked list としてもみえるといった話など。&lt;/p&gt;
&lt;!-- https://twitter.com/stevensanderson/status/1443288841964638220?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Using the new Native Dependencies feature for Blazor WebAssembly on .NET 6, I just managed to call Rust from C#, both running in the browser! It&amp;#39;s a direct p/invoke call - no JS interop. Now, what can we do with this new power? &lt;a href="https://t.co/VkyBekDWFR"&gt;pic.twitter.com/VkyBekDWFR&lt;/a&gt;&lt;/p&gt;&amp;mdash; Steve Sanderson (&amp;#64;stevensanderson) &lt;a href="https://twitter.com/stevensanderson/status/1443288841964638220?ref_src=twsrc%5Etfw"&gt;September 29, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 の Blazor WebAssemlby では Native Dependencies という機能により、C# から外部の WASM を JavaScript 相互運用なしで P/Invoke できるので Rust などを直接呼び出せるという話。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="obsolete-thumbtacked-assemblyname-properties-by-i3arnon-pull-request-59522-dotnetruntime"&gt;Obsolete thumbtacked AssemblyName properties by i3arnon · Pull Request #59522 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59522"&gt;https://github.com/dotnet/runtime/pull/59522&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AssemblyName&lt;/code&gt; の &lt;code&gt;ProcessorArchitecture&lt;/code&gt;, &lt;code&gt;HashAlgorithm&lt;/code&gt;, &lt;code&gt;VersionCompatibility&lt;/code&gt; は.NET Core では意味をなさないため非推奨としてマークするという PR。&lt;/p&gt;
&lt;h3 id="querystringenumerable-api-by-stevesandersonms-pull-request-33910-dotnetaspnetcore-github"&gt;QueryStringEnumerable API by SteveSandersonMS · Pull Request #33910 · dotnet/aspnetcore · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/pull/33910"&gt;https://github.com/dotnet/aspnetcore/pull/33910&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;クエリーストリングを Span ベースで取り扱って列挙する内部 API の実装 PR。&lt;code&gt;QueryStringEnumerable&lt;/code&gt; 自体は公開されていない。&lt;/p&gt;
&lt;h3 id="port-dllimportgenerator-to-dotnetruntime-by-jkoritzinsky-pull-request-59363-dotnetruntime"&gt;Port DllImportGenerator to dotnet/runtime by jkoritzinsky · Pull Request #59363 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59363"&gt;https://github.com/dotnet/runtime/pull/59363&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;P/Invoke のコードを Source Generator でコード生成をする DllImportGenerator を別リポジトリから dotnet/runtime に引っ越してきた PR。&lt;/p&gt;
&lt;p&gt;コードを生成することでマーシャリングの調査やカスタマイズが行いやすくなることが目的のよう。&lt;/p&gt;
&lt;h3 id="c-string-formatting-with-negative-numbers-are-not-working-as-expected-in-net5.0-issue-59570-dotnetruntime"&gt;C# string formatting with negative numbers are not working as expected in net5.0 · Issue #59570 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59570"&gt;https://github.com/dotnet/runtime/issues/59570&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;double&lt;/code&gt; の &lt;code&gt;-0.0&lt;/code&gt; を &lt;code&gt;ToString(&amp;quot;f1&amp;quot;)&lt;/code&gt; すると .NET Framework と .NET 5 で結果が違うという Issue。&lt;/p&gt;
&lt;p&gt;これは .NET Core 3.0 で小数点のパースとフォーマットに手が入った影響で正しく符号がつくようになったことによるもの。もし以前と同様の結果を得たい場合は &lt;code&gt;ToString(&amp;quot;0.0;-0.0;0.0&amp;quot;)&lt;/code&gt; という3セクションフォーマットで指定する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/floating-point-parsing-and-formatting-improvements-in-net-core-3-0/"&gt;Floating-Point Parsing and Formatting improvements in .NET Core 3.0 - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="augment-regex-extensibility-point-for-better-perf-and-span-based-matching-issue-59629-dotnetruntime"&gt;Augment Regex extensibility point for better perf and span-based matching · Issue #59629 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59629"&gt;https://github.com/dotnet/runtime/issues/59629&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Regex にパフォーマンスのためと、&lt;code&gt;Span&lt;/code&gt; ベースマッチングのために拡張ポイントを用意したいという話。&lt;/p&gt;
&lt;h3 id="stacktrace-explorer-implementation-by-ryzngard-pull-request-56315-dotnetroslyn"&gt;StackTrace Explorer Implementation by ryzngard · Pull Request #56315 · dotnet/roslyn&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/56315"&gt;https://github.com/dotnet/roslyn/pull/56315&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;テキストとしてクリップボードにコピーしたスタックトレースからジャンプしたりできる Stack Trace Explorer の実装 PR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.jetbrains.com/help/resharper/Reference__Windows__Stack_Trace_Explorer.html"&gt;Stack Trace Explorer window | ReSharper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="api-proposal-bool-hashset.updatet-value-out-t-actual-issue-59468-dotnetruntime"&gt;[API Proposal]: bool HashSet.Update(T value, out T actual) · Issue #59468 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59468#issuecomment-925609693"&gt;https://github.com/dotnet/runtime/issues/59468#issuecomment-925609693&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;元は &lt;code&gt;HashSet&amp;lt;T&amp;gt;&lt;/code&gt; に Update が欲しいという話で、やりたいこと的には &lt;code&gt;Dictionary&amp;lt;TKey, TValue&amp;gt;&lt;/code&gt; だが &lt;code&gt;Dictionary&lt;/code&gt; には &lt;code&gt;Update&lt;/code&gt; がないという話になったところ、&lt;code&gt;GetOrSet&lt;/code&gt; に相当するメソッドであれば .NET 6 RC1 で &lt;code&gt;CollectionsMarshal.GetValueRefOrAddDefault&lt;/code&gt; というものが増えたのでそれで実装できるというテクニック。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.runtime.interopservices.collectionsmarshal.getvaluereforadddefault?view=net-6.0"&gt;CollectionsMarshal.GetValueRefOrAddDefault&amp;lt;TKey,TValue&amp;gt;(Dictionary&amp;lt;TKey,TValue&amp;gt;, TKey, Boolean) メソッド (System.Runtime.InteropServices) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="api-proposal-file.writeallbytes-overload-for-span-and-readonlyspan-issue-59770-dotnetruntime"&gt;[API Proposal]: File.WriteAllBytes overload for Span and ReadOnlySpan · Issue #59770 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59770"&gt;https://github.com/dotnet/runtime/issues/59770&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;File.WriteAllBytes&lt;/code&gt; に &lt;code&gt;Span&lt;/code&gt;/&lt;code&gt;ReadOnlySpan&lt;/code&gt; を受けるオーバーロードが欲しいという提案。&lt;/p&gt;
&lt;p&gt;既に過去に似た提案があり、&lt;code&gt;File.Write*&lt;/code&gt;/&lt;code&gt;File.Append*&lt;/code&gt; は特に高レベルな API なのに対して &lt;code&gt;Span&lt;/code&gt; のような低レベルな API を組み合わせるのが不自然、これらのメソッドはパフォーマンスよりも利便性に特化していること、初心者向けのコア API を汚染することといった点でデザイン上なしという形で close されている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/35054"&gt;API proposal: Add File class method overloads for ReadOnlyMemory and ReadOnlySpan · Issue #35054 · dotnet/runtime · GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="monowasm-add-beginnings-of-support-for-wasi.by-vargaz-pull-request-59752-dotnetruntime-github"&gt;[mono][wasm] Add beginnings of support for WASI. by vargaz · Pull Request #59752 · dotnet/runtime · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59752"&gt;https://github.com/dotnet/runtime/pull/59752&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Mono WASM で WASI (WebAssemlby System Interface) のサポートを始めるという PR。&lt;/p&gt;
&lt;h3 id="add-initial-codespaces-support-for-dotnetruntime-by-eerhardt-pull-request-59723-dotnetruntime"&gt;Add initial codespaces support for dotnet/runtime by eerhardt · Pull Request #59723 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59723"&gt;https://github.com/dotnet/runtime/pull/59723&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;dotnet/runtime リポジトリを GitHub Codespaces 上でも編集/ビルドできるようにするための初期サポートの PR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-09-24: paint.net 4.3, Visual Studio 2022 for Mac Preview 1.4, Package Validation, SourceGear Bridge preview</title>
			<link>/2021/09/24/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/09/24/updates</guid>
			<pubDate>Fri, 24 Sep 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;p&gt;&lt;a href="https://blog.getpaint.net/2021/09/22/paint-net-4-3-is-now-available/"&gt;Paint.NET 4.3&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;.NET 5 への移行が完了し、パフォーマンスの向上や ARM64 対応などが行われました。5か月かかったそうですが比較的歴史のある有名な .NET アプリケーションが .NET Framework から .NET 5 へ移行しきった例という点はとても大きいのではないでしょうか。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#17.0.0-priv-pre.1.4"&gt;Visual Studio 2022 for Mac version 17.0 Private Preview 1.4&lt;/a&gt; がリリースされました。&lt;/p&gt;
&lt;p&gt;.NET 6 RC1 に対応し、Roslyn も Visual Studio 2022 (Windows) と同じバージョンに揃うことで C# 10 のコードも問題なく取り扱えるようになっています。また Xamarin プロジェクトの対応など一旦欠けていた機能が徐々に実装されてきているという状況です。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/package-validation/"&gt;Package Validation&lt;/a&gt; についての記事が .NET Blog に出ています。&lt;/p&gt;
&lt;p&gt;これはパッケージビルド時に API の互換性をチェックする仕組みを提供するものです。マルチターゲットなライブラリでのバイナリ互換性やパッケージバージョン間の互換性保てるよう、安全に開発するのに役立つと考えられます。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://ericsink.com/entries/sourcegear_bridge.html"&gt;SourceGear Bridge preview: Swift with .NET in Xcode&lt;/a&gt; という Swift と .NET を合体して動かして Xcode でコードを書けるようにする野心的なパッケージ/SDKのプレビューが公開されています。&lt;/p&gt;
&lt;p&gt;Eric Sink さんは元々 LLVM-to-CIL で Swift を .NET で動かすといったこともやっているのですが、今回のこれは .NET のアプリケーションが Swift のネイティブライブラリーをホストし、.NET のコードを呼び出せるバインディングを用意することで Swift から .NET のコードを呼び出すという仕組みのようです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ericsink.com/entries/swift_alpaca.html"&gt;Alpaca Preview: Native Swift with ASP.NET Core&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ericsink.com/entries/dotnet_swift.html"&gt;Llama Preview: Swift on .NET&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section"&gt;トピックス&lt;/h2&gt;
&lt;h3 id="paint.net-4.3-is-now-available-paint.net-blog"&gt;paint.net 4.3 is now available – paint.net blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.getpaint.net/2021/09/22/paint-net-4-3-is-now-available/"&gt;https://blog.getpaint.net/2021/09/22/paint-net-4-3-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Paint.NET 4.3 がリリース。&lt;/p&gt;
&lt;p&gt;5か月に及ぶ .NET Framework 4.8 から .NET 5 へ移行作業が完了。これによりパフォーマンスの向上、Self-contained 配布による .NET Framework インストールの不要化、ReadyToRun によるインストール時の NGEN ステップの不要化、ARM64 対応などの恩恵を受けられるようになった。&lt;/p&gt;
&lt;p&gt;今後 .NET 6 がリリースされ次第そちらへの移行していくとのこと。&lt;/p&gt;
&lt;h3 id="visual-studio-2022-for-mac-v17.0-preview-release-notes-microsoft-docs"&gt;Visual Studio 2022 for Mac v17.0 Preview - Release Notes | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#17.0.0-priv-pre.1.4"&gt;https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#17.0.0-priv-pre.1.4&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac version 17.0 Private Preview 1.4 がリリース。(プライベートプレビュー中のため利用するには登録が必要)&lt;/p&gt;
&lt;p&gt;.NET 6 RC1 の対応、Roslyn 4.0 への更新と C# 10 対応、Xamarin プロジェクトの対応など。その他プロジェクト設定などの IDE の未実装な部分の実装や改善。&lt;/p&gt;
&lt;h3 id="package-validation.net-blog"&gt;Package Validation - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/package-validation/"&gt;https://devblogs.microsoft.com/dotnet/package-validation/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の SDK で使用できるようになった Package Validation という MSBuild SDK パッケージについて。&lt;/p&gt;
&lt;p&gt;Package Validation は次のようなパッケージビルド時の API 互換性チェックの仕組みを提供する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;マルチターゲットでの互換性&lt;/li&gt;
&lt;li&gt;ベースライン間のパッケージの互換性&lt;/li&gt;
&lt;li&gt;ランタイム間の互換性&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;マルチターゲットでの互換性のチェックは例えば .NET Standard 2.0 と .NET 6 をターゲットにしたライブラリで API のバイナリ互換性が壊れてしまう例がある。記事では次のようなコードが例としてあげられている。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#if NET6_0_OR_GREATER
    public void DoStringManipulation(ReadOnlySpan&amp;lt;char&amp;gt; input)
    {
        // use spans to do string operations.
    }
#else
    public void DoStringManipulation(string input)
    {
        // Do some string operations.
    }
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;元々 .NET Standard 2.0 で参照されていた場合 &lt;code&gt;DoStringManipulation(string input)&lt;/code&gt; を使用できるが、.NET 6 以降の環境に移った場合は &lt;code&gt;DoStringManipulation(ReadOnlySpan&amp;lt;char&amp;gt; input)&lt;/code&gt; のみが使用できる状態となるため &lt;code&gt;DoStringManipulation(string input)&lt;/code&gt; がないというエラーとなる。ソースコードレベルでの互換性はあるので再コンパイルすれば再び正しく動作するが自身のコードでない場合は難しいといったことが発生する。これは &lt;code&gt;DoStringManipulation(string input)&lt;/code&gt; が &lt;code&gt;NET6_0_OR_GREATER&lt;/code&gt; でも残っていれば問題とならない。このようなコードを検出してパッケージのビルドエラーとする。&lt;/p&gt;
&lt;p&gt;ベースライン間のパッケージの互換性チェックは指定した NuGet パッケージバージョンを API のベースラインとしてバイナリ互換性をチェックする仕組み。&lt;/p&gt;
&lt;p&gt;ランタイム間の互換性チェックは Unix や Windows のようなランタイム固有で持つ API が異なる場合、固有のランタイムをターゲットとした場合に互換性のある API があるかどうかチェックする仕組み。記事には次のようなコード例がある。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;#if Unix
    public static void Open(string path, bool securityDescriptor)
    {
        // call unix specific stuff
    }
#else
    public static void Open(string path)
    {
        // call windows specific stuff
    }
#endif
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;このコードはランタイムが Unix をターゲットにしている場合には &lt;code&gt;Open(string path, bool securityDescriptor)&lt;/code&gt; を使用できるが、コード使用者はランタイムを限定しない場合 &lt;code&gt;Open(string path)&lt;/code&gt; を呼び出すコードを記述する。そのコードを Unix 環境下で実行した場合メソッドが存在しないエラーとなってしまう。このようなケースでは Unix 環境下において &lt;code&gt;Open(string path)&lt;/code&gt; を呼び出した場合に例外を投げるような形となるほうが望ましく、そういったケースを検出できる。&lt;/p&gt;
&lt;h3 id="sourcegear-bridge-preview-swift-with.net-in-xcode"&gt;SourceGear Bridge preview: Swift with .NET in Xcode&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ericsink.com/entries/sourcegear_bridge.html"&gt;https://ericsink.com/entries/sourcegear_bridge.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 以外の言語と .NET をブリッジして Xcode からコード編集できるようにする SourceGear Bridge がプレビュー。現時点では Swift がターゲット。&lt;/p&gt;
&lt;p&gt;SourceGear Bridge を利用すると ASP.NET Core のコードを Swift で記述するといったことが可能になる。これは .NET から Swift プログラムをバインディングと共にホストする仕組みと Swift のコードから .NET を呼び出せるようにする仕組みによって実現されている。&lt;/p&gt;
&lt;p&gt;async/await のサポートなども含めて、プロダクションレディを目指して開発を進めるとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://ericsink.com/entries/swift_alpaca.html"&gt;Alpaca Preview: Native Swift with ASP.NET Core&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="introducing-collection-of-new-visual-studio-themes-visual-studio-blog"&gt;Introducing Collection of New Visual Studio Themes! - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/custom-themes/"&gt;https://devblogs.microsoft.com/visualstudio/custom-themes/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 でテーマをインストールして使用できるようになったことの紹介記事。&lt;/p&gt;
&lt;p&gt;コミュニティーによるテーマ (Ayu, Dacula, ...) や Visual Studio チーム提供の Theme Pack (Light+, Monokai, ...) の紹介とテーマの切り替え方法について。また Visual Studio Code のテーマからのコンバーターがあるということにも触れている(テーマの手書きは現実的ではないのでコンバーターの利用が事実上必須と思われる)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/theme-converter-for-vs"&gt;microsoft/theme-converter-for-vs: CLI tool that allows you to convert your VS Code color theme to a VS 2022 color theme.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="http3-support-in.net-6.net-blog"&gt;HTTP/3 support in .NET 6 - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/http-3-support-in-dotnet-6/"&gt;https://devblogs.microsoft.com/dotnet/http-3-support-in-dotnet-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 での HTTP/3 のプレビューサポートについての記事。&lt;/p&gt;
&lt;p&gt;HTTP/3 がなぜ重要か、.NET 6 では QUIC の実装として何を使用しているか、.NET 6 での利用方法について。&lt;/p&gt;
&lt;p&gt;.NET での QUIC 実装は MSQuic を使用しているが、Linux では QUIC での TLS のハンドシェイク実装に必要な API が OpenSSL にないため、Akamai と協力し QuicTLS としてフォークしたものに QUIC に必要な最低限の変更を加えたものを静的リンクするようにした。&lt;/p&gt;
&lt;p&gt;.NET アプリケーションから QUIC を扱うための &lt;code&gt;System.Net.Quic&lt;/code&gt; API は .NET 7 で公開するとしている。&lt;/p&gt;
&lt;p&gt;また macOS では HTTP/3 のサポートが含まれていない。これは .NET の TLS の実装に macOS の SecureTransport を使用していることで QUIC に必要な API が足りないことによるもの。OpenSSL を使用してのサポートでは証明書管理が OS と別になるため、そのような依存は増やすことは避けたとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/msquic"&gt;microsoft/msquic: Cross-platform, C implementation of the IETF QUIC protocol.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/QuicTLS/openssl"&gt;quictls/openssl: TLS/SSL and crypto library with QUIC APIs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="xamarin.forms-5.0.0.2125-5.0.0-service-release-5-release-notes-xamarin-microsoft-docs"&gt;Xamarin.Forms 5.0.0.2125 (5.0.0 Service Release 5) Release Notes - Xamarin | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/xamarin/xamarin-forms/release-notes/5.0/5.0.0-sr5#september-17-2021---xamarinforms-5002125-500-service-release-5"&gt;https://docs.microsoft.com/en-us/xamarin/xamarin-forms/release-notes/5.0/5.0.0-sr5#september-17-2021---xamarinforms-5002125-500-service-release-5&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xamarin.Forms 5.0.0 Service Release 5 がリリース。&lt;/p&gt;
&lt;p&gt;主にバグ修正。また依存している AndroidX ライブラリのバージョン引き上げも含まれる。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/xamarin/Xamarin.Forms/pull/14506"&gt;Androidx bumps by PureWeen · Pull Request #14506 · xamarin/Xamarin.Forms&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="microsoftxamarin-community-toolkit.net-maui-compatibility-package"&gt;MicrosoftがXamarin Community Toolkit用の.NET MAUI Compatibility Packageをリリース&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.infoq.com/jp/news/2021/09/community-toolkit-maui-compat/"&gt;https://www.infoq.com/jp/news/2021/09/community-toolkit-maui-compat/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xamarin Community Toolkit の .NET MAUI Compatibility Package についての記事。&lt;/p&gt;
&lt;h3 id="minimal-apis-in.net-6-but-where-are-the-unit-tests"&gt;Minimal APIs in .NET 6 but where are the Unit Tests?&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/minimal-apis-in-net-6-but-where-are-the-unit-tests"&gt;https://www.hanselman.com/blog/minimal-apis-in-net-6-but-where-are-the-unit-tests&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core の Minimal APIs でユニットテストを書くときはどうするのかという記事。これは単純に &lt;code&gt;WebApplicationFactory&amp;lt;T&amp;gt;&lt;/code&gt; を継承したテストアプリケーションクラスを作れば従来通り呼び出しテストを書くことができる。(参考リポジトリのコードを見るとこの記事内のコードは &lt;code&gt;Todo&lt;/code&gt; をセットしていて間違っている気がする…)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/DamianEdwards/MinimalApiPlayground/blob/d9e1bcb46b964bdd8da4074f27e44567f09c60e5/tests/MinimalApiPlayground.Tests/PlaygroundApplication.cs"&gt;MinimalApiPlayground/PlaygroundApplication.cs at d9e1bcb46b964bdd8da4074f27e44567f09c60e5 · DamianEdwards/MinimalApiPlayground&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="websocket-per-message-compression-in-asp.net-core-6"&gt;WebSocket per-message compression in ASP.NET Core 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.tpeczek.com/2021/09/websocket-per-message-compression-in.html"&gt;https://www.tpeczek.com/2021/09/websocket-per-message-compression-in.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core で WebSocket のメッセージ単位の圧縮がサポートされ、それを利用する方法についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;DangerousEnableCompression&lt;/code&gt; プロパティという危険そうな名前の理由についても触れている。これはサポートされていないクライアントとのネゴシエーションで失敗するからといった理由ではなく、CRIME/BREACH 攻撃が可能となってしまうセキュリティー上の理由。(実際サポートされていなければ非圧縮にフォールバックする)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.net.websockets.websocketcreationoptions.dangerousdeflateoptions?view=net-6.0"&gt;WebSocketCreationOptions.DangerousDeflateOptions Property (System.Net.WebSockets) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/aspnetcore/blob/v6.0.0-rc.1.21452.15/src/Http/Http.Features/src/WebSocketAcceptContext.cs#L26-L32"&gt;aspnetcore/WebSocketAcceptContext.cs at v6.0.0-rc.1.21452.15 · dotnet/aspnetcore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="ms-graph-blazor-webassembly-and-azure-static-web-apps"&gt;MS Graph, Blazor WebAssembly and Azure Static Web Apps&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/azure/ms-graph-blazor-webassembly-and-azure-static-web-apps-3p1d"&gt;https://dev.to/azure/ms-graph-blazor-webassembly-and-azure-static-web-apps-3p1d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Azure Static Web Apps にホストした Blazor WebAssembly のアプリケーションから Azure Active Directory と Graph API を使用して、ユーザー認証と情報取得を行う方法についての記事。&lt;/p&gt;
&lt;h3 id="pattern-matching-examples-in-c"&gt;Pattern Matching Examples in C#&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/this-is-learning/pattern-matching-examples-in-c-3g74"&gt;https://dev.to/this-is-learning/pattern-matching-examples-in-c-3g74&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;様々なパターンマッチの書き方の紹介の記事。&lt;/p&gt;
&lt;p&gt;C# 10 で導入された Extended property patterns (ネストしたプロパティアクセスを &lt;code&gt;.&lt;/code&gt; で行える) についても。&lt;/p&gt;
&lt;h3 id="raspberrypi-3b.net5l"&gt;RaspberryPi 3B+と.NET5で電子工作したい(準備/Lチカ)&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/tera1707/articles/c458d65fee4cdc"&gt;https://zenn.dev/tera1707/articles/c458d65fee4cdc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Raspberry Pi 3B+ 上で .NET 5 アプリケーションからハードウェアをコントロールする導入記事。&lt;/p&gt;
&lt;p&gt;Raspberry Pi への OS インストールから &lt;code&gt;System.Device.Gpio&lt;/code&gt; を使用してLチカ(LED を光らせる)するプログラムを実行するまでが書かれている。また続く記事で &lt;code&gt;System.Device.Pwm&lt;/code&gt; を使用したハードウェア PWM についても触れている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zenn.dev/tera1707/articles/f33178395a14d8"&gt;RaspberryPi 3B+と.NET5で電子工作(ハードウェアPWM)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="comparing-webapplicationbuilder-to-the-generic-host-exploring.net-core-6-part-2"&gt;Comparing WebApplicationBuilder to the Generic Host: Exploring .NET Core 6 - Part 2&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-2-comparing-webapplicationbuilder-to-the-generic-host/"&gt;https://andrewlock.net/exploring-dotnet-6-part-2-comparing-webapplicationbuilder-to-the-generic-host/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の ASP.NET Core で従来の Generic Host を使用する形から、&lt;code&gt;WebApplicationBuilder&lt;/code&gt; を使用する形へと変わったことについての記事。&lt;/p&gt;
&lt;p&gt;ASP.NET Core 2.x の WebHost と .NET 5 の Generic Host からの流れについても触れている。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;WebApplicationBuilder&lt;/code&gt; は &lt;code&gt;Configuration&lt;/code&gt;, &lt;code&gt;Services&lt;/code&gt;, &lt;code&gt;Logging&lt;/code&gt; そして &lt;code&gt;IHostBuilder&lt;/code&gt; と &lt;code&gt;IWebHostBuilder&lt;/code&gt; の設定を提供する、パイプライン以外を構築するためのビルダークラスとなった。またビルダーの &lt;code&gt;Build&lt;/code&gt; で生成されるインスタンスである &lt;code&gt;WebApplication&lt;/code&gt; はミドルウェアパイプラインを構築するためのもので、&lt;code&gt;IHost&lt;/code&gt;, &lt;code&gt;IApplicaitonBuilder&lt;/code&gt;, &lt;code&gt;IEndpointRouteBuilder&lt;/code&gt; を実装しているため、Routing や Endpoint の Use が不要となり簡潔な形となった、といった話。&lt;/p&gt;
&lt;h3 id="unityasmrefasmdefinternalassembly-definition-reference-files-qiita"&gt;【Unity】asmref（asmdefではない）を使うとinternalアクセスできて便利【Assembly Definition Reference Files】 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/su10/items/7773715c8e43058e533c"&gt;https://qiita.com/su10/items/7773715c8e43058e533c&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Unity 2019.2.0 で追加された Assembly Definition Reference (.asmref) についての記事。&lt;/p&gt;
&lt;p&gt;Assembly Definition Reference は Assembly Definition のディレクトリにソースコードを差し込めるようにするという仕組み。記事では利用用途として「スクリプトの配置」「既存のアセットやパッケージの拡張」「Unity のパッケージの internal へのアクセス」といった例が挙げられている。&lt;/p&gt;
&lt;h3 id="entity-framework-core-6-compiled-models"&gt;Entity Framework Core 6 の Compiled Models を試した - しばやん雑記&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.shibayan.jp/entry/20210921/1632210374"&gt;https://blog.shibayan.jp/entry/20210921/1632210374&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 6 で実装された Compiled Models についての記事。&lt;/p&gt;
&lt;p&gt;Compiled Models はあらかじめ dotnet-ef ツールで構築済み Model の生成を構築を行ったコードを生成しておくことでスタートアップパフォーマンスを向上する機能。記事ではコード生成と参照方法のほか、Lazy Loading に非対応なこと、GitHub Actions でコード生成を行う例などについて触れている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-entity-framework-core-6-0-preview-5-compiled-models/"&gt;Announcing Entity Framework Core 6.0 Preview 5: Compiled Models - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;ちなみに .NET Blog によると Source Generator として実装されなかったのは Visual Studio 内でコンテキストをビルド/実行することになり、Visual Studio そのものの安定性が損なわれてしまう可能性があったからとのこと。&lt;/p&gt;
&lt;h3 id="net-6-blazor-aka-errorboundary"&gt;.NET 6 の Blazor で改善されたエラー処理を使ってみる aka ErrorBoundary&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/okazuki/articles/blazor-net6-errorboundary"&gt;https://zenn.dev/okazuki/articles/blazor-net6-errorboundary&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Blazor で導入されたエラーハンドリングのためのコンポーネント &lt;code&gt;ErrorBoundary&lt;/code&gt; についての記事。&lt;/p&gt;
&lt;p&gt;今まではコンポーネントが例外をスローした場合、アプリケーションのグローバルでキャッチする形になっていたが &lt;code&gt;ErrorBoundary&lt;/code&gt; コンポーネントを使うことで例外を局所化してメッセージを出すといったことができるようになる。記事ではエラーが発生した後、復旧する方法についても触れられている。&lt;/p&gt;
&lt;h3 id="getting-started-with-roslyn-code-analysis"&gt;Getting started with Roslyn code analysis&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/timur_kh/getting-started-with-roslyn-code-analysis-1aki"&gt;https://dev.to/timur_kh/getting-started-with-roslyn-code-analysis-1aki&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roslyn でソリューションを開いてコードを解析するまでの導入についての簡単な記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;MSBuildLocator&lt;/code&gt; と &lt;code&gt;MSBuildWorkspace&lt;/code&gt; を使用してソリューションを開き、&lt;code&gt;CSharpSyntaxWalker&lt;/code&gt; でシンタックスツリーをトラバースする方法についてなど。&lt;/p&gt;
&lt;h3 id="async-processing-of-long-running-tasks-in-asp.net-core"&gt;Async processing of long-running tasks in ASP.NET Core&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.elmah.io/async-processing-of-long-running-tasks-in-asp-net-core/"&gt;https://blog.elmah.io/async-processing-of-long-running-tasks-in-asp-net-core/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ConcurrentQueue&amp;lt;T&amp;gt;&lt;/code&gt; と &lt;code&gt;IHostedService&lt;/code&gt; を使用して ASP.NET Core アプリケーションに簡単なバックグラウンド処理を実装する記事。&lt;/p&gt;
&lt;p&gt;注意書きではとっかかりとしてはよいがロバストな構成とするため Hangfire や Quartz.NET の利用の検討するように触れられている。&lt;/p&gt;
&lt;h3 id="introduction-to-system.text.json-through-examples-code-maze"&gt;Introduction to System.Text.Json Through Examples - Code Maze&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://code-maze.com/introduction-system-text-json-examples/"&gt;https://code-maze.com/introduction-system-text-json-examples/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;System.Text.Json&lt;/code&gt; の各種クラスなどの利用方法についての記事。&lt;/p&gt;
&lt;p&gt;シリアライズ/デシリアライズの方法や簡単なカスタマイズ方法 JsonDocument について、.NET 5 以降で使用できる HttpClient に対する拡張メソッドの紹介など。&lt;/p&gt;
&lt;h3 id="platform-vs.platformtarget-in-any.net-build"&gt;Platform vs. PlatformTarget In Any .NET Build&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/benvillalobos/platform-vs-platformtarget-in-any-net-build-252b"&gt;https://dev.to/benvillalobos/platform-vs-platformtarget-in-any-net-build-252b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MSBuild の &lt;code&gt;Platform&lt;/code&gt; と &lt;code&gt;PlatformTarget&lt;/code&gt; プロパティについて。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;PlatformTarget&lt;/code&gt; はコンパイラーに渡されるもので、.NET Framework (non-SDK スタイル)のプロジェクトでは &lt;code&gt;Platform&lt;/code&gt; から、SDK スタイルのプロジェクトでは &lt;code&gt;Platform&lt;/code&gt; または &lt;code&gt;RuntimeIdentifier&lt;/code&gt; から定義される。その実際に定義されるまでの流れなどが解説されている。&lt;/p&gt;
&lt;h2 id="section-2"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="byme8zeroioc-zeroioc-is-reflectionless-ioc-container-for.net"&gt;byme8/ZeroIoC: ZeroIoC is reflectionless IoC Container for .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/byme8/ZeroIoC"&gt;https://github.com/byme8/ZeroIoC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Source Generator でコード生成することで初回実行も含めて高速な動作を目的とした IoC コンテナー。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dev.to/byme8/zeroioc-ioc-container-powered-via-source-generators-339c"&gt;ZeroIoC - IoC container powered via Source Generators&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="net-6-asp.net-core-migration"&gt;.NET 6 ASP.NET Core Migration&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://gist.github.com/davidfowl/0e0372c3c1d895c3ce195ba983b1e03d"&gt;https://gist.github.com/davidfowl/0e0372c3c1d895c3ce195ba983b1e03d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;David Fowler 氏による .NET 6 の ASP.NET Core に移行するためのガイド。&lt;/p&gt;
&lt;h3 id="section-4"&gt;ツイート&lt;/h3&gt;
&lt;!-- https://twitter.com/kzu/status/1438634365869768707?s=12 --&gt;
&lt;blockquote class="twitter-tweet" data-conversation="none"&gt;&lt;p lang="en" dir="ltr"&gt;Hmm.... seems like &lt;a href="https://twitter.com/nuget?ref_src=twsrc%5Etfw"&gt;&amp;#64;nuget&lt;/a&gt; install/uninstall icon could use dark theme compatible versions 🤔 &lt;a href="https://t.co/mBYqyIOm1A"&gt;pic.twitter.com/mBYqyIOm1A&lt;/a&gt;&lt;/p&gt;&amp;mdash; Daniel Cazzulino (&amp;#64;kzu) &lt;a href="https://twitter.com/kzu/status/1438634365869768707?ref_src=twsrc%5Etfw"&gt;September 16, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Visual Studio 2022 のダークテーマ対応が進んだ結果、NuGet アイコンが透過で黒いものの場合に視認性が悪くなってしまうという話。&lt;/p&gt;
&lt;!-- https://twitter.com/shanselman/status/1438657727417315328?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Just learned that in the .NET CLR Header MetadataHeader Signature is the bytes 42 53 4A 42, which is HEX ASCII for &amp;#39;BSJB&amp;#39; which is the initials for Brian Harry, Susan Radke-Sproull, Jason Zander &amp;amp; Bill Evans, who worked on it! Just learned this via &lt;a href="https://twitter.com/robcaron?ref_src=twsrc%5Etfw"&gt;&amp;#64;robcaron&lt;/a&gt; about &lt;a href="https://twitter.com/jlzander?ref_src=twsrc%5Etfw"&gt;&amp;#64;jlzander&lt;/a&gt;&lt;/p&gt;&amp;mdash; Scott Hanselman (&amp;#64;shanselman) &lt;a href="https://twitter.com/shanselman/status/1438657727417315328?ref_src=twsrc%5Etfw"&gt;September 17, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET CLR のヘッダーのメタデータヘッダーシグネチャーが &lt;code&gt;42 53 4A 42&lt;/code&gt; で ASCII では 'BSJB' となり、Brian Harry, Susan Radke-Sproull, Jason Zander, Bill Evans (.NET Framework の開発者)のイニシャルであるという小ネタ。これは &lt;a href="https://www.oreilly.com/library/view/programming-in-the/0201770180/"&gt;Programming in the .NET Environment (2002)&lt;/a&gt; の序文に書かれている。&lt;/p&gt;
&lt;!-- https://twitter.com/konradkokosa/status/1438816800368640000?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Generational aware analysis added in .NET 5 is just a killer feature! Now you may have a full insight what was alive in a given generation AND from which generations🤯 &lt;a href="https://t.co/F6a6QcdbzX"&gt;pic.twitter.com/F6a6QcdbzX&lt;/a&gt;&lt;/p&gt;&amp;mdash; Konrad Kokosa (&amp;#64;konradkokosa) &lt;a href="https://twitter.com/konradkokosa/status/1438816800368640000?ref_src=twsrc%5Etfw"&gt;September 17, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 5 で PerfView でのスナップショット解析で GC のジェネレーション単位の分類ができるようになったという話。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1439336245730025472?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;You can also declare the Program class as partial and add things to it while keeping your top level statements. This makes it possible to expose properties/fields/etc, declare a base class or implement an interface on the type that hosts the Program&amp;#39;s entry point.&lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://t.co/er9oSTc0Gf"&gt;pic.twitter.com/er9oSTc0Gf&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1439336245730025472?ref_src=twsrc%5Etfw"&gt;September 18, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;.NET 6 RC1 以降で Top-level statements のコードを書いた際に生成される Program クラスにアクセスできるようになった。また、Program クラスは partial として生成されるので partial class を定義することで拡張できるというテクニック。&lt;/p&gt;
&lt;!-- https://twitter.com/mattleibow/status/1439036843287269378?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Literally just finished the pre-alpha-hack-poc for &lt;a href="https://twitter.com/hashtag/SkiaSharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#SkiaSharp&lt;/a&gt; running on &lt;a href="https://twitter.com/hashtag/Blazor?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#Blazor&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/WebAssembly?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#WebAssembly&lt;/a&gt; &lt;a href="https://t.co/s4Dt8Kj1em"&gt;https://t.co/s4Dt8Kj1em&lt;/a&gt; &lt;a href="https://t.co/Ys6tTvB2dy"&gt;pic.twitter.com/Ys6tTvB2dy&lt;/a&gt;&lt;/p&gt;&amp;mdash; Matthew &amp;quot;V 50%&amp;quot; Leibowitz (&amp;#64;mattleibow) &lt;a href="https://twitter.com/mattleibow/status/1439036843287269378?ref_src=twsrc%5Etfw"&gt;September 18, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;SkiaSharp と Blazor WASM で Canvas 操作などを行える PoC ができたという話。&lt;/p&gt;
&lt;!-- https://twitter.com/okyrylchuk/status/1438926317383294982?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Previous C# versions don&amp;#39;t support field initializers in the structs.&lt;br&gt;&lt;br&gt;C# 10 fixes it and closes the gap between struct and class declarations.&lt;br&gt;&lt;br&gt;If the struct has field initializers, the compiler will synthesize a public parameterless constructor.&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/coding?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#coding&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/devcommunity?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#devcommunity&lt;/a&gt; &lt;a href="https://t.co/5XVfU0xQTS"&gt;pic.twitter.com/5XVfU0xQTS&lt;/a&gt;&lt;/p&gt;&amp;mdash; Oleg Kyrylchuk (&amp;#64;okyrylchuk) &lt;a href="https://twitter.com/okyrylchuk/status/1438926317383294982?ref_src=twsrc%5Etfw"&gt;September 17, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;C# 10 では struct に対してフィールド初期化子を記述した場合、パラメータなしのコンストラクターが自動生成されるようになった。なおパラメータありコンストラクターを記述した場合はパラメータなしコンストラクターは生成されないので注意。&lt;/p&gt;
&lt;!-- https://twitter.com/konradkokosa/status/1440344667820752907?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;TIL: PerfView has live events view command. For example, to observe all .NET exceptions on the machine:&lt;br&gt;.\PerfView.exe UserCommand Listen Microsoft-Windows-DotNETRuntime:0x8000:Verbose:&amp;#64;EventIDsToEnable=80 &lt;a href="https://t.co/Pdfv89xpEK"&gt;pic.twitter.com/Pdfv89xpEK&lt;/a&gt;&lt;/p&gt;&amp;mdash; Konrad Kokosa (&amp;#64;konradkokosa) &lt;a href="https://twitter.com/konradkokosa/status/1440344667820752907?ref_src=twsrc%5Etfw"&gt;September 21, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;&lt;code&gt;.\PerfView.exe UserCommand Listen Microsoft-Windows-DotNETRuntime:0x8000:Verbose:&amp;#64;EventIDsToEnable=80&lt;/code&gt; を実行することでコンピューター上のすべての .NET アプリケーションのあらゆる Exception を観測できるというテクニック。&lt;/p&gt;
&lt;!-- https://twitter.com/kirillosenkov/status/1440192351528374279?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Folks, a quick PSA about large MSBuild builds on CI.&lt;br&gt;&lt;br&gt;Too often I see a build taking upwards of 10-20 minutes with all sorts of text loggers (file loggers, console loggers), worst of all text loggers of diagnostic verbosity.&lt;br&gt;&lt;br&gt;Text loggers absolutely kill your build performance.&lt;/p&gt;&amp;mdash; Kirill Osenkov (&amp;#64;KirillOsenkov) &lt;a href="https://twitter.com/KirillOsenkov/status/1440192351528374279?ref_src=twsrc%5Etfw"&gt;September 21, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;CI などでの巨大な MSBuild ビルドを実行するときはテキストログを止めるとパフォーマンス向上できるという話。スレッドにはその方法や binlog の使用を進めるといった話も。&lt;/p&gt;
&lt;!-- https://twitter.com/jaredpar/status/1439973140910641155?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;This will not RTM in C# 10 as there are significant toolchain issues that need to be sorted out before they can be generally used.&lt;/p&gt;&amp;mdash; Jared Parsons (&amp;#64;jaredpar) &lt;a href="https://twitter.com/jaredpar/status/1439973140910641155?ref_src=twsrc%5Etfw"&gt;September 20, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Generic 属性は .NET 6 にはツールチェイン側の対応の都合などもあり入らず(C++/CLI コンパイラーがクラッシュするなど)、.NET 7 / C# 11 になるという話。&lt;/p&gt;
&lt;!-- https://twitter.com/davidfowl/status/1439630163872944129?s=12 --&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;This is the best thing I&amp;#39;ve found today. The [BestFriend] attribute 🤣 &lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://t.co/VgN9peJFHj"&gt;https://t.co/VgN9peJFHj&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1439630163872944129?ref_src=twsrc%5Etfw"&gt;September 19, 2021&lt;/a&gt;&lt;/blockquote&gt;
&lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;ML.NET に &lt;code&gt;BestFriend&lt;/code&gt; 属性という変わった名前の属性があるという話。&lt;/p&gt;
&lt;p&gt;この属性は外部のアセンブリから内部 (internal) に対してアクセス可能であることを示すもので、外部のアセンブリは &lt;code&gt;WantsToBeBestFriends&lt;/code&gt; 属性を持つ。&lt;code&gt;InternalsVisibleTo&lt;/code&gt; 属性との違いは &lt;code&gt;BestFriend&lt;/code&gt; 属性自体は特別な効果を持つものではなく &lt;code&gt;InternalsVisibleTo&lt;/code&gt; 属性で internal にアクセスできるようになっている前提で、各種 internal なメンバーが外部のアセンブリからのアクセスを意図しているかどうかを Analyzer でチェックするためのマーカー。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/machinelearning/blob/3bf8cba75fd94241d2f918fc5330e8cda3b36432/src/Microsoft.ML.Core/BestFriendAttribute.cs#L25"&gt;machinelearning/BestFriendAttribute.cs at 3bf8cba75fd94241d2f918fc5330e8cda3b36432 · dotnet/machinelearning&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/machinelearning/blob/3bf8cba75fd94241d2f918fc5330e8cda3b36432/tools-local/Microsoft.ML.InternalCodeAnalyzer/BestFriendAnalyzer.cs"&gt;machinelearning/BestFriendAnalyzer.cs at 3bf8cba75fd94241d2f918fc5330e8cda3b36432 · dotnet/machinelearning&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-09-17: .NET 6 RC1, Visual Studio 2022 Preview 4, WinUI 2.7, Uno Platform 3.10</title>
			<link>/2021/09/17/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/09/17/updates</guid>
			<pubDate>Fri, 17 Sep 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;h2 id="section"&gt;主なトピックス&lt;/h2&gt;
&lt;p&gt;.NET 6 RC 1 と Visual Studio 2022 Preview 4 がリリースされました。RC ということで若干の breaking changes はありますが GA に向けたステップといったリリースです。Preview から Go live ライセンスとなったのでプロダクション環境での利用が可能になります。&lt;/p&gt;
&lt;p&gt;また、マルチプラットフォームアプリを作るためのフレームワーク MAUI は .NET 6 には入らないことなどがアナウンスされています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-1/"&gt;Announcing .NET 6 Release Candidate 1 - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-preview-4-is-now-available/"&gt;Visual Studio 2022 Preview 4 is now available! - Visual Studio Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-dotnet-maui/"&gt;Update on .NET Multi-platform App UI (.NET MAUI) - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Uno Platform 3.10 がリリースされました。.NET 6 RC1 への対応や Windows 11 のスタイルなどに対応したようです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://platform.uno/blog/uno-platform-3-10-day-0-support-for-net-6-rc1-winui-infobadge-windows-11-fluent-styles/"&gt;Uno Platform 3.10: Day-0 support for .NET 6 RC1, WinUI InfoBadge, Windows 11 Fluent Styles&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Silverlight のオープンソース代替実装、OpenSilver のベータがリリースされました。これは C#/WPF を Web 技術上で動かす CSHTML5 をベースとして Silverlight のコードを Web 技術上で動かすものです。Silverlight は2021年10月12日でサポート終了するため、その延命処置としてといった目的が大きそうです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://opensilver.net/announcements/introducing-opensilver.aspx"&gt;Introducing OpenSilver&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NETのクラスライブラリ設計 改訂新版の予約が Amazon でできるようになりました。10月7日に発売だそうです。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://www.amazon.co.jp/dp/4296080040"&gt;.NETのクラスライブラリ設計 改訂新版 (マイクロソフト関連書) | Krzysztof Cwalina、Jeremy Barton、Brad Abrams, 猪股 健太郎、河合 宜文 (監訳), 藤原 雄介 |本 | 通販 | Amazon&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;ヘッドライン&lt;/h2&gt;
&lt;h3 id="announcing.net-6-release-candidate-1.net-blog"&gt;Announcing .NET 6 Release Candidate 1 - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-1/"&gt;https://devblogs.microsoft.com/dotnet/announcing-net-6-release-candidate-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 Release Candidate 1 がリリース。RC1 以降では機能の追加などから GA に向けて品質の向上にフォーカスする形。
また、このバージョンから &amp;quot;go live&amp;quot; ライセンスとなり実運用環境での使用がサポートされる。
Visual Studio 2022 Preview 4と共に使用することが前提で Visual Studio 2022 for Mac Preview 1 は追って対応。&lt;/p&gt;
&lt;p&gt;記事ではソースからビルドすること(.NET 6 で tarball からビルドできるようになったなど)、Profile-guided optimization、Crossgen2、セキュリティー関連についてなどが触れられている。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-6-rc-1/"&gt;ASP.NET Core updates in .NET 6 Release Candidate 1 - ASP.NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-dotnet-maui/"&gt;Update on .NET Multi-platform App UI (.NET MAUI) - .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="visual-studio-2022-preview-4-is-now-available-visual-studio-blog"&gt;Visual Studio 2022 Preview 4 is now available! - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/visual-studio-2022-preview-4-is-now-available/"&gt;https://devblogs.microsoft.com/visualstudio/visual-studio-2022-preview-4-is-now-available/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 Preview 4 がリリース。&lt;/p&gt;
&lt;p&gt;ファイル内検索が改善され、大きいソリューションなどでは3倍近く早くなった。&lt;/p&gt;
&lt;p&gt;ブレークポイントの条件に &amp;quot;Dependent Breakpoint&amp;quot; という「特定のブレークポイントにかかっていた場合にブレークする」という設定の追加。ASP.NET での CSS 同期や MAUI サポートを初めとするホットリロード機能の強化。フォルダー階層と名前空間を合わせる &amp;quot;Sync Namespaces&amp;quot; の追加(ReSharper の Adjust Namespaces 相当)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/release-notes-preview#17.0.0-pre.4.0"&gt;Visual Studio 2022 Preview Release Notes | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="update-on.net-multi-platform-app-ui.net-maui.net-blog"&gt;Update on .NET Multi-platform App UI (.NET MAUI) - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/update-on-dotnet-maui/"&gt;https://devblogs.microsoft.com/dotnet/update-on-dotnet-maui/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MAUI の状況と .NET MAUI Preview 8 について。&lt;/p&gt;
&lt;p&gt;MAUI は開発状況的に .NET 6 の11月の GA には入らず、2022年の Q2 での GA を目指すとのこと。それまでは Xamarin の強化を行い、製品開発への採用は Xamarin を推奨する。.NET 6 GA の段階で必要な機能は提供するがしばらくはプレビューで品質向上と移行のための準備を進める。&lt;/p&gt;
&lt;p&gt;また .NET 6 RC1 では &amp;quot;Go Live&amp;quot; だが、MAUI は除外され、RC2 で Preview となる。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 Preview 4 の Mobile development with .NET ワークロードに MAUI が含まれるようになった。Windows デスクトップアプリケーションをターゲットにしたい場合には &amp;quot;Desktop Development with .NET&amp;quot;, &amp;quot;UWP&amp;quot;, &amp;quot;Desktop Development with C++&amp;quot; ワークロードも必要。&lt;/p&gt;
&lt;p&gt;また、XAML のホットリロードにも対応し、Windows をはじめ iOS, Android でも同様に動作する。&lt;/p&gt;
&lt;p&gt;.NET MAUI SDK はアップデートで ASP.NET Core などと同様に .NET Host Builder パターンを使用するようになった。&lt;/p&gt;
&lt;h3 id="winui-2.7-release-notes-windows-apps-microsoft-docs"&gt;WinUI 2.7 Release Notes - Windows apps | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/apps/winui/winui2/release-notes/winui-2.7"&gt;https://docs.microsoft.com/en-us/windows/apps/winui/winui2/release-notes/winui-2.7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows UI Library 2.7 がリリース。&lt;/p&gt;
&lt;p&gt;InfoBadge コントロール、ColorPicker の方向設定(横置き)の追加。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/microsoft-ui-xaml/releases/tag/v2.7.0"&gt;Release Microsoft.UI.Xaml 2.7.0 · microsoft/microsoft-ui-xaml&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-september-2021-updates-5.0.10-and-3.1.19.net-blog"&gt;.NET September 2021 Updates – 5.0.10 and 3.1.19 - .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/september-2021-updates/"&gt;https://devblogs.microsoft.com/dotnet/september-2021-updates/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5.0.10 と 3.1.19 がリリース。&lt;/p&gt;
&lt;p&gt;セキュリティーアップデートを含まない、信頼性やその他バグ修正等の改善。&lt;/p&gt;
&lt;p&gt;.NET 5 の Runtime には &lt;code&gt;GCConserveMemory&lt;/code&gt; という GC の設定が追加された。&lt;code&gt;GCConserveMemory&lt;/code&gt; は Gen 2 で意味のある生きたデータの割合の閾値で設定値として 1-9 をとる。例えば 3 を指定した場合には Gen 2 にあるべきデータは 30% となり、これによってフラグメンテーションが 70% 以上になるとよりブロッキング Gen 2 GC が実行される(つまり大きい値を指定すると Gen 2 をコンパクトに保とうとする)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/announcements/issues/200"&gt;September 2021 .NET Updates · Issue #200 · dotnet/announcements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/48601"&gt;Fix high frag in gen2 by PeterSolMS · Pull Request #48601 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="uno-platform-3.10-day-0-support-for.net-6-rc1-winui-infobadge-windows-11-fluent-styles"&gt;Uno Platform 3.10: Day-0 support for .NET 6 RC1, WinUI InfoBadge, Windows 11 Fluent Styles&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://platform.uno/blog/uno-platform-3-10-day-0-support-for-net-6-rc1-winui-infobadge-windows-11-fluent-styles/"&gt;https://platform.uno/blog/uno-platform-3-10-day-0-support-for-net-6-rc1-winui-infobadge-windows-11-fluent-styles/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Uno Platform 3.10 がリリース。&lt;/p&gt;
&lt;p&gt;.NET 6 RC1 への対応や Windows 11 のスタイルなどに対応、WinUI に追加された InfoBadge への対応など。多くの改善と修正、サンプルコードの追加が行われた。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/unoplatform/uno/releases/tag/3.10.7"&gt;Release 3.10.7 · unoplatform/uno&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="http3-enable-in-kestrel-by-default-in.net-7-issue-36486-dotnetaspnetcore"&gt;HTTP/3: Enable in Kestrel by default in .NET 7 · Issue #36486 · dotnet/aspnetcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/issues/36486"&gt;https://github.com/dotnet/aspnetcore/issues/36486&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 7 で Kestrel の HTTP/3 サポートがデフォルトで有効になる予定。&lt;/p&gt;
&lt;h3 id="introducing-opensilver"&gt;Introducing OpenSilver&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://opensilver.net/announcements/introducing-opensilver.aspx"&gt;https://opensilver.net/announcements/introducing-opensilver.aspx&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Silverlight のオープンソース代替実装、OpenSilver のベータがリリース。&lt;/p&gt;
&lt;p&gt;C#/WPF を Web 技術上で動かす CSHTML5 をベースとして Silverlight のコードを Web 技術上で動かすツールキット。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/OpenSilver/OpenSilver"&gt;OpenSilver/OpenSilver: This repository contains the source of both OpenSilver and CSHTML5. More information is available at: www.opensilver.net and www.cshtml5.com - Read README.md for the instructions on how to build the source code and how to test it.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://support.microsoft.com/ja-jp/windows/silverlight-%E3%81%AE%E3%82%B5%E3%83%9D%E3%83%BC%E3%83%88%E7%B5%82%E4%BA%86%E6%97%A5-0a3be3c7-bead-e203-2dfd-74f0a64f1788"&gt;Silverlight のサポート終了日&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="open-sourcing-the.net-5-c-language-extension-for-sql-server-microsoft-sql-server-blog"&gt;Open sourcing the .NET 5 C# Language Extension for SQL Server - Microsoft SQL Server Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://cloudblogs.microsoft.com/sqlserver/2021/09/08/open-sourcing-the-net-5-c-language-extension-for-sql-server/"&gt;https://cloudblogs.microsoft.com/sqlserver/2021/09/08/open-sourcing-the-net-5-c-language-extension-for-sql-server/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SQL Server 2019 から利用できる外部コードを実行することで様々な言語を呼び出せる仕組みで .NET 5 / C# を使用する拡張がオープンソースで公開された。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://blog.engineer-memo.com/2021/09/12/sql-server-2019-on-windows-%E3%81%AE-language-extension-%E3%81%A7-net-5-c-%E3%81%8C%E5%8B%95%E4%BD%9C%E3%81%99%E3%82%8B%E3%82%88%E3%81%86%E3%81%AB%E3%81%AA%E3%82%8A%E3%81%BE%E3%81%97%E3%81%9F/"&gt;SQL Server 2019 on Windows の Language Extension で .NET 5 C# が動作するようになりました at SE の雑記&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/sql/language-extensions/language-extensions-overview?view=sql-server-ver15"&gt;SQL Server 言語拡張とは? | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/sql-server-language-extensions/tree/main/language-extensions/dotnet-core-CSharp"&gt;sql-server-language-extensions/language-extensions/dotnet-core-CSharp at main · microsoft/sql-server-language-extensions&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-1.4.0-beta.3-mysql-netmysqlconnector"&gt;Release 1.4.0-beta.3 · mysql-net/MySqlConnector&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mysql-net/MySqlConnector/releases/tag/1.4.0-beta.3"&gt;https://github.com/mysql-net/MySqlConnector/releases/tag/1.4.0-beta.3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Async MySQL Connector の 1.4.0-beta.3 がリリース。&lt;/p&gt;
&lt;p&gt;1.4.0 シリーズでは .NET 6 のサポートの追加や、netstandard1.3 のサポートの削除などが行われている。&lt;/p&gt;
&lt;h3 id="release-v5.0.10-npgsqlnpgsql"&gt;Release v5.0.10 · npgsql/npgsql&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/npgsql/npgsql/releases/tag/v5.0.10"&gt;https://github.com/npgsql/npgsql/releases/tag/v5.0.10&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Npgsql 5.0.10 がリリース。&lt;/p&gt;
&lt;p&gt;様々な不具合の修正と、&lt;code&gt;xid8&lt;/code&gt; データ型のサポートの追加など。&lt;/p&gt;
&lt;h3 id="security-bulletin-announcements-travis-ci-community"&gt;Security Bulletin - Announcements - Travis CI Community&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://travis-ci.community/t/security-bulletin/12081"&gt;https://travis-ci.community/t/security-bulletin/12081&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Travis CI の脆弱性について。パブリックなリポジトリをフォークした先で PR を作った際に元リポジトリの Secrets が露出してしまう問題があった。&lt;/p&gt;
&lt;p&gt;経緯や対応方法は下記の記事が詳しいので Travis CI を使用していた場合には対応が推奨。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zenn.dev/azu/articles/110528f8963686"&gt;Travis CIのGitHub連携を停止する方法&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="introducing-package-source-mapping-the-nuget-blog"&gt;Introducing Package Source Mapping - The NuGet Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/nuget/introducing-package-source-mapping/"&gt;https://devblogs.microsoft.com/nuget/introducing-package-source-mapping/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;複数の NuGet パッケージソースを持つ場合に特定のパッケージやパッケージ名のパターンでどのパッケージソースを使用するか指定できる機能についての記事。&lt;/p&gt;
&lt;p&gt;例えば特定の名前のパッケージ(&lt;code&gt;Contoso&lt;/code&gt; や &lt;code&gt;Contoso.*&lt;/code&gt;)は常に社内の NuGet パッケージレジストリを使うといったことが可能となる。&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 Preview 4 または nuget.exe 6.0.0-preview.4 または .NET SDK 6.0.100-rc.1 (.NET 6 RC1) 以降が必要。&lt;/p&gt;
&lt;h3 id="reflection-via-source-generators"&gt;Reflection via source generators&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/byme8/aot-reflection-4ijb"&gt;https://dev.to/byme8/aot-reflection-4ijb&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Source Generator でリフレクションで取得するようなものをあらかじめ生成しておくことでリフレクションのようなことをする場合でもパフォーマンスを稼げるのではないかというアイデアの記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/byme8/Apparatus.AOT.Reflection"&gt;byme8/Apparatus.AOT.Reflection&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="cidisposableusingdispose"&gt;C#でIDisposableをusingしたのにDisposeしてくれない件&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://makiuchi-d.github.io/2021/09/16/csharp-using-idisposable.ja.html"&gt;http://makiuchi-d.github.io/2021/09/16/csharp-using-idisposable.ja.html&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;場合によっては &lt;code&gt;try-finally&lt;/code&gt; の &lt;code&gt;finally&lt;/code&gt; が呼び出されないことがあるという話。&lt;/p&gt;
&lt;p&gt;通常例外がエントリーポイントまでさかのぼって &lt;code&gt;catch&lt;/code&gt; されなかった場合、「ハンドルされていない例外 (Unhandled Exception)」となりアプリケーションが終了される。その際、一番外側でも &lt;code&gt;catch&lt;/code&gt; がない場合 &lt;code&gt;finally&lt;/code&gt; が実行されない可能性がある。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-csharp"&gt;static void Main(string[] args)
{
    try
    {
        try
        {
            throw new Exception();
        }
        finally
        {
            // 実行される
            Console.WriteLine(&amp;quot;Finally2&amp;quot;);
        }
    }
    catch (Exception e)
    {
        // ここで throw すると結局 Unhandled Exception となるので try-catch-finally の finally は実行されない可能性がある
        throw;
    }
    finally
    {
        // 実行されない可能性がある
        Console.WriteLine(&amp;quot;Finally&amp;quot;);
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;大抵はユーザーコードにたどり着くまでにフレームワークのどこかで try-catch が含まれているので問題にならないが、素のコンソールアプリケーションや Top-level Statements などで、&lt;code&gt;using&lt;/code&gt; / &lt;code&gt;using var&lt;/code&gt; を利用している場合等で問題になる可能性がある。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/csharp/language-reference/keywords/try-finally"&gt;try-finally - C# リファレンス | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="system.diagnostics.metrics-api-qiita"&gt;計量的な統計を扱うためのSystem.Diagnostics.Metrics API - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/skitoy4321/items/ae506268fb18fc2ac54d"&gt;https://qiita.com/skitoy4321/items/ae506268fb18fc2ac54d&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で追加される System.Diagnosics.Metrics API についての記事。API の概要とシナリオ、実際の使い方などを解説。&lt;/p&gt;
&lt;h3 id="web-api-openapi-httprepl"&gt;Web API (OpenAPI) の探索やテストに便利な HttpRepl を使ってみた&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/08thse/articles/47-tool-httprepl"&gt;https://zenn.dev/08thse/articles/47-tool-httprepl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Tools として提供されている HTTP を REPL のような形で操作できる HttpRepl の使い方の記事。&lt;/p&gt;
&lt;h3 id="apples-in-maui"&gt;Apples in MAUI&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.telerik.com/amp/apples-maui/WEx1ZE1sRUVUWkE5S0dNbEhBNXJyUkU3T1Q4PQ2"&gt;https://www.telerik.com/amp/apples-maui/WEx1ZE1sRUVUWkE5S0dNbEhBNXJyUkU3T1Q4PQ2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MAUI で iOS アプリケーションを動かすまでの macOS 開発環境でのステップバイステップ。&lt;/p&gt;
&lt;h3 id="section-3"&gt;[雑記] コンパイル結果に影響を及ぼす属性&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ufcpp.net/study/csharp/start/miscreservedattribute/"&gt;https://ufcpp.net/study/csharp/start/miscreservedattribute/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;AttributeUsage&lt;/code&gt; や &lt;code&gt;Conditional&lt;/code&gt;, &lt;code&gt;Obsolete&lt;/code&gt; など実行時に属性を解釈するのではなくコンパイル時にコンパイラーが知るためにある属性についての記事。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;NullableContext&lt;/code&gt; のようなコンパイラーが生成する属性についても。&lt;/p&gt;
&lt;h3 id="api-versioning-in-asp.net-core.net-core-tutorials"&gt;API Versioning in ASP.net Core - .NET Core Tutorials&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dotnetcoretutorials.com/2017/01/17/api-versioning-asp-net-core/"&gt;https://dotnetcoretutorials.com/2017/01/17/api-versioning-asp-net-core/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core で API のバージョニングを実現する Microsoft.AspNetCore.Mvc.Versioning の使い方についての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://qiita.com/alicial/items/f095ef52c5677abc3f7e"&gt;.NETCoreでアクション別のバージョン管理 - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net5.0rest-apiaws-codepipelineecs-qiita"&gt;.NET5.0製のREST APIサーバーを、AWS CodePipelineでビルドしてコンテナ化してECSでデプロイする。 - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/tricrow/items/dad78c99cb77c7c6be9b"&gt;https://qiita.com/tricrow/items/dad78c99cb77c7c6be9b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 アプリケーションを AWS CodePipeline/CodeBuild でビルドして、ARM (Graviton) な ECS インスタンスで動かすという話。&lt;/p&gt;
&lt;h3 id="debugging-a.net-app-on-linux-from-windows-visual-studio-with-wsl-ndepend"&gt;Debugging a .NET App on Linux from Windows Visual Studio with WSL - NDepend&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.ndepend.com/debugging-a-net-app-on-linux-from-windows-visual-studio-with-wsl"&gt;https://blog.ndepend.com/debugging-a-net-app-on-linux-from-windows-visual-studio-with-wsl&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio から .NET 5 アプリケーションを WSL 2 上の Linux で動かしてデバッグするための手順についての記事。&lt;/p&gt;
&lt;p&gt;.NET Framework のアプリを移植してきた場合、&lt;code&gt;DebugType&lt;/code&gt; が &lt;code&gt;full&lt;/code&gt; となっている場合があるので &lt;code&gt;portable&lt;/code&gt; にするようにといった話も。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/visualstudio/debugger/debug-dotnet-core-in-wsl-2?view=vs-2019"&gt;Linux で WSL を使用して .NET アプリをデバッグする - Visual Studio (Windows) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="socks-proxy-support-in.net.net-core-tutorials"&gt;SOCKS Proxy Support In .NET - .NET Core Tutorials&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dotnetcoretutorials.com/2021/07/11/socks-proxy-support-in-net/"&gt;https://dotnetcoretutorials.com/2021/07/11/socks-proxy-support-in-net/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で　SOCKS プロキシーに対応したのでその使用方法についての記事。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/48883"&gt;SOCKS4/4a/5 proxy support in SocketsHttpHandler by huoyaoyuan · Pull Request #48883 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="looking-inside-configurationmanager-in.net-6-exploring.net-core-6-part-1"&gt;Looking inside ConfigurationManager in .NET 6: Exploring .NET Core 6 - Part 1&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/exploring-dotnet-6-part-1-looking-inside-configurationmanager-in-dotnet-6/"&gt;https://andrewlock.net/exploring-dotnet-6-part-1-looking-inside-configurationmanager-in-dotnet-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ConfigurationBuilder の代わりとなる .NET 6 で導入された ConfigurationManager についての違いと利点などについての記事。&lt;/p&gt;
&lt;p&gt;ConfigurationManager は &lt;code&gt;IConfigurationBuilder&lt;/code&gt; を実装しているが ConfigurationBuilder と異なり、設定ソースの追加と削除が行われた時点で設定が確定するため部分的な取り出しが簡単になっている (&lt;code&gt;IConfigurationRoot&lt;/code&gt; を実装していて自身を返すだけになっている)。&lt;code&gt;ConfigurationBuilder&lt;/code&gt; は一度 &lt;code&gt;Build&lt;/code&gt; しないと読めないため、設定に依存する設定がある場合の取り回しが悪かった。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/microsoft.extensions.configuration.configurationmanager?view=dotnet-plat-ext-6.0"&gt;ConfigurationManager Class (Microsoft.Extensions.Configuration) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="web.net-maui-essentialsxamarin.essentials-1.7"&gt;新たなWeb認証オプションと.NET MAUI Essentialsを加えたXamarin.Essentials 1.7&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.infoq.com/jp/news/2021/09/xamarin-essentials-1-7/"&gt;https://www.infoq.com/jp/news/2021/09/xamarin-essentials-1-7/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xamarin.Essentials 1.7 についての記事。Web 認証と MAUI 対応について。&lt;/p&gt;
&lt;h3 id="backend-for-frontend-authentication-pattern-with-auth0-and-asp.net-core"&gt;Backend For Frontend Authentication Pattern with Auth0 and ASP.NET Core&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://auth0.com/blog/backend-for-frontend-pattern-with-auth0-and-dotnet/"&gt;https://auth0.com/blog/backend-for-frontend-pattern-with-auth0-and-dotnet/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Backend for Frontend (BFF) のような構成で Auth0 と ASP.NET Core を使った認証実装パターンについての記事。&lt;/p&gt;
&lt;h3 id="minimal-apis-at-a-glance-in.net-6"&gt;Minimal APIs at a glance in .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.hanselman.com/blog/minimal-apis-at-a-glance-in-net-6"&gt;https://www.hanselman.com/blog/minimal-apis-at-a-glance-in-net-6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 (ASP.NET Core) の Minimal API を使用したサンプルコードの記事。&lt;/p&gt;
&lt;h2 id="section-4"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="egorbostaticpgo_example-how-to-collect-a-static-not-the-dynamic-one-pgo-and-re-use-it-during-dotnet-publish"&gt;EgorBo/StaticPGO_Example: How to collect a static (not the dynamic one) PGO and re-use it during &amp;quot;dotnet publish&amp;quot;&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/EgorBo/StaticPGO_Example"&gt;https://github.com/EgorBo/StaticPGO_Example&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の Static PGO を試すためのサンプルリポジトリ。&lt;/p&gt;
&lt;h3 id="mayukikokuban-simplifies-styling-strings-in-the-terminal-for.net-application"&gt;mayuki/Kokuban: Simplifies styling strings in the terminal for .NET application&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mayuki/Kokuban"&gt;https://github.com/mayuki/Kokuban&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コンソールに表示される文字列に対して色や下線など装飾を行うためのライブラリ。&lt;/p&gt;
&lt;h3 id="mayukichell-write-scripts-with-the-power-of-c-and.net"&gt;mayuki/Chell: Write scripts with the power of C# and .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/mayuki/Chell"&gt;https://github.com/mayuki/Chell&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;シェルスクリプトのような作業を C# でも書きやすくするためのプロセス実行とユーティリティのライブラリ。&lt;/p&gt;
&lt;h2 id="section-5"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="scott-hanselman-shanselman-tiktok-watch-scott-hanselmans-newest-tiktok-videos"&gt;Scott Hanselman (&amp;#64;shanselman) TikTok | Watch Scott Hanselman's Newest TikTok Videos&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.tiktok.com/&amp;#64;shanselman"&gt;https://www.tiktok.com/&amp;#64;shanselman&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Scott Hanselman の TikTok。&lt;/p&gt;
&lt;h3 id="net-krzysztof-cwalinajeremy-bartonbrad-abrams-amazon"&gt;.NETのクラスライブラリ設計 改訂新版 (マイクロソフト関連書) | Krzysztof Cwalina、Jeremy Barton、Brad Abrams, 猪股 健太郎、河合 宜文 (監訳), 藤原 雄介 |本 | 通販 | Amazon&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.amazon.co.jp/dp/4296080040"&gt;https://www.amazon.co.jp/dp/4296080040&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NETのクラスライブラリ設計 改訂新版の発売日が10月7日となり、Amazon での予約が開始。&lt;/p&gt;
&lt;h3 id="section-6"&gt;ツイート&lt;/h3&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;New create option in &lt;a href="https://twitter.com/AzureFunctions?ref_src=twsrc%5Etfw"&gt;&amp;#64;AzureFunctions&lt;/a&gt; to create apps with .NET 6 🎉 &lt;br&gt;&lt;br&gt;Go give it a try! &lt;a href="https://t.co/El855SLeGM"&gt;pic.twitter.com/El855SLeGM&lt;/a&gt;&lt;/p&gt;&amp;mdash; Jeff Hollan (&amp;#64;jeffhollan) &lt;a href="https://twitter.com/jeffhollan/status/1436422895350153217?ref_src=twsrc%5Etfw"&gt;September 10, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Azure Functions で .NET 6 が Preview という形で使用できるように(これまでは Early Preview 扱い)。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Your binlogs will be smaller and your builds will be faster! &lt;a href="https://t.co/uEhA1t3zIE"&gt;https://t.co/uEhA1t3zIE&lt;/a&gt;&lt;/p&gt;&amp;mdash; Kirill Osenkov (&amp;#64;KirillOsenkov) &lt;a href="https://twitter.com/KirillOsenkov/status/1395510072348868609?ref_src=twsrc%5Etfw"&gt;May 20, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;MSBuild が 16.10 で文字列の dedup するようになって binlog が小さくなって、ビルドが速くなったという話。他にも binlog にファイルを埋め込めるようになった等の改善点など。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/msbuild/pull/6017"&gt;Deduplicate strings in binlogs by KirillOsenkov · Pull Request #6017 · dotnet/msbuild&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/msbuild/pull/6339"&gt;Add support for embedding arbitrary files into binlog by KirillOsenkov · Pull Request #6339 · dotnet/msbuild&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Optimized version 🏎️&lt;br&gt;If build time only is enough for your codegen, you can still use RegisterForSyntaxNotifications and detect build time by checking entry assembly != null &lt;a href="https://t.co/fXKdxTSzSA"&gt;https://t.co/fXKdxTSzSA&lt;/a&gt;&lt;br&gt;By doing so, your codegen will have *zero* impact at IDE time/keystrokes! 😎 &lt;a href="https://t.co/HZx3VObLlB"&gt;pic.twitter.com/HZx3VObLlB&lt;/a&gt;&lt;/p&gt;&amp;mdash; Alexandre Mutel (&amp;#64;xoofx) &lt;a href="https://twitter.com/xoofx/status/1437054965789470729?ref_src=twsrc%5Etfw"&gt;September 12, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Source Generator から &lt;code&gt;Assembly.GetEntryAssembly()&lt;/code&gt; が &lt;code&gt;null&lt;/code&gt; かどうかを調べることで IDE 上で動いているかどうか確認できるので、ビルド時にのみ実行したい Source Generator を作る場合には使えるというテクニック。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;For 17.0, we have fully NGEN&amp;#39;d most major assemblies, most of which is in Preview 4, with a trailing set of assemblies in a future preview.&lt;/p&gt;&amp;mdash; David Kean (&amp;#64;davkean) &lt;a href="https://twitter.com/davkean/status/1438027246623547394?ref_src=twsrc%5Etfw"&gt;September 15, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Visual Studio が 64bit になったことでアドレス空間に余裕ができた。例えばアドレス空間を節約するため NGEN の対象はよく使われるコードパスのもののみに絞っていた(のでたまに JIT が走る)が、主要なアセンブリの大半を NGEN できるようになったという話。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;&lt;a href="https://t.co/4PmXMQN7SX"&gt;https://t.co/4PmXMQN7SX&lt;/a&gt; Core SignalR is one of the things I&amp;#39;m most proud of engineering wise. Lots of lessons were learnt building the first version that went into building its successor. Here is an example of native IAsyncEnumerable&amp;lt;T&amp;gt; streaming &lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/signalr?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#signalr&lt;/a&gt; &lt;a href="https://t.co/7wEmonu6Zp"&gt;pic.twitter.com/7wEmonu6Zp&lt;/a&gt;&lt;/p&gt;&amp;mdash; David Fowler 🇧🇧💉💉 (&amp;#64;davidfowl) &lt;a href="https://twitter.com/davidfowl/status/1437994847252606978?ref_src=twsrc%5Etfw"&gt;September 15, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;SignalR の Hub は &lt;code&gt;IAsyncEnumerable&amp;lt;T&amp;gt;&lt;/code&gt; をサポートしているのでデータのストリーミングできるという話。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="add-initial-regex-source-generator-by-stephentoub-pull-request-59186-dotnetruntime"&gt;Add initial regex source generator by stephentoub · Pull Request #59186 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/59186"&gt;https://github.com/dotnet/runtime/pull/59186&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Regex の Source Generator の初期実装のPR。&lt;/p&gt;
&lt;p&gt;Source Generator であらかじめ正規表現マッチ用のコードを生成しておくことでパフォーマンスを向上することが目的。
現時点では &lt;code&gt;RegexOptions.Compiled&lt;/code&gt; のコードを流用して、C# の Regex のマッチ用のコードを生成する形。&lt;/p&gt;
&lt;h3 id="need-to-run-non-english-text-through-utf8encoding-for-pgo-scenarios-issue-57698-dotnetruntime-github"&gt;Need to run non-English text through UTF8Encoding for PGO scenarios · Issue #57698 · dotnet/runtime · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/57698"&gt;https://github.com/dotnet/runtime/issues/57698&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で PGO をかけた結果 UTF8Encoding が遅くなってしまうケースが発生しているという話。&lt;/p&gt;
&lt;p&gt;Non-English なテキストを処理するようなデータでプロファイルしていないため、ギリシャ語やキリル文字を処理するようなケースでパフォーマンスが若干低下している。多分日本語も該当する可能性がある。コアライブラリは元から PGO で最適化された R2R の形式で出荷されているので影響を受ける。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/52313"&gt;[Perf] Regressions in System.Text.Perf_Utf8Encoding for Greek and Cyrillic · Issue #52313 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="add-freebsd-rids-to-known-targets-by-josteink-pull-request-11972-dotnetinstaller"&gt;Add FreeBSD RIDs to known targets by josteink · Pull Request #11972 · dotnet/installer&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/installer/pull/11972"&gt;https://github.com/dotnet/installer/pull/11972&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;インストーラーが知っている Runtime Identifier に FreeBSD が追加することでインストールできるようにする PR。&lt;/p&gt;
&lt;h3 id="support-multi-targeting-for-roslyn-components-by-eerhardt-pull-request-20793-dotnetsdk"&gt;Support multi-targeting for Roslyn components by eerhardt · Pull Request #20793 · dotnet/sdk&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/sdk/pull/20793"&gt;https://github.com/dotnet/sdk/pull/20793&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roslyn のバージョンが Visual Studio 2019 (Roslyn 3.10) と 2022 (Roslyn 4.0) という形で複数ある都合、読み込むものを分けられるようにするという PR (マルチターゲット化)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/sdk/issues/20355"&gt;Support multi-targeting for Roslyn components · Issue #20355 · dotnet/sdk · GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="marshal.allochglobalfreehglobal-is-150x-slower-in.net-than-legacy-mono-on-device-tvos-issue-58939-dotnetruntime"&gt;Marshal.AllocHGlobal/FreeHGlobal is ~150x slower in .NET than legacy mono on device (tvOS) · Issue #58939 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/58939"&gt;https://github.com/dotnet/runtime/issues/58939&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;tvOS で Marshal.AllocHGlobal/FreeHGlobal が急激に遅くなったのだけどなぜ?という話。レガシー Mono では問題なかったが .NET ではとても遅い、となっているが実際はランタイム自体はどちらも Mono で .NET 6 世代で &lt;code&gt;Marshal.AllocHGlobal&lt;/code&gt; の実装が .NET の &lt;code&gt;NativeMemory.Alloc&lt;/code&gt; に変わった影響。&lt;/p&gt;
&lt;p&gt;Mono の固有実装と異なり素直に P/Invoke を使うようになった影響で P/Invoke 呼び出しの GC セーフにするための処理でオーバーヘッドが生まれてしまった。&lt;/p&gt;
&lt;h3 id="api-proposal-add-arm64-to-processorarchitecture-and-imagefilemachine-enums-issue-58970-dotnetruntime"&gt;[API Proposal]: Add Arm64 to ProcessorArchitecture and ImageFileMachine enums · Issue #58970 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/58970"&gt;https://github.com/dotnet/runtime/issues/58970&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ProcessorArchitecture&lt;/code&gt; と &lt;code&gt;ImageFileMachine&lt;/code&gt; に ARM64 の値がないので増やしたいという提案。
ところがそもそもこの値は .NET Core/.NET 5 以降では事実上の非推奨でほぼ機能しておらず、むしろ &lt;code&gt;AssemblyName&lt;/code&gt; にある &lt;code&gt;ProcessorArchitecture&lt;/code&gt; は Obsolete にしたいという話に。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/59061"&gt;Obsolete thumbtacked AssemblyName properties · Issue #59061 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="create-using-alias-types.md-by-cyrusnajmabadi-pull-request-5174-dotnetcsharplang"&gt;Create using-alias-types.md by CyrusNajmabadi · Pull Request #5174 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/pull/5174"&gt;https://github.com/dotnet/csharplang/pull/5174&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;名前を持つ型に対するエイリアスとして &lt;code&gt;using A = Foo.Bar.Baz;&lt;/code&gt; はできるが、&lt;code&gt;using Position = (int X, int Y);&lt;/code&gt; のようなタプルや配列型、ポインター型などに対するエイリアスは定義できないので定義できるようにする提案。&lt;/p&gt;
&lt;h3 id="proposal-event-hookup-in-object-initializer-issue-5176-dotnetcsharplang"&gt;[Proposal]: Event hookup in object initializer · Issue #5176 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/5176"&gt;https://github.com/dotnet/csharplang/issues/5176&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;オブジェクト初期化子で event ハンドラーをセットできてもいいのではないかという提案。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-09-10</title>
			<link>/2021/09/10/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/09/10/updates</guid>
			<pubDate>Fri, 10 Sep 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;h2 id="section"&gt;主なトピックス&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/the-future-of-visual-studio-extensibility-is-here/"&gt;The Future of Visual Studio Extensibility is Here! - Visual Studio Blog&lt;/a&gt; という Visual Studio の拡張についての今後についての記事が公開されています。&lt;/p&gt;
&lt;p&gt;この中でも Out-of-Process モデルの実装が始まったのが大きいかと思います。Phase 1ということで単純なコマンドモデルのみが実装可能なレベルですが、.NET 6 で実装できるようになりますし、今と同じ拡張可能な領域まで到達するのは今後長い時間がかかるとはいえ楽しみな部分です。&lt;/p&gt;
&lt;h3 id="weekref.net"&gt;WeekRef.NET&lt;/h3&gt;
&lt;p&gt;この WeekRef.NET を公開して初めての更新となるので改めて WeekRef.NET について少し説明しておこうかなと思います。&lt;/p&gt;
&lt;p&gt;元々 JavaScript 方面では &lt;a href="http://jser.info/"&gt;JSer.info&lt;/a&gt; という一週間の JavaScript やブラウザに関連するリリースや記事などをまとめて紹介してくれる日本語のサイトがあり、個人的によく見ていました(ちなみに JSer.info は10年以上続いていてすごいです)。&lt;/p&gt;
&lt;p&gt;そこで同じように .NET の方面にもそういった週ごとの .NET に絞った記事やリリースの日本語でのまとめが欲しいなとずっと思っていたものの、特にそういった物は出てこなかったのでそれなら勉強がてら自分で初めてみようとなりました(英語では Weekly まとめはいくつかあります)。&lt;/p&gt;
&lt;p&gt;というわけで先に社内向けに4週間ぐらいお試ししてからスタートしたのですぐに力尽きることはないと思いますが、ゆるくほぼ週刊という感じでやっていければと思っています。&lt;/p&gt;
&lt;h2 id="section-1"&gt;ヘッドライン&lt;/h2&gt;
&lt;h3 id="the-future-of-visual-studio-extensibility-is-here-visual-studio-blog"&gt;The Future of Visual Studio Extensibility is Here! - Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/the-future-of-visual-studio-extensibility-is-here/"&gt;https://devblogs.microsoft.com/visualstudio/the-future-of-visual-studio-extensibility-is-here/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio のこれからの拡張について。&lt;a href="https://github.com/microsoft/VSExtensibility"&gt;microsoft/VSExtensibility&lt;/a&gt; というリポジトリでアナウンスやサンプル、ドキュメントなどが公開される。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/VSExtensibility"&gt;microsoft/VSExtensibility: A repo for upcoming changes to extensibility in Visual Studio, the new extensibility model, and language server protocol.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Visual Studio 2022 に向けての拡張は開発者がマイグレーションガイドに沿って移行する必要がある。CodeRush, VSVim, Productivity Power Tools のような人気の拡張は既に対応済み。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/extensibility/migration/update-visual-studio-extension?view=vs-2022"&gt;Update a Visual Studio extension - Visual Studio (Windows) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Language Server Protocol のサポートの拡張。Visual Studio 固有の Language Server Protocol の拡張についてのドキュメントの公開とそれをサポートする NuGet パッケージ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/VSExtensibility/blob/main/docs/lsp/lsp-extensions-specifications.md"&gt;VSExtensibility/lsp-extensions-specifications.md at main · microsoft/VSExtensibility&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Visual Studio Community Toolkit を使用して拡張を簡単に書けるように。&lt;/p&gt;
&lt;p&gt;新しい Out-of-Process 拡張モデルのサポート Phase 1 の導入。プロセス分離によって Visual Studio の安定性や再起動の不要化などの利便性の向上を図る。Phase 1 では新しい API を使用して単一ファイルに対する lint やフォーマットのようなコマンドでの処理を実装できるようになる。Out-of-Proccess で動作する拡張は .NET 6 ベース。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/VSExtensibility/blob/main/docs/new-extensibility-model/getting-started/create-your-first-extension.md"&gt;VSExtensibility/create-your-first-extension.md at main · microsoft/VSExtensibility&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-release-v2.39.0-grpcgrpc-dotnet"&gt;Release Release v2.39.0 · grpc/grpc-dotnet&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/grpc/grpc-dotnet/releases/tag/v2.39.0"&gt;https://github.com/grpc/grpc-dotnet/releases/tag/v2.39.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gRPC の .NET 実装 (grpc-dotnet) の 2.39.0 がリリース。&lt;/p&gt;
&lt;p&gt;主に小さなバグフィックスのリリース。リトライポリシーでカルチャーによっては例外が発生する問題の修正や HedgingDelay が null の場合の処理の修正。&lt;/p&gt;
&lt;p&gt;gRPC の本体も 1.40.0 がリリース。C-コアやC++, Python に関する変更を含むのみでピュアな C# 部分での変更はないため、&lt;code&gt;Grpc.Core&lt;/code&gt; パッケージを使用している場合にのみ C-core の更新の影響がある(C-core 版のパッケージバージョンは 2.40.0 であることに注意)。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/grpc/grpc/releases/tag/v1.40.0"&gt;Release Release v1.40.0 · grpc/grpc&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-enterprise-developer-day-hosted-by-amazon-web-services"&gt;.NET Enterprise Developer Day hosted by Amazon Web Services&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.eventbrite.com/e/net-enterprise-developer-day-hosted-by-amazon-web-services-registration-167917464657"&gt;https://www.eventbrite.com/e/net-enterprise-developer-day-hosted-by-amazon-web-services-registration-167917464657&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;AWS の .NET アプリ向けの開発者オンラインイベントが9月14日(日本時間)に開催。&lt;/p&gt;
&lt;h3 id="entity-framework-biweekly-status-updates-2021-issue-23884-dotnetefcore"&gt;Entity Framework Biweekly Status Updates (2021) · Issue #23884 · dotnet/efcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/issues/23884#issuecomment-916251523"&gt;https://github.com/dotnet/efcore/issues/23884#issuecomment-916251523&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;2週ごとの Entity Framework のステータス更新レポートの9月9日分。&lt;/p&gt;
&lt;h3 id="c-language-design-meeting-for-august-30th-2021"&gt;C# Language Design Meeting for August 30th, 2021&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-08-30.md"&gt;https://github.com/dotnet/csharplang/blob/main/meetings/2021/LDM-2021-08-30.md&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 11 に向けて Initial Triage が行われた。C# 10 で Preview になっていた Generic Attributes や static abstract を初め、Discriminated Union、Statements as expressions、Expression Tree の強化などが検討されている。&lt;/p&gt;
&lt;p&gt;ただし現時点では始まったばかりでこれを持って C# 11 にはどれが入る、入らないはまだわからないので注意が必要。&lt;/p&gt;
&lt;h2 id="section-2"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="taking-the-ef-core-azure-cosmos-db-provider-for-a-test-drive.net-blog"&gt;Taking the EF Core Azure Cosmos DB Provider for a Test Drive | .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/taking-the-ef-core-azure-cosmos-db-provider-for-a-test-drive/"&gt;https://devblogs.microsoft.com/dotnet/taking-the-ef-core-azure-cosmos-db-provider-for-a-test-drive/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 6.0 で強化される Cosmos DB プロバイダーに関する紹介。&lt;/p&gt;
&lt;p&gt;暗黙的なオーナーシップ (&lt;code&gt;HasMany&lt;/code&gt; のようなリレーションを開発者が明示的に指定しなくてよくなる)、プリミティブ型のコレクションのサポート、Raw SQL のサポートについて。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/ef/core/what-is-new/ef-core-6.0/plan#cosmos-database-provider"&gt;Cosmos database provider - Plan for Entity Framework Core 6.0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="which-azure-table-storage.net-sdk-should-i-use"&gt;Which Azure Table Storage .NET SDK should I use?&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/medialesson/which-azure-table-storage-net-sdk-should-i-use-a7f33fe294e"&gt;https://medium.com/medialesson/which-azure-table-storage-net-sdk-should-i-use-a7f33fe294e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Azure Table Storage にアクセスするために使用できるパッケージ、&lt;code&gt;WindowsAzure.Storage&lt;/code&gt;, &lt;code&gt;Microsoft.Azure.CosmosDB.Table&lt;/code&gt;, &lt;code&gt;Microsoft.Azure.Cosmos.Table&lt;/code&gt;, &lt;code&gt;Azure.Data.Tables&lt;/code&gt; の違いについて。&lt;/p&gt;
&lt;h3 id="new-improved-attach-to-process-dialog-experience-visual-studio-blog"&gt;New Improved Attach to Process Dialog Experience | Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/new-improved-attach-to-process-dialog-experience/"&gt;https://devblogs.microsoft.com/visualstudio/new-improved-attach-to-process-dialog-experience/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 のプロセスアタッチウィンドウの改善について。&lt;/p&gt;
&lt;p&gt;プロセスの一覧にコマンドラインの詳細や IIS の App Pool 名の表示、リストの自動更新機能の追加、プロセスのツリー表示、ウィンドウから探す機能の追加。&lt;/p&gt;
&lt;h3 id="making-foreach-loop-as-fast-as-for-loop"&gt;Making «foreach» loop as fast as «for» loop&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://habr.com/en/post/575916/"&gt;https://habr.com/en/post/575916/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enumerator を何とかすることで &lt;code&gt;foreach&lt;/code&gt; でまわすのを &lt;code&gt;for&lt;/code&gt; 並に速くできないのか?例えば Range のようなものに対する &lt;code&gt;GetEnumerator()&lt;/code&gt; 拡張メソッドを作って列挙するようなケースで。という記事。&lt;/p&gt;
&lt;p&gt;コンパイラーの空気を読むより for を書いたほうが簡単であるというオチではあるものの、いろいろなパターンでの JIT の結果との比較などを行い、インライン化によって遅くなる例なども見られる。&lt;/p&gt;
&lt;h3 id="csharpscript-qiita"&gt;CSharpScriptでスクリプトファイル実行機能を実装する - Qiita&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://qiita.com/t0r/items/c89215f4bbf22b7a17ac"&gt;https://qiita.com/t0r/items/c89215f4bbf22b7a17ac&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Microsoft.CodeAnalysis.CSharp.Scripting&lt;/code&gt; を使用して C# スクリプティングを実装する方法について。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CSharpScript&lt;/code&gt; クラスの &lt;code&gt;Create&lt;/code&gt;, &lt;code&gt;RunAsync&lt;/code&gt;, &lt;code&gt;EvaluteAsync&lt;/code&gt; の違いや、グローバルオブジェクトの取り扱い、実行結果を保持する &lt;code&gt;ScriptState&lt;/code&gt; に関する説明など、実用的な範囲まで網羅している。&lt;/p&gt;
&lt;h3 id="using-source-generators-with-blazor-components-in.net-6"&gt;Using Source Generators with Blazor components in .NET 6&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://andrewlock.net/using-source-generators-with-blazor-in-dotnet-6/"&gt;https://andrewlock.net/using-source-generators-with-blazor-in-dotnet-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 から .NET 6 に Blazor プロジェクトをアップデートした結果、Blazor コンポーネントに対するソースジェネレーターが動かなくなったことについての記事。&lt;/p&gt;
&lt;p&gt;.NET 6 では Blazor の Razor テンプレートに対するコード生成がソースジェネレーターとなったため、ソースジェネレーターの結果にソースジェネレーターをかけることができない問題が発生する。&lt;code&gt;&amp;lt;UseRazorSourceGenerator&amp;gt;false&amp;lt;/UseRazorSourceGenerator&amp;gt;&lt;/code&gt; を指定することで以前と同様の挙動に戻り、問題は回避できるが Hot Reload を初めとする新しい機能は使用できないので注意が必要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/aspnetcore/issues/26902"&gt;Reimplement the Razor compiler using source generators &amp;amp; support incrementality · Issue #26902 · dotnet/aspnetcore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/aspnetcore/issues/32172"&gt;Components added by a source generator work in code, but not in markup · Issue #32172 · dotnet/aspnetcore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="cspantreadonlyspant"&gt;C#のSpan&amp;lt;T&amp;gt;やReadOnlySpan&amp;lt;T&amp;gt;と戯れる&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/flipflap/articles/a72a3fc40605f7"&gt;https://zenn.dev/flipflap/articles/a72a3fc40605f7&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; や &lt;code&gt;MemoryMarshal&lt;/code&gt;, &lt;code&gt;BinaryPrimitives&lt;/code&gt; クラスを使った例について。&lt;code&gt;Span&amp;lt;byte&amp;gt;&lt;/code&gt; から &lt;code&gt;unmanaged type&lt;/code&gt; を作成する例や、エンディアンを考慮した読み込み、Span 同士での変換など。&lt;/p&gt;
&lt;h3 id="how-visual-studio-2022-ate-up-100-gb-of-memory-and-what-xml-bombs-had-to-do-with-it"&gt;How Visual Studio 2022 ate up 100 GB of memory and what XML bombs had to do with it&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/vasilievserg/how-visual-studio-2022-ate-up-100-gb-of-memory-and-what-xml-bombs-had-to-do-with-it-2noh"&gt;https://dev.to/vasilievserg/how-visual-studio-2022-ate-up-100-gb-of-memory-and-what-xml-bombs-had-to-do-with-it-2noh&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;64bit になった Visual Studio 2022 に XML Bomb を開かせることで100GB超のメモリを消費させる記事。&lt;/p&gt;
&lt;p&gt;以前からよく知られている XML の実体参照の展開で DoS のような負荷をかける手法が 64bit になった上で XML パーサーに制限をかけていないために効果的に作用した例。報告後に修正は行われた模様。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://developercommunity.visualstudio.com/t/Visual-Studio-2022-Preview-is-vulnurable/1521704#T-N1524549"&gt;Visual Studio 2022 Preview is vulnerable to XML bombs - Visual Studio Feedback&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://ja.wikipedia.org/wiki/Billion_laughs%E6%94%BB%E6%92%83"&gt;Billion laughs攻撃 - Wikipedia&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="xamarin.android"&gt;Xamarin.Android アプリが例外で落ちるということ | あじょろぐ&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.azyobuzi.net/2021/08/28/01-xaexception/"&gt;https://blog.azyobuzi.net/2021/08/28/01-xaexception/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Xamarin.Android における未処理例外の取り扱いについて。Java スレッド/.NET スレッドそれぞれで発生した未処理例外の内部的な取り扱いについての解説。&lt;/p&gt;
&lt;h3 id="ideation-of-an-ide-the.net-and-reactjs-love-affair"&gt;Ideation of an IDE: The .NET and ReactJS Love Affair&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/outsystems-engineering/ideation-of-an-ide-the-net-and-reactjs-love-affair-dc29a9dd26b6"&gt;https://medium.com/outsystems-engineering/ideation-of-an-ide-the-net-and-reactjs-love-affair-dc29a9dd26b6&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;macOS 対応のため、WPF アプリケーションから React ベースの UI を持つアプリケーションに移行した事例についての記事。&lt;/p&gt;
&lt;p&gt;UI は AvaloniaUI や Xamarin.Forms では WPF の問題は解決できなかったため、別なアプローチとして Web 技術を選択。その際に .NET のコードの再利用をしたかったため Electron.NET を検討したが、ASP.NET Core をホストするモデルのためレイテンシーやメモリ使用量などが満足いかなかったなど。&lt;/p&gt;
&lt;p&gt;Chromium をホストすることにしたが CefSharp は Windows でのみのため、CefGlue を使用することにしラッパーを実装、それをホストする WPF または AvaloniaUI という構成に。&lt;/p&gt;
&lt;p&gt;React と C# は TypeScript (View) から C# のコードを生成することで連携できる仕組みを用意したとのこと。仕組みとしては TypeScript 側で props のインターフェースを定義すると、C# 側でその props を公開するクラスを生成する模様。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/OutSystems/ReactView"&gt;ReactView/ReactViewControl.Avalonia at master · OutSystems/ReactView&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/OutSystems/WebView"&gt;OutSystems/WebView: Avalonia/WPF control that wraps CefGlue webview control&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-3"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="jetbrainsrefasmer-the-tool-to-create-reference-assembly-from-common-assembly"&gt;JetBrains/Refasmer: The tool to create reference assembly from common assembly.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/JetBrains/Refasmer"&gt;https://github.com/JetBrains/Refasmer&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;既存のアセンブリからリファレンスアセンブリを生成するツール。&lt;/p&gt;
&lt;h3 id="redthandroidsdk.tools.net-library-global-tool-for-various-android-sdk-manager-adb-avd-emulator-commands"&gt;Redth/AndroidSdk.Tools: .NET Library + global tool for various Android SDK Manager, ADB, AVD, Emulator commands&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/Redth/AndroidSdk.Tools"&gt;https://github.com/Redth/AndroidSdk.Tools&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Android SDK を操作するためのライブラリ。一部機能は .NET ツールとしても提供する。SDK Manager の操作や ADB の操作などが可能。&lt;/p&gt;
&lt;h2 id="section-4"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="path.endsindirectoryseparator-system.io-microsoft-docs"&gt;Path.EndsInDirectorySeparator メソッド (System.IO) | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.path.endsindirectoryseparator?view=net-5.0"&gt;https://docs.microsoft.com/ja-jp/dotnet/api/system.io.path.endsindirectoryseparator?view=net-5.0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core 3.0 以降で追加されたパスがセパレーターで終わるかどうかを返すメソッド。&lt;/p&gt;
&lt;h3 id="macos-apphost.net-microsoft-docs"&gt;破壊的変更: macOS 用の apphost を生成する - .NET | Microsoft Docs&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/core/compatibility/sdk/6.0/apphost-generated-for-macos"&gt;https://docs.microsoft.com/ja-jp/dotnet/core/compatibility/sdk/6.0/apphost-generated-for-macos&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core SDK 3.0 以降では macOS 向けにビルドした際に appHost (アセンブリとともに配置される実行ファイル) がデフォルトで生成されなくなっていたが、.NET 6 では再び生成されるように変更される。その際生成される appHost ファイルにはアドホックなコード署名がつく。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/53913"&gt;Codesign apphosts on Mac by mateoatr · Pull Request #53913 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/core/install/macos-notarization-issues"&gt;macOS Catalina の公証に対応する | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-5"&gt;ツイート&lt;/h3&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Tired of using SharpLab to decompile C# to IL?&lt;br&gt;No problem!&lt;br&gt;&lt;br&gt;Thanks to great work by &lt;a href="https://twitter.com/konradkokosa?ref_src=twsrc%5Etfw"&gt;&amp;#64;konradkokosa&lt;/a&gt; and &lt;a href="https://twitter.com/vivekmapara?ref_src=twsrc%5Etfw"&gt;&amp;#64;vivekmapara&lt;/a&gt; you can now decompile IL to to C# instead.&lt;a href="https://t.co/uQOpyvY43S"&gt;https://t.co/uQOpyvY43S&lt;/a&gt; &lt;a href="https://t.co/Uc1AmNp6wC"&gt;pic.twitter.com/Uc1AmNp6wC&lt;/a&gt;&lt;/p&gt;&amp;mdash; 👾 (&amp;#64;ashmind) &lt;a href="https://twitter.com/ashmind/status/1434831895825580036?ref_src=twsrc%5Etfw"&gt;September 6, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Now you can use &lt;a href="https://t.co/o6xZEr63TE"&gt;https://t.co/o6xZEr63TE&lt;/a&gt; to learn CIL and immediately observe how it is JITted into native code😍 &lt;a href="https://t.co/jf5JAuZlSt"&gt;pic.twitter.com/jf5JAuZlSt&lt;/a&gt;&lt;/p&gt;&amp;mdash; Konrad Kokosa (&amp;#64;konradkokosa) &lt;a href="https://twitter.com/konradkokosa/status/1435201174207188995?ref_src=twsrc%5Etfw"&gt;September 7, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;SharpLab に IL から C# に変換する機能が追加され、結果として IL から JIT 結果まで見れるようになった。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Small snippit of C# code: Unit testing a memory leak with WeakReference.&lt;br&gt;&lt;br&gt;Pretty simple, but not something I&amp;#39;ve tried before 🤓&lt;a href="https://t.co/LB3Q7HUxhf"&gt;https://t.co/LB3Q7HUxhf&lt;/a&gt;&lt;/p&gt;&amp;mdash; James Newton-King ♔ (&amp;#64;JamesNK) &lt;a href="https://twitter.com/JamesNK/status/1433907307331538944?ref_src=twsrc%5Etfw"&gt;September 3, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;開放されるべきオブジェクトを WeakReference に入れておくことでユニットテストで手っ取り早くメモリーリークを検出するというテクニック。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;Here&amp;#39;s a somewhat not well known trick in C#: you can define extension methods for pointers too! The extension needs to take a this ref parameter, and then the compiler will pick it up when using the normal -&amp;gt; operator on compatible pointers. Niche, but useful! 🚀&lt;a href="https://twitter.com/hashtag/dotnet?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#dotnet&lt;/a&gt; &lt;a href="https://twitter.com/hashtag/csharp?src=hash&amp;amp;ref_src=twsrc%5Etfw"&gt;#csharp&lt;/a&gt; &lt;a href="https://t.co/ZoVq5Rkl2x"&gt;pic.twitter.com/ZoVq5Rkl2x&lt;/a&gt;&lt;/p&gt;&amp;mdash; Sergio Pedri (&amp;#64;SergioPedri) &lt;a href="https://twitter.com/SergioPedri/status/1435569329110724614?ref_src=twsrc%5Etfw"&gt;September 8, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;&lt;code&gt;ref this&lt;/code&gt; で定義した拡張メソッドはポインター型(&lt;code&gt;int*&lt;/code&gt; など)に対して使用でき、参照として渡ってくるのでうまく扱えるというテクニック。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;I&amp;#39;d expect not having this struct copy here...👀 /cc:&lt;a href="https://twitter.com/EgorBo?ref_src=twsrc%5Etfw"&gt;&amp;#64;EgorBo&lt;/a&gt;? &lt;a href="https://t.co/7qmWl1Ua21"&gt;pic.twitter.com/7qmWl1Ua21&lt;/a&gt;&lt;/p&gt;&amp;mdash; Konrad Kokosa (&amp;#64;konradkokosa) &lt;a href="https://twitter.com/konradkokosa/status/1434130844260655105?ref_src=twsrc%5Etfw"&gt;September 4, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;構造体を &lt;code&gt;ref&lt;/code&gt; 渡ししているにもかかわらずコピーが発生してしまうことがあるというツイート。続くリプライにコンストラクターで初期化したりフィールドの数によっては問題なくコピーが発生しないようになるなど(難しくてあまりちゃんと理解していない…)。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="support-the-windows-11-io-ring-api-issue-58752-dotnetruntime"&gt;Support the Windows 11 I/O ring API · Issue #58752 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/58752"&gt;https://github.com/dotnet/runtime/issues/58752&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows 11 で io_uring のようなリングバッファベースの IO API ができるのでそれをサポートしてほしいという提案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/windows/win32/api/ioringapi/"&gt;ioringapi - Win32 apps | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://windows-internals.com/i-o-rings-when-one-i-o-operation-is-not-enough/"&gt;I/O Rings – When One I/O Operation is Not Enough – Winsider Seminars &amp;amp; Solutions Inc.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/51985"&gt;Implement io_uring support for FileStream · Issue #51985 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="api-proposal-regexgenerator.attribute-issue-58880-dotnetruntime"&gt;[API Proposal]: [RegexGenerator(...)] attribute · Issue #58880 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/58880"&gt;https://github.com/dotnet/runtime/issues/58880&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Regex をソースジェネレーターで事前にコンパイルしておくために &lt;code&gt;RegexGenerator&lt;/code&gt; 属性を導入したいという提案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/44676"&gt;Developers can precompile their Regex code for faster startup · Issue #44676 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="why-can-nameof-not-be-used-with-alias-qualified-types-at-the-root-level-stack-overflow"&gt;Why can nameof not be used with alias-qualified types at the root level? - Stack Overflow&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/69116668/why-can-nameof-not-be-used-with-alias-qualified-types-at-the-root-level"&gt;https://stackoverflow.com/questions/69116668/why-can-nameof-not-be-used-with-alias-qualified-types-at-the-root-level&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;global::ClassA&lt;/code&gt; のようなルート名前空間にある型をエイリアス付きで指定するものを &lt;code&gt;typeof(global::ClassA)&lt;/code&gt; のように &lt;code&gt;typeof&lt;/code&gt; では使えるのに &lt;code&gt;nameof(global::ClassA)&lt;/code&gt; で使えないのはなぜという話。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/csharplang/discussions/911"&gt;Please permit &lt;code&gt;nameof(global::N)&lt;/code&gt; · Discussion #911 · dotnet/csharplang&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-09-03</title>
			<link>/2021/09/03/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/09/03/updates</guid>
			<pubDate>Fri, 03 Sep 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;h2 id="section"&gt;主なトピックス&lt;/h2&gt;
&lt;p&gt;今週は大きなリリースはなく、主に .NET 6 に向けた改善や API の紹介記事などが出てきています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/"&gt;File IO improvements in .NET 6 | .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/new-dotnet-6-apis-driven-by-the-developer-community/"&gt;New .NET 6 APIs driven by the developer community | .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NETのクラスライブラリ設計の改訂新版が来月上旬に発売となります。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://twitter.com/yfakariya/status/1433398719815114756"&gt;https://twitter.com/yfakariya/status/1433398719815114756&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;現在入手可能なものは原著の 2nd Edition をベースとしたものですでに12年が経過しており、今回の改訂新版は去年出版された 3rd Edition となり、async から &lt;code&gt;Span&amp;lt;T&amp;gt;&lt;/code&gt; などもカバーされているようです。&lt;/p&gt;
&lt;h2 id="section-1"&gt;ヘッドライン&lt;/h2&gt;
&lt;h3 id="file-io-improvements-in.net-6.net-blog"&gt;File IO improvements in .NET 6 | .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/"&gt;https://devblogs.microsoft.com/dotnet/file-io-improvements-in-dotnet-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で FileStream を改善してパフォーマンスを改善した話。&lt;/p&gt;
&lt;p&gt;スレッドセーフなオフセットベースでのアクセスを可能とする &lt;code&gt;RandomAccess&lt;/code&gt; クラスの追加。&lt;code&gt;PreallocationSize&lt;/code&gt; による事前に必要なサイズを渡すオプションの追加により、あらかじめ必要なサイズを OS に通知できるように。複数のバッファを読み書きする Scatter-Gather IO (ベクタ IO) をサポートする API の追加で scatter/gather パターンでのシステムコールを減らしパフォーマンスを向上できるように。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/ja-jp/dotnet/api/system.io.randomaccess?view=net-6.0"&gt;RandomAccess Class (System.IO) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;挙動に破壊的変更が若干あるため、.NET 5 と同様の挙動にするオプションの設定方法についても説明 (.NET 7 で削除予定)。&lt;/p&gt;
&lt;h3 id="new.net-6-apis-driven-by-the-developer-community.net-blog"&gt;New .NET 6 APIs driven by the developer community | .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/new-dotnet-6-apis-driven-by-the-developer-community/"&gt;https://devblogs.microsoft.com/dotnet/new-dotnet-6-apis-driven-by-the-developer-community/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 で追加や使いやすくなった API の紹介。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ファイルのランダムアクセスの API&lt;/li&gt;
&lt;li&gt;Environment.ProcessId/ProcessPath&lt;/li&gt;
&lt;li&gt;CSPNG から手軽にランダムバイト列の取得&lt;/li&gt;
&lt;li&gt;Parallel.ForEachAsync の追加&lt;/li&gt;
&lt;li&gt;LINQ の Chunk, MinBy/MaxBy の追加&lt;/li&gt;
&lt;li&gt;ConfigurationHelper での必須項目の取得方法の追加&lt;/li&gt;
&lt;li&gt;2の乗数かどうかをチェックする BitOperations.IsPow2 と一番近い値にする BitOperations.RoundUpToPowerOf2 の追加&lt;/li&gt;
&lt;li&gt;Task の待機にタイムアウトを指定できる WaitAsync(TimeSpan) の追加&lt;/li&gt;
&lt;li&gt;ArgumentNullException を簡単にスローする ArgumentNullException.ThrowIfNull の追加&lt;/li&gt;
&lt;li&gt;ネイティブメモリーを扱う NativeMemory クラスの追加&lt;/li&gt;
&lt;li&gt;POSIX シグナルハンドリング&lt;/li&gt;
&lt;li&gt;OpenTelemetry API の形をベースとした Metrics API の追加&lt;/li&gt;
&lt;li&gt;await を使用する形のモダンなタイマーの追加&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="introducing-the.net-maui-community-toolkit-preview.net-blog"&gt;Introducing the .NET MAUI Community Toolkit (Preview) | .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/introducing-the-net-maui-community-toolkit-preview/"&gt;https://devblogs.microsoft.com/dotnet/introducing-the-net-maui-community-toolkit-preview/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET MAUI Community Toolkit のプレビューリリースとスケジュールについて。また、同時に Xamarin Community Toolkit の互換インターフェースを提供するライブラリも公開。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/xamarin/introducing-net-maui-compatibility-for-the-xamarin-community-toolkit/"&gt;Introducing .NET MAUI Compatibility for the Xamarin Community Toolkit&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="windows-terminal-preview-1.11-release-windows-command-line"&gt;Windows Terminal Preview 1.11 Release | Windows Command Line&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/commandline/windows-terminal-preview-1-11-release/"&gt;https://devblogs.microsoft.com/commandline/windows-terminal-preview-1-11-release/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows Terminal Preview 1.11 がリリース。&lt;/p&gt;
&lt;p&gt;タイトルバーのアクリルスタイル、システムトレイへの最小化、強調テキストのスタイル、+ボタンへのドラッグアンドドロップ、ペイン関連の強化など。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/microsoft/terminal/releases/tag/v1.10.2383.0"&gt;Release Windows Terminal Preview v1.10.2383.0 · microsoft/terminal&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="resharper-2021.2.1-and-rider-2021.2.1-bug-fixes-are-out"&gt;ReSharper 2021.2.1 and Rider 2021.2.1 Bug Fixes Are Out!&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/08/27/resharper-rider-2021-2-1/"&gt;https://blog.jetbrains.com/dotnet/2021/08/27/resharper-rider-2021-2-1/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rider 2021.2.1 と ReSharper 2021.2.1 のリリース。主にバグフィックス。&lt;/p&gt;
&lt;h3 id="g2-grpc-over-http3-by-jamesnk-pull-request-256-grpcproposal"&gt;G2: gRPC over HTTP/3 by JamesNK · Pull Request #256 · grpc/proposal&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/grpc/proposal/pull/256"&gt;https://github.com/grpc/proposal/pull/256&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;gRPC over HTTP/3 の提案。エラーコードのマッピングや HTTP/2 とは異なる部分の対応。&lt;/p&gt;
&lt;h3 id="net-core-2.02.1-has-reached-end-of-life"&gt;.NET Core 2.0/2.1 has reached end of life&lt;/h3&gt;
&lt;p&gt;.NET Core 2.0 と 2.1 のサポートが8月21日に終了した旨のアナウンス。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/announcements/issues/199"&gt;.NET Core 2.1 has reached end of life · Issue #199 · dotnet/announcements&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/announcements/issues/86"&gt;.NET Core 2.0 has reached end of life · Issue #86 · dotnet/announcements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="visual-studio-2022-for-mac-version-17.0-private-preview-1.3"&gt;Visual Studio 2022 for Mac version 17.0 Private Preview 1.3&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#17.0.0-priv-pre.1.3"&gt;https://docs.microsoft.com/en-us/visualstudio/releases/2022/mac-release-notes-preview#17.0.0-priv-pre.1.3&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 for Mac version 17.0 Private Preview 1.3 がリリース。&lt;/p&gt;
&lt;p&gt;主にバグフィックスを含むリリース。現在プライベートプレビュー中のためフォームでの申し込みが必要。&lt;/p&gt;
&lt;h2 id="section-2"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="intellisense-for-hosted-c-script"&gt;IntelliSense for Hosted C# Script&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://haacked.com/archive/2021/09/01/hosted-csharp-intellisense/"&gt;http://haacked.com/archive/2021/09/01/hosted-csharp-intellisense/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# スクリプトの IntelliSense を実現するための MirrorSharp や OmniSharp の紹介。&lt;/p&gt;
&lt;h3 id="investigation-of-an-openssl-cve-found-in-aspnet5.0-image"&gt;Investigation of an OpenSSL CVE found in aspnet:5.0 image&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;olivier.gaumond/investigation-of-an-openssl-cve-found-in-aspnet-5-0-image-2d66b03c9d53"&gt;https://medium.com/&amp;#64;olivier.gaumond/investigation-of-an-openssl-cve-found-in-aspnet-5-0-image-2d66b03c9d53&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;OpenSSL CVE が発行され、.NET 5 の ASP.NET Core のコンテナーイメージを脆弱性スキャンで検出される話。&lt;/p&gt;
&lt;p&gt;これは Debian のベースイメージは更新されたがその後に .NET のイメージが再ビルドされていないため検出される。バージョンの固定による把握や脆弱性スキャンの重要性。&lt;/p&gt;
&lt;h3 id="the.net-teams-favorite-razor-features"&gt;The .NET Team's Favorite Razor Features&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/dotnet/the-net-team-s-favorite-razor-features-5b72"&gt;https://dev.to/dotnet/the-net-team-s-favorite-razor-features-5b72&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET チームがおすすめする Razor の機能 (主に ASP.NET Core のビューとしての Razor)。タグヘルパー, &lt;code&gt;&amp;#64;await&lt;/code&gt;, &lt;code&gt;&amp;#64;inject&lt;/code&gt;, &lt;code&gt;&amp;#64;:&lt;/code&gt;, 各種ライブラリーなど。&lt;/p&gt;
&lt;h3 id="a-neat-trick-to-debug-exceptions-in-c"&gt;A neat Trick to Debug Exceptions in C#&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.rismosch.com/article?id=a-neat-trick-to-debug-exceptions-in-c-sharp"&gt;https://www.rismosch.com/article?id=a-neat-trick-to-debug-exceptions-in-c-sharp&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;例外デバッグのちょっとしたテクニックの紹介。catch 句ではすでにスタックトレースが巻き戻った状態になるが、when 句の中ではまだスタックの状態が維持されているため、そこで止めることで呼び出し元の状態を確認できるというテクニック。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://user-images.githubusercontent.com/9012/132095029-3dec69ba-71c9-4f00-929a-1e23ad91250a.png" alt="image" /&gt;
&lt;img src="https://user-images.githubusercontent.com/9012/132095027-57fe587d-f3c0-4ba0-964e-594234c74881.png" alt="image" /&gt;&lt;/p&gt;
&lt;h3 id="optimization-of.net-applications-a-big-result-of-small-edits"&gt;Optimization of .NET applications: a big result of small edits&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://pvs-studio.com/en/blog/posts/csharp/0852/"&gt;https://pvs-studio.com/en/blog/posts/csharp/0852/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Framework アプリケーションに関する最適化のポイントについて (.NET/.NET Core ではなく .NET Framework の話であることに注意)。&lt;/p&gt;
&lt;h3 id="blazor-webassemblyaot"&gt;Blazor WebAssemblyのAOTコンパイルでクライアントサイドの画像処理を高速化&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/kaorumori/articles/1aa45e5ec256c1"&gt;https://zenn.dev/kaorumori/articles/1aa45e5ec256c1&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 Preview 4 で導入された Blazor WebAssemly の AOT コンパイルを使用することで処理を高速化することについて。&lt;/p&gt;
&lt;p&gt;コンパイルには時間がかかるがImageSharp のような処理内容次第では大きな効果が見込める実例など。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/aspnet/asp-net-core-updates-in-net-6-preview-4/#blazor-webassembly-ahead-of-time-aot-compilation"&gt;Blazor WebAssembly ahead-of-time (AOT) compilation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="authenticating-your-nextjs-app-to-a.net-api-with-auth0"&gt;Authenticating your NextJs App to a .net API with Auth0&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;projectsbydan/authenticating-your-nextjs-app-to-a-net-api-with-auth0-d092747a6201"&gt;https://medium.com/&amp;#64;projectsbydan/authenticating-your-nextjs-app-to-a-net-api-with-auth0-d092747a6201&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core で実装された API 呼び出す Next.js アプリを Auth0 で認証する方法について。&lt;/p&gt;
&lt;h3 id="firebase-authentication.net-5"&gt;Firebase Authentication .NET 5&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/ivan_pesenti/firebase-authentication-net-5-29oi"&gt;https://dev.to/ivan_pesenti/firebase-authentication-net-5-29oi&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core アプリケーションで Firebase Authentication を使用する手順について。&lt;/p&gt;
&lt;h3 id="add-a-readme-to-your-nuget-package-the-nuget-blog"&gt;Add a README to Your NuGet Package | The NuGet Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/nuget/add-a-readme-to-your-nuget-package/"&gt;https://devblogs.microsoft.com/nuget/add-a-readme-to-your-nuget-package/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;NuGet パッケージに README ファイルを含めてパブリッシュすることで NuGet.org のパッケージページ上に表示する方法について。ただし、現状 .NET 6 Preview の SDK では snupkg を生成するようにするとエラーとなる問題がある点に注意。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/NuGet/Home/issues/10791"&gt;Cannot use embeded PackageReadmeFile when using snupkg for symbols · Issue #10791 · NuGet/Home&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="unconventional-way-to-name-this-variable-in-extension-methods"&gt;(Un)Conventional way to name &lt;code&gt;this&lt;/code&gt; variable in extension methods&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://medium.com/&amp;#64;simonas.baltulionis/un-conventional-way-to-name-this-variable-in-extension-methods-68091f9f8b8b"&gt;https://medium.com/&amp;#64;simonas.baltulionis/un-conventional-way-to-name-this-variable-in-extension-methods-68091f9f8b8b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;拡張メソッドのターゲットとなる引数 (例: &lt;code&gt;this string value&lt;/code&gt;) の名前に &lt;code&gt;this&lt;/code&gt; という名前を使えてしまうという話と、それを名前付き引数で呼び出すときに Unicode エスケープできるという話。&lt;/p&gt;
&lt;h3 id="net-annotated-monthly-september-2021-the.net-tools-blog"&gt;.NET Annotated Monthly | September 2021 | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/09/02/net-annotated-monthly-september-2021/"&gt;https://blog.jetbrains.com/dotnet/2021/09/02/net-annotated-monthly-september-2021/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;JetBrains による .NET 関連のまとめ9月号&lt;/p&gt;
&lt;h2 id="section-3"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="cysharpobservablecollections-high-performance-observable-collections-and-synchronized-views-for-wpf-blazor-unity"&gt;Cysharp/ObservableCollections: High performance observable collections and synchronized views, for WPF, Blazor, Unity.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/Cysharp/ObservableCollections"&gt;https://github.com/Cysharp/ObservableCollections&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;WPF, Blazor, Unity 向けの変更通知を受けられるコレクションを提供するライブラリ。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;ObservableCollection&amp;lt;T&amp;gt;&lt;/code&gt; とは異なりあらかじめソートされた結果のビューなどを定義しておくことで表示に反映していくということができる。&lt;/p&gt;
&lt;h3 id="wiremock-netwiremock.net-wiremock.net-is-a-flexible-library-for-stubbing-and-mocking-web-http-responses-using-request-matching-and-response-templating.based-on-the-functionality-from-wiremock.org-but-extended-with-more-functionality"&gt;WireMock-Net/WireMock.Net: WireMock.Net is a flexible library for stubbing and mocking web HTTP responses using request matching and response templating. Based on the functionality from WireMock.org, but extended with more functionality.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/WireMock-Net/WireMock.Net"&gt;https://github.com/WireMock-Net/WireMock.Net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;モック API サーバーを実装する &lt;a href="http://wiremock.org/"&gt;WireMock&lt;/a&gt; の .NET 実装。&lt;/p&gt;
&lt;p&gt;設定で単純な返しを行うモックサーバーからプロキシや、コードベースでふるまいを定義できる。&lt;/p&gt;
&lt;h3 id="dirs-devdirectories-net-directories.net"&gt;dirs-dev/directories-net: Directories.Net&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dirs-dev/directories-net"&gt;https://github.com/dirs-dev/directories-net&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;プラットフォームを抽象化してドキュメントフォルダーのようなものを取得するライブラリの .NET 実装。&lt;/p&gt;
&lt;p&gt;Windows は Known Folder API、macOS は Standard Directories 定義、Linux では xdg-user-dirs を使用する。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://dirs.dev/"&gt;Extended Directories Guide for Software Developers&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="github-dotnetruntimelab-at-featureregexsrm"&gt;GitHub - dotnet/runtimelab at feature/regexsrm&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtimelab/tree/feature/regexsrm"&gt;https://github.com/dotnet/runtimelab/tree/feature/regexsrm&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;runtimelab の Symbolic Regex Matcher の実装ブランチ。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/AutomataDotNet/srm"&gt;AutomataDotNet/srm: High-performance .NET regex engine with predictable performance&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-4"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="quiz-evaluate-you.net-memory-management-skills"&gt;Quiz - Evaluate you .NET memory management skills&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://quiz.dotnetmemoryexpert.com/"&gt;https://quiz.dotnetmemoryexpert.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET の GC やメモリの扱いに関するクイズ。&lt;/p&gt;
&lt;h3 id="abbot-make-chat-your-command-center"&gt;Abbot: Make Chat Your Command Center&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ab.bot/"&gt;https://ab.bot/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C#, Python, JavaScript で Hubot のような Slack, Discord, Teams 向けのチャットコマンドアプリを作れるサービス。&lt;/p&gt;
&lt;p&gt;提供元の A Serious Business, Inc. は Phill Haack さんが創設者で CTO の会社。&lt;/p&gt;
&lt;h3 id="ryzngard-twitch"&gt;ryzngard - Twitch&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.twitch.tv/ryzngard"&gt;https://www.twitch.tv/ryzngard&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Roslyn にコミットしているエンジニアの Andrew さんのコーディング配信。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/ryzngard"&gt;ryzngard (Andrew Hall)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="section-5"&gt;ツイート&lt;/h3&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="ja" dir="ltr"&gt;『.NETのクラスライブラリ設計 改訂新版』、来月上旬発売予定です。&lt;br&gt;非互換の考え方などの付録も完全収録、コンテンツの追加等諸々で前の版の1.5倍超のボリューム、豪華監訳陣を加え訳文の質も上がってます！&lt;br&gt;&lt;br&gt;C# 書かない人もライブラリ設計の参考になるかも。&lt;br&gt;電子版もリフロー形式で発売予定です。 &lt;a href="https://t.co/hCTGTNFoc5"&gt;pic.twitter.com/hCTGTNFoc5&lt;/a&gt;&lt;/p&gt;&amp;mdash; FUJIWARA, Yusuke (&amp;#64;yfakariya) &lt;a href="https://twitter.com/yfakariya/status/1433398719815114756?ref_src=twsrc%5Etfw"&gt;September 2, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;&lt;a href="https://www.pearson.com/us/higher-education/program/Cwalina-Framework-Design-Guidelines-Conventions-Idioms-and-Patterns-for-Reusable-NET-Libraries-3rd-Edition/PGM2686089.html"&gt;Framework Design Guidelines: Conventions, Idioms, and Patterns for Reusable .NET Libraries, 3rd Edition&lt;/a&gt; の日本語訳版が10月上旬に発売予定。&lt;/p&gt;
&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="ja" dir="ltr"&gt;Unity 2021.1.19f1 で C# 8.0 の await using 使うとコンパイルエラー（CS0518）が起きる件について、「ランボー 怒りの Bug Reports」をキメたので、再現プロジェクト置いておきますね。&lt;a href="https://t.co/LKUvz0cwGV"&gt;https://t.co/LKUvz0cwGV&lt;/a&gt;&lt;/p&gt;&amp;mdash; もんりぃ先生 (&amp;#64;monry) &lt;a href="https://twitter.com/monry/status/1433255396492283913?ref_src=twsrc%5Etfw"&gt;September 2, 2021&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;p&gt;Unity 2021.1 では C# 8 が使えるようになっているが、C# 8 の公式サポートは .NET Standard 2.1 または .NET Core 3.x 以降となっているギャップにより &lt;code&gt;await using&lt;/code&gt; を使ったコードで問題が出るという話。&lt;code&gt;IAsyncDisposable&lt;/code&gt; がないためでダミーの型を追加するか .NET Standard 2.1 をサポートする Unity 2021.2.0b6 以降を使う。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://twitter.com/neuecc/status/1433264122209046529"&gt;IAsyncDisposableまとめ — neuecc (&amp;#64;neuecc)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="consider-returning-a-generic-dictionary-from-environment.getenvironmentvariables.issue-58438-dotnetruntime"&gt;Consider returning a generic &lt;code&gt;Dictionary&lt;/code&gt; from &lt;code&gt;Environment.GetEnvironmentVariables&lt;/code&gt;. · Issue #58438 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/58438"&gt;https://github.com/dotnet/runtime/issues/58438&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Environment.GetEnvironmentVariables がジェネリックな Dictionary を返してほしいという話。&lt;/p&gt;
&lt;p&gt;Hashtable そのものや yield する際に DictionaryEntry が返ってくることを期待している既存コードが多く、過去に断念している話など。&lt;/p&gt;
&lt;h3 id="api-proposal-make-stringbuilder.appendspanformattable-issue-58459-dotnetruntime-github"&gt;[API Proposal]: Make StringBuilder.AppendSpanFormattable · Issue #58459 · dotnet/runtime · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/58459"&gt;https://github.com/dotnet/runtime/issues/58459&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;StringBuilder に ISpanFormattable を受ける API が欲しいという提案。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/58458"&gt;[API Proposal]: Add System.Guid support to StringBuilder · Issue #58458 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="use-indexof-to-find-value-for-smaller-enums-by-stephentoub-pull-request-57973-dotnetruntime"&gt;Use IndexOf to find value for smaller enums by stephentoub · Pull Request #57973 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/57973"&gt;https://github.com/dotnet/runtime/pull/57973&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Enum の文字列キャッシュなどを今まではバイナリサーチしていたが、数が少ない場合はリニアに探すほうが速いという PR。&lt;/p&gt;
&lt;h3 id="add-symbolic-link-apis-by-carlossanlop-pull-request-54253-dotnetruntime"&gt;Add symbolic link APIs by carlossanlop · Pull Request #54253 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/54253"&gt;https://github.com/dotnet/runtime/pull/54253&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 Preview 4 でシンボリックリンクやジャンクションなどを取り扱えるようになる API が追加。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.filesysteminfo.resolvelinktarget?view=net-6.0"&gt;FileSystemInfo.ResolveLinkTarget(Boolean) Method (System.IO) | Microsoft Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/24271"&gt;Proposed API for symbolic links · Issue #24271 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/57996"&gt;Add internal junction support to link APIs by carlossanlop · Pull Request #57996 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="higher-level-syntaxprovider-apis-for-incremental-generators-issue-54725-dotnetroslyn"&gt;Higher Level SyntaxProvider APIs for incremental generators · Issue #54725 · dotnet/roslyn&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/roslyn/issues/54725"&gt;https://github.com/dotnet/roslyn/issues/54725&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/55984"&gt;Source generators high level syntax api by chsienki · Pull Request #55984 · dotnet/roslyn · GitHub&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="remove-usage-of-aggressiveoptimization-by-steveharter-pull-request-58209-dotnetruntime"&gt;Remove usage of [AggressiveOptimization] by steveharter · Pull Request #58209 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/58209"&gt;https://github.com/dotnet/runtime/pull/58209&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;System.Text.Json から4か所の AggressiveOptimization を外した PR。&lt;/p&gt;
&lt;p&gt;2か所はループを持つため AO の効果がなく、残りの2つは非 R2R (Ready-to-Run) 環境の Release ビルドでのみ効果があり R2R では元々 AO 相当の効果がある、また AO を外すことで Dynamic PGO モード をサポートできるといった利点がある。&lt;/p&gt;
&lt;p&gt;ローカルの Release ビルドで…と書かれているので、通常配布されている .NET ランタイムの In-box ライブラリは各プラットフォーム向けで R2R 済みと思われる。&lt;/p&gt;
&lt;p&gt;Dynamic PGO は .NET 6 で導入された実行時にプロファイリングして最適化をかけるオプトイン機能(なので &amp;quot;best perf but slow start&amp;quot; / 開始は遅いが最高のパフォーマンス)。&lt;/p&gt;
&lt;h3 id="add-win11-rids-by-vitek-karas-pull-request-58588-dotnetruntime-github"&gt;Add Win11 RIDs by vitek-karas · Pull Request #58588 · dotnet/runtime · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/58588"&gt;https://github.com/dotnet/runtime/pull/58588&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Windows 11 向けの Runtime Identifier (RID) の追加。&lt;/p&gt;
&lt;h3 id="use-lambda-expression-and-method-group-signature-in-type-inference-by-cston-pull-request-55786-dotnetroslyn"&gt;Use lambda expression and method group signature in type inference by cston · Pull Request #55786 · dotnet/roslyn&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/55786"&gt;https://github.com/dotnet/roslyn/pull/55786&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ラムダ式の型推論の強化に関する PR がマージされた。&lt;/p&gt;
&lt;h3 id="support-generic-array-parameters-in-components-by-campersau-pull-request-34734-dotnetaspnetcore-github"&gt;Support generic array parameters in components by campersau · Pull Request #34734 · dotnet/aspnetcore · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/pull/34734"&gt;https://github.com/dotnet/aspnetcore/pull/34734&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;型パラメーターを受けるような Blazor のコンポーネントで配列を使えなかった問題の修正 PR。&lt;/p&gt;
&lt;h3 id="adds-tizen-backend-by-rookiejava-pull-request-2360-dotnetmaui"&gt;Adds Tizen backend by rookiejava · Pull Request #2360 · dotnet/maui&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/maui/pull/2360"&gt;https://github.com/dotnet/maui/pull/2360&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MAUI への Tizen のバックエンド追加の PR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-08-27</title>
			<link>/2021/08/27/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/08/27/updates</guid>
			<pubDate>Fri, 27 Aug 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;h2 id="section"&gt;主なトピックス&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://blog.getpaint.net/2021/08/11/paint-net-4-3-alpha-build-7894/"&gt;paint.net 4.3 alpha&lt;/a&gt; がリリースされ、α版ですが比較的有名なデスクトップアプリケーションの .NET 5 への移行が実現しています。&lt;/p&gt;
&lt;h2 id="section-1"&gt;ヘッドライン&lt;/h2&gt;
&lt;h3 id="paint.net-4.3-alpha-build-7894-paint.net-blog"&gt;paint.net 4.3 alpha (build 7894) – paint.net blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.getpaint.net/2021/08/11/paint-net-4-3-alpha-build-7894/"&gt;https://blog.getpaint.net/2021/08/11/paint-net-4-3-alpha-build-7894/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;paint.net 4.3 alpha がリリース。&lt;/p&gt;
&lt;p&gt;このバージョンで .NET Framework から .NET 5 への移行が行われた。ユーザーからは表面上変化が見えない形での移行。&lt;/p&gt;
&lt;p&gt;.NET 5 へと移行したことに伴い self-contained deployment により .NET のインストールが不要になり、パフォーマンスも向上。起動時間は AOT の効果で 5% 程度短くなる、ARM64 ビルドの提供も可能となった、など。&lt;/p&gt;
&lt;h3 id="update-implicit-global-usings-feature-to-address-issues-issue-19521-dotnetsdk"&gt;Update implicit global usings feature to address issues · Issue #19521 · dotnet/sdk&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/sdk/issues/19521"&gt;https://github.com/dotnet/sdk/issues/19521&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Preview 7 で導入した暗黙の global usings でいくつか問題が出たので C# プロジェクトでは明示的に指定しない限り有効とならないようにするよう挙動の変更。SDK 6.0.100-rc.1 にて入る予定。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;C# プロジェクトでは &lt;code&gt;DisableImplicitNamespaceImports&lt;/code&gt; MSBuild プロパティを &lt;code&gt;ImplicitUsings&lt;/code&gt; プロパティに変更
&lt;ul&gt;
&lt;li&gt;Visual Basic のプロジェクトでは引き続き &lt;code&gt;DisableImplicitNamespaceImports&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ImplictUsings&lt;/code&gt; プロパティが &lt;code&gt;enable&lt;/code&gt; または &lt;code&gt;true&lt;/code&gt; と定義されている場合のみ暗黙の using が使われる&lt;/li&gt;
&lt;li&gt;それに伴い .NET 6 プロジェクトのテンプレートでは &lt;code&gt;&amp;lt;ImplicitUsings&amp;gt;enable&amp;lt;/ImplicitUsings&amp;gt;&lt;/code&gt; が含まれてデフォルト有効化される形となる&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="api-proposal-attribute-for-passing-caller-identity-implicitly-issue-4984-dotnetcsharplang"&gt;[API proposal] Attribute for passing caller identity implicitly · Issue #4984 · dotnet/csharplang&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/csharplang/issues/4984"&gt;https://github.com/dotnet/csharplang/issues/4984&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;CallerMemberNameAttribute&lt;/code&gt; 属性などと同様にメソッドの引数に呼び出し元のアセンブリ、型、メソッドをコンパイル時に差し込むための属性の提案。&lt;code&gt;Assembly.GetCallingAssembly&lt;/code&gt; の AOT セーフで高速な代替として。&lt;/p&gt;
&lt;h3 id="api-proposal-regexoptions.constrained-issue-57891-dotnetruntime"&gt;[API Proposal]: RegexOptions.Constrained · Issue #57891 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/57891"&gt;https://github.com/dotnet/runtime/issues/57891&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 7 で正規表現エンジンに DFA モードをオプトインで追加することを検討しているので、そのためのフラグを追加する提案。&lt;/p&gt;
&lt;h3 id="user-story.net-7.0-developers-can-verify-more-apis-for-correct-usage-to-speed-up-their-development-57797"&gt;User Story: .NET 7.0 developers can verify more APIs for correct usage to speed up their development #57797&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/57797"&gt;https://github.com/dotnet/runtime/issues/57797&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 から組み込み Roslyn Analyzer が導入されたので .NET ベースライブラリの使用方法を支援するためにアナライザーを拡充しようという話の .NET 7 向けの話。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/43617"&gt;User Story: .NET 6.0 developers can verify more APIs for their correct usage to speed up their development · Issue #43617 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="big-endian-platforms-not-supported-issue-35709-dotnetaspnetcore-github"&gt;Big-endian platforms not supported · Issue #35709 · dotnet/aspnetcore · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/issues/35709"&gt;https://github.com/dotnet/aspnetcore/issues/35709&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core の様々な個所でビッグエンディアンを考慮していないため、IBM Z (s390x) で動作しないという Issue と Pull requests。&lt;/p&gt;
&lt;p&gt;.NET 6 からターゲットアーキテクチャに s390x (linux-s390x) が追加され、ベースライブラリや CoreCLR へのパッチなどが入っている。現時点では CoreCLR ではなく Mono ランタイムを使用するとのこと。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/52909"&gt;Add public Architecture enum value for s390x · Issue #52909 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pulls?q=is%3Apr+s390x+is%3Aclosed"&gt;is:pr s390x is:closed · Pull requests · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/53950"&gt;Build support for s390x: installers and packages by uweigand · Pull Request #53950 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-2"&gt;アーティクル、スライドなど&lt;/h2&gt;
&lt;h3 id="the-journey-to-accessible-apps-making-visual-text-accessible-xamarin-blog"&gt;The Journey to Accessible Apps: Making Visual Text Accessible | Xamarin Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/xamarin/the-journey-to-accessible-apps-making-visual-text-accessible/"&gt;https://devblogs.microsoft.com/xamarin/the-journey-to-accessible-apps-making-visual-text-accessible/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;モバイルアプリで目に見える文字をアクセシブルにするときに考慮する点やテスト方法などについて。&lt;/p&gt;
&lt;h3 id="google-app-engine.net-5"&gt;Google App Engine で .NET 5 を動かす&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/shimat/articles/4c4e292646f32e"&gt;https://zenn.dev/shimat/articles/4c4e292646f32e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Google App Engine Flexible (GAE) では.NET Core 3.1 までしかコンテナーイメージがないため .NET 5 のコンテナーをビルドする方法について。&lt;/p&gt;
&lt;h3 id="how-to-build-an-interactive-command-line-application-in.net"&gt;How to build an interactive command-line application in .NET&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/shibayan/how-to-build-an-interactive-command-line-application-in-net-4oic"&gt;https://dev.to/shibayan/how-to-build-an-interactive-command-line-application-in-net-4oic&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/shibayan/Sharprompt"&gt;Sharprompt&lt;/a&gt; を使用して質問や選択などの入力をもつインタラクティブなコマンドラインアプリケーションの作り方。&lt;/p&gt;
&lt;h3 id="flavours-of-rounding"&gt;Flavours of rounding&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://dev.to/semuserable/flavours-of-rounding-42e0"&gt;https://dev.to/semuserable/flavours-of-rounding-42e0&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET を含む、いろいろな言語やランタイムでの丸め (例:&lt;code&gt;Math.Round&lt;/code&gt;) の例。&lt;/p&gt;
&lt;h3 id="cedec-2021"&gt;[CEDEC 2021] 運用中タイトルでも怖くない！ 『メルクストーリア』におけるハイパフォーマンス・ローコストなリアルタイム通信技術の導入事例&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.slideshare.net/NaoyaKishimoto/cedec-2021"&gt;https://www.slideshare.net/NaoyaKishimoto/cedec-2021&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/Cysharp/MagicOnion"&gt;MagicOnion (gRPC ベースの C# RPC フレームワーク)&lt;/a&gt; を使用した ASP.NET Core サーバー、Unity クライアントでのリアルタイム通信技術を Kubernetes 環境に Agones とともに構築した事例。&lt;/p&gt;
&lt;h3 id="tips-and-tricks-to-increase-your-productivity-in-visual-studio-2019"&gt;15 Tips and Tricks to Increase Your Productivity in Visual Studio 2019&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://arunkani-a.medium.com/15-tips-and-tricks-to-increase-your-productivity-in-visual-studio-2019-5d2329d3252f"&gt;https://arunkani-a.medium.com/15-tips-and-tricks-to-increase-your-productivity-in-visual-studio-2019-5d2329d3252f&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2019 で便利な小ネタ15選の紹介。&lt;/p&gt;
&lt;h3 id="in-c-how-do-i-get-the-descriptive-text-for-an-hresult-the-old-new-thing"&gt;In C#, how do I get the descriptive text for an HRESULT? | The Old New Thing&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/oldnewthing/20210826-00/?p=105609"&gt;https://devblogs.microsoft.com/oldnewthing/20210826-00/?p=105609&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;COM の HRESULT に対応する文字列を簡単に取得する方法。&lt;code&gt;Marshal.GetExceptionForHR&lt;/code&gt; メソッドで Exception を作成して Message を取り出す。&lt;/p&gt;
&lt;h3 id="hidden-productivity-gems-in-resharper-and-rider-michaels-coding-spot"&gt;6 Hidden Productivity Gems in Resharper and Rider - Michael's Coding Spot&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://michaelscodingspot.com/productivity-in-resharper-and-rider/"&gt;https://michaelscodingspot.com/productivity-in-resharper-and-rider/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReSharper と Rider の目立たない便利機能6選の紹介。&lt;/p&gt;
&lt;h3 id="bite-size-c-10-semi-auto-properties-and-field-keyword"&gt;Bite-Size C# 10 - Semi-Auto Properties and 'field' Keyword&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://exceptionnotfound.net/bite-size-csharp-10-semi-auto-properties-using-field-keyword/"&gt;https://exceptionnotfound.net/bite-size-csharp-10-semi-auto-properties-using-field-keyword/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;C# 10 からプロパティのバッキングフィールドにアクセスする &lt;code&gt;field&lt;/code&gt; キーワードが追加されるので半自動実装プロパティが実現できるという話。&lt;/p&gt;
&lt;h2 id="section-3"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="philippseithsignalr-signalr-server-and-client-in-go"&gt;philippseith/signalr: SignalR server and client in go&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/philippseith/signalr"&gt;https://github.com/philippseith/signalr&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Go による SignalR のサーバーとクライアント実装。&lt;/p&gt;
&lt;h2 id="section-4"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="section-5"&gt;ツイート&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Not sure when it happened but Visual Studio 2019 is now in the Microsoft Store on Windows 11 :D pic.twitter.com/hHElUUZ5yz— Zac Bowden (&amp;#64;zacbowden) August 24, 2021&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://twitter.com/zacbowden/status/1430183656677683219"&gt;https://twitter.com/zacbowden/status/1430183656677683219&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2019 が Microsoft Store (Windows 11 のストア)から入手可能に。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;IL Language view has been improved by showing opcode bytes (for next release) pic.twitter.com/iljS3gcyA1— ILSpy Team (&amp;#64;ilspy) August 26, 2021&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://twitter.com/ilspy/status/1430882132596072451?s=12"&gt;https://twitter.com/ilspy/status/1430882132596072451?s=12&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ILSpy の時期リリースで IL Language ビューにオペコードバイト列も表示されるように。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="enable-sockethttphandler-to-decompress-zlib-or-deflate-by-stephentoub-pull-request-57862-dotnetruntime"&gt;Enable SocketHttpHandler to decompress zlib or deflate by stephentoub · Pull Request #57862 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/57862"&gt;https://github.com/dotnet/runtime/pull/57862&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;従来 SocketsHttpHandler では &lt;code&gt;Content-Encoding: deflate&lt;/code&gt; を DeflateStream で展開していたところ、&lt;code&gt;deflate&lt;/code&gt; の圧縮は zlib 形式で互換性がないことがあったので .NET 6 で ZLibStream クラスを新たに用意してそちらを使用するようにしたが、実際はどちらのパターンもあるので自動でスイッチするようにするという PR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/57940"&gt;[release/6.0-rc1] Enable SocketHttpHandler to decompress zlib or deflate by github-actions · Pull Request #57940 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/38022"&gt;HttpClient doesn't decompress &amp;quot;deflate&amp;quot; correctly · Issue #38022 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/42717"&gt;Implement ZLibStream and fix SocketsHttpHandler deflate support by stephentoub · Pull Request #42717 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/issues/57604"&gt;HttpClient deflate decompression error · Issue #57604 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="update-components-to-use-loggermessage-by-pranavkm-pull-request-35585-dotnetaspnetcore"&gt;Update Components to use LoggerMessage by pranavkm · Pull Request #35585 · dotnet/aspnetcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/pull/35585"&gt;https://github.com/dotnet/aspnetcore/pull/35585&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core での Source Generator を使用したロガーへの置き換えの PR。&lt;/p&gt;
&lt;h3 id="use-lambda-expression-and-method-group-signature-in-type-inference-by-cston-pull-request-55786-dotnetroslyn-github"&gt;Use lambda expression and method group signature in type inference by cston · Pull Request #55786 · dotnet/roslyn · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/55786"&gt;https://github.com/dotnet/roslyn/pull/55786&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ラムダ式の型推論の強化の PR。&lt;/p&gt;
&lt;h3 id="migrate-loggermessagegenerator-to-iincrementalgenerator-by-eerhardt-pull-request-58068-dotnetruntime"&gt;Migrate LoggerMessageGenerator to IIncrementalGenerator by eerhardt · Pull Request #58068 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/pull/58068"&gt;https://github.com/dotnet/runtime/pull/58068&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ロガーのコード生成を行う Source Generator である LoggerMessageGenerator を新しい仕組みの IIncrementalGenerator に移行したいという PR。&lt;/p&gt;
&lt;h3 id="web-relax-the-induced-gc-strategy-in-serverdispatcher-by-sharwell-pull-request-55814-dotnetroslyn"&gt;Web Relax the induced GC strategy in ServerDispatcher by sharwell · Pull Request #55814 · dotnet/roslyn&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/roslyn/pull/55814"&gt;https://github.com/dotnet/roslyn/pull/55814&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;VBCSCompiler (コンパイラーサーバー) がクリーンナップのために定期的に GC を実行するが、何度も実行する形になっていて CPU を消費しているので &lt;code&gt;GC.GetTotalMemory(forceFullCollection: true);&lt;/code&gt; 一回で終わらせるようにする PR。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/roslyn/issues/55807"&gt;Roslyn Compiler Service is forcing unneeded GCs, wasting CPU time · Issue #55807 · dotnet/roslyn&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;元々は VBCSCompiler がメモリリークしている(ように見えているだけ)という強いフィードバックがあり、見かけ上減らしたかったためこのようなコードを実行していた。この処理を行うことでのパフォーマンス上のインパクトは大きくないかあるいは WeakReference が回収される分悪くなる可能性もある。なお GC を11回実行していたのは実験した結果、GC 中の Finalizer などで生き残ってしまうものも含めて処理するにはそれぐらいが良かったからとのこと。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;GC.GetTotalMemory(forceFullCollection: true)&lt;/code&gt; では同様に繰り返し GC を呼び出して縮めるがある程度効果のあるまでという仕組みになっている。
&lt;a href="https://github.com/dotnet/runtime/blob/7994e5940d8e093e6a7a6008358b539f9d8a352d/src/coreclr/System.Private.CoreLib/src/System/GC.cs#L331-L353"&gt;https://github.com/dotnet/runtime/blob/7994e5940d8e093e6a7a6008358b539f9d8a352d/src/coreclr/System.Private.CoreLib/src/System/GC.cs#L331-L353&lt;/a&gt;&lt;/p&gt;
&lt;h3 id="automatically-provide-global-using-by-kzu-pull-request-516-spectreconsolespectre.console"&gt;Automatically provide global using by kzu · Pull Request #516 · spectreconsole/spectre.console&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/spectreconsole/spectre.console/pull/516"&gt;https://github.com/spectreconsole/spectre.console/pull/516&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;パッケージに .props を入れておくことで global usings を有効にする方法を使った例&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
		<item>
			<title>2021-08-20</title>
			<link>/2021/08/20/updates</link>
			<description>.NET 関連の情報をほぼ週刊配信</description>
			<author>Mayuki Sawatari</author>
			<enclosure url="/img/logo.png" length="0" type="image" />
			<guid isPermaLink="false">/2021/08/20/updates</guid>
			<pubDate>Fri, 20 Aug 2021 00:00:00 GMT</pubDate>
			<content:encoded>&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;!--
# yyyy-MM-dd
## 主なトピックス
## ヘッドライン
## アーティクル、スライドなど
## ライブラリ、リポジトリ、ツールなど
## サイト、ドキュメントなど
### ツイート
## Deep Dive
--&gt;
&lt;h2 id="section"&gt;主なトピックス&lt;/h2&gt;
&lt;p&gt;今週は .NET 6 Preview 7 と Visual Studio 2022 のフォローアップがメインです。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/"&gt;Performance Improvements in .NET 6 | .NET Blog&lt;/a&gt; はなかなかボリュームのある形で .NET 6 でのパフォーマンス改善についてベンチマークやアセンブリを見せながら説明されています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/revamped-project-properties-ui/"&gt;Revamped Project Properties UI | Visual Studio Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/flexible-theming-visual-studio/"&gt;Flexible theming capabilities for Visual Studio | Visual Studio Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/debugging-external-sources-with-visual-studio/"&gt;Debugging External Sources with Visual Studio | Visual Studio Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/improving-developer-security-with-visual-studio-2022/"&gt;Improving developer security with Visual Studio 2022 | Visual Studio Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;.NET のリポジトリがそろそろ .NET 7 に向けて準備を始めていることもちらほら見えています。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/announcements/issues/198"&gt;Main is now targeting .NET 7 · Issue #198 · dotnet/announcements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="section-1"&gt;ヘッドライン&lt;/h2&gt;
&lt;h3 id="breaking-change-with-string.indexofstring-from.net-core-3.0.net-5.0-issue-43736-dotnetruntime"&gt;Breaking change with string.IndexOf(string) from .NET Core 3.0 -&amp;gt; .NET 5.0 · Issue #43736 · dotnet/runtime&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/runtime/issues/43736"&gt;https://github.com/dotnet/runtime/issues/43736&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 5 でグローバリゼーションのライブラリが NLS から ICU へと変わった結果、Windows 上で &lt;code&gt;IndexOf, LastIndexOf, IsSuffix, IsPrefix&lt;/code&gt; といった文字列比較の結果が以前と変化した。例えば &lt;code&gt;&amp;quot;\r\n&amp;quot;.IndexOf(&amp;quot;\n&amp;quot;)&lt;/code&gt; が &lt;code&gt;-1&lt;/code&gt; となってしまったので ICU の Break Iterator をカスタマイズすることで従来の振る舞いになるように修正された。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/runtime/pull/57078"&gt;Fix the string search behavior when using ICU by tarekgh · Pull Request #57078 · dotnet/runtime&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="main-is-now-targeting.net-7-issue-198-dotnetannouncements"&gt;Main is now targeting .NET 7 · Issue #198 · dotnet/announcements&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/announcements/issues/198"&gt;https://github.com/dotnet/announcements/issues/198&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 RC1 以降各種 dotnet のリポジトリの main ブランチが .NET 7 をターゲットにするように。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/aspnetcore/pull/35428"&gt;Update branding to 7.0.0-alpha1 by wtgodbe · Pull Request #35428 · dotnet/aspnetcore&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/installer/pull/11566"&gt;Update Versions.props for 7.0.1xx by marcpopMSFT · Pull Request #11566 · dotnet/installer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/efcore/pull/25561"&gt;Update branding to 7.0.0-alpha1 by wtgodbe · Pull Request #25561 · dotnet/efcore&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="net-core-2.1-container-images-will-be-deleted-from-docker-hub.net-blog"&gt;.NET Core 2.1 container images will be deleted from Docker Hub | .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/net-core-2-1-container-images-will-be-deleted-from-docker-hub/"&gt;https://devblogs.microsoft.com/dotnet/net-core-2-1-container-images-will-be-deleted-from-docker-hub/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Core 2.1 のサポートが2021年8月21日で終了することに伴い Docker Hub から .NET Core 2.1 のコンテナーイメージを削除。継続してイメージを利用したい場合は MCR (mcr.microsoft.com) でホストされるものへの移行が必要。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/net-core-2-1-will-reach-end-of-support-on-august-21-2021/"&gt;.NET Core 2.1 will reach End of Support on August 21, 2021 | .NET Blog&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/dotnet/announcements/issues/197"&gt;.NET Core 2.1 container images will be deleted from Docker Hub · Issue #197 · dotnet/announcements&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="fluent-assertions-6.0-the-biggest-release-ever"&gt;Fluent Assertions 6.0, the biggest release ever&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ddoomen.medium.com/fluent-assertions-6-0-the-biggest-release-ever-5086a7bfa13e"&gt;https://ddoomen.medium.com/fluent-assertions-6-0-the-biggest-release-ever-5086a7bfa13e&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Fluent Assertions 6.0 がリリース。&lt;/p&gt;
&lt;p&gt;.NET Framework 4.5, .NET Standard 1.3, 1.6 および MSTest, NSpec v1 and 2, xUnit 1, Gallio, MBUnit のサポートが削除。async 関連の改善が多く行われた。マイグレーションについては&lt;a href="https://fluentassertions.com/upgradingtov6"&gt;ガイドを参照&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;BufferedStream&lt;/code&gt;, &lt;code&gt;TaskCompletionSource&amp;lt;T&amp;gt;&lt;/code&gt;, &lt;code&gt;enum&lt;/code&gt;, &lt;code&gt;IReadOnlyDictionary&amp;lt;K, V&amp;gt;&lt;/code&gt; のサポートの追加。構造的な等価アサーションの改善など。&lt;/p&gt;
&lt;h3 id="version-6.0.0-preview7-of-npgsql-and-the-efcore-provider-for-postgres-are-now-available-on-nuget.org"&gt;Version 6.0.0-preview7 of #npgsql and the #efcore provider for #postgres are now available on nuget.org.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://twitter.com/shayrojansky/status/1427264414093299715"&gt;https://twitter.com/shayrojansky/status/1427264414093299715&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Npgsql と Npgsql Entity Framework Core Provider の 6.0.0-preview 7 がリリース。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/npgsql/npgsql/releases/tag/v6.0.0-preview7"&gt;Release v6.0.0-preview7 · npgsql/npgsql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://github.com/npgsql/efcore.pg/releases/tag/v6.0.0-preview7"&gt;Release v6.0.0-preview7 · npgsql/efcore.pg&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="release-ef-core-5.0.9-dotnetefcore"&gt;Release EF Core 5.0.9 · dotnet/efcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/efcore/releases/tag/v5.0.9"&gt;https://github.com/dotnet/efcore/releases/tag/v5.0.9&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 5.0.9 がリリース。いくつかのバグ修正。&lt;/p&gt;
&lt;h3 id="mvvm-light-is-not-maintained-anymore"&gt;MVVM Light is not maintained anymore.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/lbugnion/mvvmlight"&gt;https://github.com/lbugnion/mvvmlight&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;MVVM Light Toolkit がライブラリメンテナンス終了のアナウンス。今後は &lt;a href="https://github.com/CommunityToolkit/WindowsCommunityToolkit"&gt;Windows Community Toolkit&lt;/a&gt; の &lt;a href="https://docs.microsoft.com/en-us/windows/communitytoolkit/mvvm/introduction"&gt;Microsoft MVVM Toolkit&lt;/a&gt; の利用を推奨。&lt;/p&gt;
&lt;h3 id="introducing-devops-friendly-ef-core-migration-bundles.net-blog"&gt;Introducing DevOps-friendly EF Core Migration Bundles | .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/introducing-devops-friendly-ef-core-migration-bundles/"&gt;https://devblogs.microsoft.com/dotnet/introducing-devops-friendly-ef-core-migration-bundles/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Entity Framework Core 6.0.0-preview7 で利用可能になった migration bundle について。&lt;/p&gt;
&lt;h3 id="support-prerelease-for-dotnet-tool-by-wli3-pull-request-19646-dotnetsdk"&gt;support --prerelease for dotnet tool by wli3 · Pull Request #19646 · dotnet/sdk&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/sdk/pull/19646"&gt;https://github.com/dotnet/sdk/pull/19646&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET Global/Local Tools でインストールするパッケージとして prerelease としてマークされているものをインストールできるようにするフラグが追加(今までは NuGet パッケージにはあったが .NET Tools にはなかった)。&lt;/p&gt;
&lt;h2 id="section-2"&gt;アーティクル&lt;/h2&gt;
&lt;h3 id="performance-improvements-in.net-6.net-blog"&gt;Performance Improvements in .NET 6 | .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/"&gt;https://devblogs.microsoft.com/dotnet/performance-improvements-in-net-6/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[あとで書く]&lt;/p&gt;
&lt;h3 id="understanding-the-cost-of-c-delegates.net-blog"&gt;Understanding the cost of C# delegates | .NET Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/dotnet/understanding-the-cost-of-csharp-delegates/"&gt;https://devblogs.microsoft.com/dotnet/understanding-the-cost-of-csharp-delegates/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;デリゲートのインスタンスのコスト、ラムダ式を使った際に発生するインスタンス生成について。&lt;/p&gt;
&lt;h3 id="revamped-project-properties-ui-visual-studio-blog"&gt;Revamped Project Properties UI | Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/revamped-project-properties-ui/"&gt;https://devblogs.microsoft.com/visualstudio/revamped-project-properties-ui/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 でのプロジェクトプロパティ画面の刷新されることの解説。Visual Studio のテーマに応じた外観、設定項目の検索、プロパティの評価値のプレビューなど。&lt;/p&gt;
&lt;h3 id="flexible-theming-capabilities-for-visual-studio-visual-studio-blog"&gt;Flexible theming capabilities for Visual Studio | Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/flexible-theming-visual-studio/"&gt;https://devblogs.microsoft.com/visualstudio/flexible-theming-visual-studio/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 のテーマについて。システムのテーマ (Windows の Dark / Light モード) に合わせて変更する設定が追加。&lt;/p&gt;
&lt;h3 id="debugging-external-sources-with-visual-studio-visual-studio-blog"&gt;Debugging External Sources with Visual Studio | Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/debugging-external-sources-with-visual-studio/"&gt;https://devblogs.microsoft.com/visualstudio/debugging-external-sources-with-visual-studio/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 Preview 3 で追加された External Source についての解説。&lt;/p&gt;
&lt;p&gt;.NET の BCL や Newtonsoft.Json, CsvHelper, xUnit.net などのような Source Link や Symbol Server にアップロードされているソースコードを読み込み、Solution Explorer 上で展開してデバッグできる機能。&lt;/p&gt;
&lt;h3 id="improving-developer-security-with-visual-studio-2022-visual-studio-blog"&gt;Improving developer security with Visual Studio 2022 | Visual Studio Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://devblogs.microsoft.com/visualstudio/improving-developer-security-with-visual-studio-2022/"&gt;https://devblogs.microsoft.com/visualstudio/improving-developer-security-with-visual-studio-2022/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio 2022 で強化されるソリューションの読み込み時のセキュリティ機能について。デザインタイムビルドによってセキュリティ侵害が発生する可能性があるため、以前からプロジェクトを開く際に確認する仕組みが Visual Studio にはありその機能の刷新。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://code.visualstudio.com/docs/editor/workspace-trust"&gt;Visual Studio Code の Workspace Trust&lt;/a&gt; と似た機能で、フォルダー、git リポジトリ、リポジトリオーナーを Trusted Location に指定して信頼するか、信頼しない Restrict モードを選択する。Restrict モードではデザインタイムビルド (Analyzer やソース生成など) が機能しないようになる。ただし現時点の Preview ではまだ利用できない。&lt;/p&gt;
&lt;h3 id="c.net-6"&gt;最初の C# プログラム(.NET 6 新テンプレート)&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://ufcpp.net/blog/2021/8/newprojecttemplate/"&gt;https://ufcpp.net/blog/2021/8/newprojecttemplate/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 から使用される新しいプロジェクトテンプレートについて。&lt;code&gt;DisableImplicitNamespaceImports&lt;/code&gt;/&lt;code&gt;ImplicitUsings&lt;/code&gt; ディレクティブのような Preview 7 と RC 1 以降での違いについても。&lt;/p&gt;
&lt;h3 id="rider-2021.3-roadmap-the.net-tools-blog"&gt;Rider 2021.3 Roadmap | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/08/18/rider-2021-3-roadmap/"&gt;https://blog.jetbrains.com/dotnet/2021/08/18/rider-2021-3-roadmap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Rider 2021.3 のロードマップ。C# 10 や .NET 6 対応、次期 OS やApple Silicon 対応、Multiple Startup Projects、MAUI など。&lt;/p&gt;
&lt;h3 id="resharper-2021.3-roadmap-the.net-tools-blog"&gt;ReSharper 2021.3 Roadmap | The .NET Tools Blog&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://blog.jetbrains.com/dotnet/2021/08/18/resharper-2021-3-roadmap/"&gt;https://blog.jetbrains.com/dotnet/2021/08/18/resharper-2021-3-roadmap/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ReSharper 2021.3 のロードマップ。Visual Studio 2022 や C# 10 対応、LINQ Visualizer など。&lt;/p&gt;
&lt;h3 id="blazor-webassemblyauth0"&gt;Blazor WebAssemblyとAuth0でユーザー認証&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://zenn.dev/kaorumori/articles/b9f67f1e8946c2"&gt;https://zenn.dev/kaorumori/articles/b9f67f1e8946c2&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Blazor WebAssembly と Auth0 を組み合わせてユーザー認証を組み込む手順の解説。&lt;/p&gt;
&lt;h2 id="section-3"&gt;ライブラリ、リポジトリ、ツールなど&lt;/h2&gt;
&lt;h3 id="spectreconsolespectre.console-a.net-library-that-makes-it-easier-to-create-beautiful-console-applications"&gt;spectreconsole/spectre.console: A .NET library that makes it easier to create beautiful console applications.&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/spectreconsole/spectre.console"&gt;https://github.com/spectreconsole/spectre.console&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;コマンドラインアプリケーションの実装に関連するオールインワンライブラリー。&lt;/p&gt;
&lt;p&gt;コマンドラインパーサーからカラーリング、テーブル、入力補助などリッチなコンソールアプリケーションを実装できる。&lt;/p&gt;
&lt;h2 id="section-4"&gt;サイト、ドキュメントなど&lt;/h2&gt;
&lt;h3 id="various-goodies-from-dotnetos"&gt;Various goodies from Dotnetos!&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://goodies.dotnetos.org/"&gt;https://goodies.dotnetos.org/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET の診断、async、メモリに関するポスター画像や、スライド。&lt;/p&gt;
&lt;p&gt;ConfigureAwait と Deadlock に関する図やメモリレイアウトに関する図など。&lt;/p&gt;
&lt;h3 id="awesome-blazor-browser"&gt;Awesome Blazor Browser&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://jsakamoto.github.io/awesome-blazor-browser/"&gt;https://jsakamoto.github.io/awesome-blazor-browser/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;awesome-blazor をカテゴリごとに絞り込んだり検索できるようにしたサイト。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://github.com/AdrienTorris/awesome-blazor"&gt;AdrienTorris/awesome-blazor: Resources for Blazor, a .NET web framework using C#/Razor and HTML that runs in the browser with WebAssembly.&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id="visual-studio-extensibility-cookbook"&gt;Visual Studio Extensibility Cookbook&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://www.vsixcookbook.com/"&gt;https://www.vsixcookbook.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Visual Studio の拡張 VSIX を作るためのクックブック。拡張や開発の初めかたの手順などがまとまっている。&lt;/p&gt;
&lt;h3 id="section-5"&gt;ツイート&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;I have been open here with all of my work for the past decade, and I will be about leaving Stack Overflow as well. Here is what I sent to friends and family here at Stack, a place I will forever love and still highly recommend to any developer looking to improve the world: pic.twitter.com/E4Zxs6xDqF— Nick Craver (&amp;#64;Nick_Craver) August 16, 2021&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://twitter.com/nick_craver/status/1427323097380794371"&gt;https://twitter.com/nick_craver/status/1427323097380794371&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Nick Craver さんが Stack Exchange を離れることに。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ReadAtLeastAsync is one of my new favorite APIs in the latest version of System.IO.Pipelines. Makes reading length prefixed protocols a breeze. #dotnet pic.twitter.com/jNe1j04hbx— David Fowler 🇧🇧💉💉 (&amp;#64;davidfowl) August 15, 2021&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://twitter.com/davidfowl/status/1426719909971521536"&gt;https://twitter.com/davidfowl/status/1426719909971521536&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;.NET 6 の System.IO.Pipelines から使用できる、最小限必要な長さを指定して読み出す &lt;a href="https://docs.microsoft.com/en-us/dotnet/api/system.io.pipelines.pipereader.readatleastasync?view=dotnet-plat-ext-6.0"&gt;PipeReader.ReadAtLeastAsync メソッド&lt;/a&gt; について。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;We migrated Stack Overflow's ad server from .NET 4.6.2 to .NET 5.0 and we are testing it on a canary server in production. We are seeing big improvements in memory usage and in server response times. It wasn't the main goal of the migration, but definitely a nice to have. pic.twitter.com/Z1dkKfYQWp— Juan Rodríguez (&amp;#64;juanrodriguezce) August 18, 2021&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;a href="https://twitter.com/juanrodriguezce/status/1428070925698805771"&gt;https://twitter.com/juanrodriguezce/status/1428070925698805771&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Stack Overflow の広告サーバーを .NET 4.6.2 から .NET 5.0 に移行して、本番環境でのカナリアテストを行ったところメモリ使用量とレスポンスタイムが改善された。&lt;/p&gt;
&lt;h2 id="deep-dive"&gt;Deep Dive&lt;/h2&gt;
&lt;h3 id="more-loggermessageattribute-by-pranavkm-pull-request-35368-dotnetaspnetcore"&gt;More LoggerMessageAttribute by pranavkm · Pull Request #35368 · dotnet/aspnetcore&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/pull/35368"&gt;https://github.com/dotnet/aspnetcore/pull/35368&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ASP.NET Core のロガーを LoggerMessage を使う形から Source Generator によって生成するようにする PR。&lt;/p&gt;
&lt;h3 id="use-poolingasyncvaluetaskmethodbuilder-on-various-readasync-methods.by-adityamandaleeka-pull-request-35011-dotnetaspnetcore-github"&gt;Use PoolingAsyncValueTaskMethodBuilder on various ReadAsync methods. by adityamandaleeka · Pull Request #35011 · dotnet/aspnetcore · GitHub&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/dotnet/aspnetcore/pull/35011"&gt;https://github.com/dotnet/aspnetcore/pull/35011&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Kestrel のボディの読み取りメソッドに &lt;code&gt;PoolingAsyncValueTaskMethodBuilder&lt;/code&gt; を使用することでアロケーションを抑える PR。&lt;/p&gt;
</content:encoded>
			<comments xmlns="http://purl.org/rss/1.0/modules/slash/">0</comments>
		</item>
	</channel>
</rss>